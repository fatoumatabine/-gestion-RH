
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Entreprise
 * 
 */
export type Entreprise = $Result.DefaultSelection<Prisma.$EntreprisePayload>
/**
 * Model JournalAudit
 * 
 */
export type JournalAudit = $Result.DefaultSelection<Prisma.$JournalAuditPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model CompanyFacture
 * 
 */
export type CompanyFacture = $Result.DefaultSelection<Prisma.$CompanyFacturePayload>
/**
 * Model CompanyLigneFacture
 * 
 */
export type CompanyLigneFacture = $Result.DefaultSelection<Prisma.$CompanyLigneFacturePayload>
/**
 * Model CompanyPayRun
 * 
 */
export type CompanyPayRun = $Result.DefaultSelection<Prisma.$CompanyPayRunPayload>
/**
 * Model CompanyBulletin
 * 
 */
export type CompanyBulletin = $Result.DefaultSelection<Prisma.$CompanyBulletinPayload>
/**
 * Model CompanyPaiement
 * 
 */
export type CompanyPaiement = $Result.DefaultSelection<Prisma.$CompanyPaiementPayload>
/**
 * Model CompanyTemplate
 * 
 */
export type CompanyTemplate = $Result.DefaultSelection<Prisma.$CompanyTemplatePayload>
/**
 * Model CompanySetting
 * 
 */
export type CompanySetting = $Result.DefaultSelection<Prisma.$CompanySettingPayload>
/**
 * Model CompanyDocument
 * 
 */
export type CompanyDocument = $Result.DefaultSelection<Prisma.$CompanyDocumentPayload>
/**
 * Model CompanyModeleDocument
 * 
 */
export type CompanyModeleDocument = $Result.DefaultSelection<Prisma.$CompanyModeleDocumentPayload>
/**
 * Model CompanyPeriodePaie
 * 
 */
export type CompanyPeriodePaie = $Result.DefaultSelection<Prisma.$CompanyPeriodePaiePayload>
/**
 * Model CompanyConfigurationPaie
 * 
 */
export type CompanyConfigurationPaie = $Result.DefaultSelection<Prisma.$CompanyConfigurationPaiePayload>
/**
 * Model CompanyHistoriqueSalaire
 * 
 */
export type CompanyHistoriqueSalaire = $Result.DefaultSelection<Prisma.$CompanyHistoriqueSalairePayload>
/**
 * Model CompanyRegleDeduction
 * 
 */
export type CompanyRegleDeduction = $Result.DefaultSelection<Prisma.$CompanyRegleDeductionPayload>
/**
 * Model Pointage
 * 
 */
export type Pointage = $Result.DefaultSelection<Prisma.$PointagePayload>
/**
 * Model ReglePointage
 * 
 */
export type ReglePointage = $Result.DefaultSelection<Prisma.$ReglePointagePayload>
/**
 * Model Absence
 * 
 */
export type Absence = $Result.DefaultSelection<Prisma.$AbsencePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  CASHIER: 'CASHIER',
  SUPERADMIN: 'SUPERADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const EmployeeStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  TERMINATED: 'TERMINATED'
};

export type EmployeeStatus = (typeof EmployeeStatus)[keyof typeof EmployeeStatus]


export const ContractType: {
  FIXED_SALARY: 'FIXED_SALARY',
  DAILY: 'DAILY',
  HOURLY: 'HOURLY'
};

export type ContractType = (typeof ContractType)[keyof typeof ContractType]


export const PaymentMethod: {
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHECK: 'CHECK',
  MOBILE_MONEY: 'MOBILE_MONEY'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSED: 'PROCESSED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const NotificationType: {
  INFO: 'INFO',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const CompanyStatutFacture: {
  EN_ATTENTE: 'EN_ATTENTE',
  PAYEE: 'PAYEE',
  ANNULEE: 'ANNULEE'
};

export type CompanyStatutFacture = (typeof CompanyStatutFacture)[keyof typeof CompanyStatutFacture]


export const CompanyStatutPayRun: {
  BROUILLON: 'BROUILLON',
  EN_COURS: 'EN_COURS',
  EN_ATTENTE_APPROBATION: 'EN_ATTENTE_APPROBATION',
  APPROUVE: 'APPROUVE',
  REJETE: 'REJETE',
  COMPLETE: 'COMPLETE',
  ANNULE: 'ANNULE'
};

export type CompanyStatutPayRun = (typeof CompanyStatutPayRun)[keyof typeof CompanyStatutPayRun]


export const CompanyStatutPaiement: {
  EN_ATTENTE: 'EN_ATTENTE',
  TRAITE: 'TRAITE',
  ECHOUE: 'ECHOUE',
  ANNULE: 'ANNULE'
};

export type CompanyStatutPaiement = (typeof CompanyStatutPaiement)[keyof typeof CompanyStatutPaiement]


export const CompanyMethodePaiement: {
  ESPECES: 'ESPECES',
  CHEQUE: 'CHEQUE',
  VIREMENT: 'VIREMENT',
  MOBILE_MONEY: 'MOBILE_MONEY',
  AUTRE: 'AUTRE'
};

export type CompanyMethodePaiement = (typeof CompanyMethodePaiement)[keyof typeof CompanyMethodePaiement]


export const StatutPointage: {
  PRESENT: 'PRESENT',
  RETARD: 'RETARD',
  DEPART_ANTICIPE: 'DEPART_ANTICIPE',
  ABSENT: 'ABSENT',
  CONGE: 'CONGE',
  MALADIE: 'MALADIE',
  AUTRE: 'AUTRE'
};

export type StatutPointage = (typeof StatutPointage)[keyof typeof StatutPointage]


export const TypePointage: {
  NORMAL: 'NORMAL',
  RETARD_JUSTIFIE: 'RETARD_JUSTIFIE',
  DEPART_ANTICIPE_JUSTIFIE: 'DEPART_ANTICIPE_JUSTIFIE',
  HEURES_SUPPLEMENTAIRES: 'HEURES_SUPPLEMENTAIRES',
  TRAVAIL_NUIT: 'TRAVAIL_NUIT',
  FERIE: 'FERIE'
};

export type TypePointage = (typeof TypePointage)[keyof typeof TypePointage]


export const TypeAbsence: {
  CONGE_ANNUEL: 'CONGE_ANNUEL',
  CONGE_MALADIE: 'CONGE_MALADIE',
  CONGE_MATERNITE: 'CONGE_MATERNITE',
  CONGE_PATERNITE: 'CONGE_PATERNITE',
  CONGE_EXCEPTIONNEL: 'CONGE_EXCEPTIONNEL',
  ABSENCE_NON_JUSTIFIEE: 'ABSENCE_NON_JUSTIFIEE',
  ACCIDENT_TRAVAIL: 'ACCIDENT_TRAVAIL',
  FORMATION: 'FORMATION',
  AUTRE: 'AUTRE'
};

export type TypeAbsence = (typeof TypeAbsence)[keyof typeof TypeAbsence]


export const StatutAbsence: {
  EN_ATTENTE: 'EN_ATTENTE',
  APPROUVEE: 'APPROUVEE',
  REJETEE: 'REJETEE',
  ANNULEE: 'ANNULEE'
};

export type StatutAbsence = (typeof StatutAbsence)[keyof typeof StatutAbsence]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type EmployeeStatus = $Enums.EmployeeStatus

export const EmployeeStatus: typeof $Enums.EmployeeStatus

export type ContractType = $Enums.ContractType

export const ContractType: typeof $Enums.ContractType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type CompanyStatutFacture = $Enums.CompanyStatutFacture

export const CompanyStatutFacture: typeof $Enums.CompanyStatutFacture

export type CompanyStatutPayRun = $Enums.CompanyStatutPayRun

export const CompanyStatutPayRun: typeof $Enums.CompanyStatutPayRun

export type CompanyStatutPaiement = $Enums.CompanyStatutPaiement

export const CompanyStatutPaiement: typeof $Enums.CompanyStatutPaiement

export type CompanyMethodePaiement = $Enums.CompanyMethodePaiement

export const CompanyMethodePaiement: typeof $Enums.CompanyMethodePaiement

export type StatutPointage = $Enums.StatutPointage

export const StatutPointage: typeof $Enums.StatutPointage

export type TypePointage = $Enums.TypePointage

export const TypePointage: typeof $Enums.TypePointage

export type TypeAbsence = $Enums.TypeAbsence

export const TypeAbsence: typeof $Enums.TypeAbsence

export type StatutAbsence = $Enums.StatutAbsence

export const StatutAbsence: typeof $Enums.StatutAbsence

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entreprise`: Exposes CRUD operations for the **Entreprise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entreprises
    * const entreprises = await prisma.entreprise.findMany()
    * ```
    */
  get entreprise(): Prisma.EntrepriseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalAudit`: Exposes CRUD operations for the **JournalAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalAudits
    * const journalAudits = await prisma.journalAudit.findMany()
    * ```
    */
  get journalAudit(): Prisma.JournalAuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyFacture`: Exposes CRUD operations for the **CompanyFacture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyFactures
    * const companyFactures = await prisma.companyFacture.findMany()
    * ```
    */
  get companyFacture(): Prisma.CompanyFactureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyLigneFacture`: Exposes CRUD operations for the **CompanyLigneFacture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyLigneFactures
    * const companyLigneFactures = await prisma.companyLigneFacture.findMany()
    * ```
    */
  get companyLigneFacture(): Prisma.CompanyLigneFactureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyPayRun`: Exposes CRUD operations for the **CompanyPayRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyPayRuns
    * const companyPayRuns = await prisma.companyPayRun.findMany()
    * ```
    */
  get companyPayRun(): Prisma.CompanyPayRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyBulletin`: Exposes CRUD operations for the **CompanyBulletin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyBulletins
    * const companyBulletins = await prisma.companyBulletin.findMany()
    * ```
    */
  get companyBulletin(): Prisma.CompanyBulletinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyPaiement`: Exposes CRUD operations for the **CompanyPaiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyPaiements
    * const companyPaiements = await prisma.companyPaiement.findMany()
    * ```
    */
  get companyPaiement(): Prisma.CompanyPaiementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyTemplate`: Exposes CRUD operations for the **CompanyTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyTemplates
    * const companyTemplates = await prisma.companyTemplate.findMany()
    * ```
    */
  get companyTemplate(): Prisma.CompanyTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companySetting`: Exposes CRUD operations for the **CompanySetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanySettings
    * const companySettings = await prisma.companySetting.findMany()
    * ```
    */
  get companySetting(): Prisma.CompanySettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyDocument`: Exposes CRUD operations for the **CompanyDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyDocuments
    * const companyDocuments = await prisma.companyDocument.findMany()
    * ```
    */
  get companyDocument(): Prisma.CompanyDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyModeleDocument`: Exposes CRUD operations for the **CompanyModeleDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyModeleDocuments
    * const companyModeleDocuments = await prisma.companyModeleDocument.findMany()
    * ```
    */
  get companyModeleDocument(): Prisma.CompanyModeleDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyPeriodePaie`: Exposes CRUD operations for the **CompanyPeriodePaie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyPeriodePaies
    * const companyPeriodePaies = await prisma.companyPeriodePaie.findMany()
    * ```
    */
  get companyPeriodePaie(): Prisma.CompanyPeriodePaieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyConfigurationPaie`: Exposes CRUD operations for the **CompanyConfigurationPaie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyConfigurationPaies
    * const companyConfigurationPaies = await prisma.companyConfigurationPaie.findMany()
    * ```
    */
  get companyConfigurationPaie(): Prisma.CompanyConfigurationPaieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyHistoriqueSalaire`: Exposes CRUD operations for the **CompanyHistoriqueSalaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyHistoriqueSalaires
    * const companyHistoriqueSalaires = await prisma.companyHistoriqueSalaire.findMany()
    * ```
    */
  get companyHistoriqueSalaire(): Prisma.CompanyHistoriqueSalaireDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyRegleDeduction`: Exposes CRUD operations for the **CompanyRegleDeduction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyRegleDeductions
    * const companyRegleDeductions = await prisma.companyRegleDeduction.findMany()
    * ```
    */
  get companyRegleDeduction(): Prisma.CompanyRegleDeductionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointage`: Exposes CRUD operations for the **Pointage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pointages
    * const pointages = await prisma.pointage.findMany()
    * ```
    */
  get pointage(): Prisma.PointageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reglePointage`: Exposes CRUD operations for the **ReglePointage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReglePointages
    * const reglePointages = await prisma.reglePointage.findMany()
    * ```
    */
  get reglePointage(): Prisma.ReglePointageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.absence`: Exposes CRUD operations for the **Absence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Absences
    * const absences = await prisma.absence.findMany()
    * ```
    */
  get absence(): Prisma.AbsenceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Employee: 'Employee',
    Entreprise: 'Entreprise',
    JournalAudit: 'JournalAudit',
    Payment: 'Payment',
    Notification: 'Notification',
    CompanyFacture: 'CompanyFacture',
    CompanyLigneFacture: 'CompanyLigneFacture',
    CompanyPayRun: 'CompanyPayRun',
    CompanyBulletin: 'CompanyBulletin',
    CompanyPaiement: 'CompanyPaiement',
    CompanyTemplate: 'CompanyTemplate',
    CompanySetting: 'CompanySetting',
    CompanyDocument: 'CompanyDocument',
    CompanyModeleDocument: 'CompanyModeleDocument',
    CompanyPeriodePaie: 'CompanyPeriodePaie',
    CompanyConfigurationPaie: 'CompanyConfigurationPaie',
    CompanyHistoriqueSalaire: 'CompanyHistoriqueSalaire',
    CompanyRegleDeduction: 'CompanyRegleDeduction',
    Pointage: 'Pointage',
    ReglePointage: 'ReglePointage',
    Absence: 'Absence'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "employee" | "entreprise" | "journalAudit" | "payment" | "notification" | "companyFacture" | "companyLigneFacture" | "companyPayRun" | "companyBulletin" | "companyPaiement" | "companyTemplate" | "companySetting" | "companyDocument" | "companyModeleDocument" | "companyPeriodePaie" | "companyConfigurationPaie" | "companyHistoriqueSalaire" | "companyRegleDeduction" | "pointage" | "reglePointage" | "absence"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Entreprise: {
        payload: Prisma.$EntreprisePayload<ExtArgs>
        fields: Prisma.EntrepriseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntrepriseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntrepriseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          findFirst: {
            args: Prisma.EntrepriseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntrepriseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          findMany: {
            args: Prisma.EntrepriseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>[]
          }
          create: {
            args: Prisma.EntrepriseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          createMany: {
            args: Prisma.EntrepriseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntrepriseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          update: {
            args: Prisma.EntrepriseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          deleteMany: {
            args: Prisma.EntrepriseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntrepriseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntrepriseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          aggregate: {
            args: Prisma.EntrepriseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntreprise>
          }
          groupBy: {
            args: Prisma.EntrepriseGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntrepriseGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntrepriseCountArgs<ExtArgs>
            result: $Utils.Optional<EntrepriseCountAggregateOutputType> | number
          }
        }
      }
      JournalAudit: {
        payload: Prisma.$JournalAuditPayload<ExtArgs>
        fields: Prisma.JournalAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload>
          }
          findFirst: {
            args: Prisma.JournalAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload>
          }
          findMany: {
            args: Prisma.JournalAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload>[]
          }
          create: {
            args: Prisma.JournalAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload>
          }
          createMany: {
            args: Prisma.JournalAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JournalAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload>
          }
          update: {
            args: Prisma.JournalAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload>
          }
          deleteMany: {
            args: Prisma.JournalAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalAuditPayload>
          }
          aggregate: {
            args: Prisma.JournalAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalAudit>
          }
          groupBy: {
            args: Prisma.JournalAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalAuditCountArgs<ExtArgs>
            result: $Utils.Optional<JournalAuditCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      CompanyFacture: {
        payload: Prisma.$CompanyFacturePayload<ExtArgs>
        fields: Prisma.CompanyFactureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFactureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFactureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload>
          }
          findFirst: {
            args: Prisma.CompanyFactureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFactureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload>
          }
          findMany: {
            args: Prisma.CompanyFactureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload>[]
          }
          create: {
            args: Prisma.CompanyFactureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload>
          }
          createMany: {
            args: Prisma.CompanyFactureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyFactureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload>
          }
          update: {
            args: Prisma.CompanyFactureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload>
          }
          deleteMany: {
            args: Prisma.CompanyFactureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyFactureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyFactureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyFacturePayload>
          }
          aggregate: {
            args: Prisma.CompanyFactureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyFacture>
          }
          groupBy: {
            args: Prisma.CompanyFactureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyFactureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyFactureCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyFactureCountAggregateOutputType> | number
          }
        }
      }
      CompanyLigneFacture: {
        payload: Prisma.$CompanyLigneFacturePayload<ExtArgs>
        fields: Prisma.CompanyLigneFactureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyLigneFactureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyLigneFactureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload>
          }
          findFirst: {
            args: Prisma.CompanyLigneFactureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyLigneFactureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload>
          }
          findMany: {
            args: Prisma.CompanyLigneFactureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload>[]
          }
          create: {
            args: Prisma.CompanyLigneFactureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload>
          }
          createMany: {
            args: Prisma.CompanyLigneFactureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyLigneFactureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload>
          }
          update: {
            args: Prisma.CompanyLigneFactureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload>
          }
          deleteMany: {
            args: Prisma.CompanyLigneFactureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyLigneFactureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyLigneFactureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyLigneFacturePayload>
          }
          aggregate: {
            args: Prisma.CompanyLigneFactureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyLigneFacture>
          }
          groupBy: {
            args: Prisma.CompanyLigneFactureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyLigneFactureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyLigneFactureCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyLigneFactureCountAggregateOutputType> | number
          }
        }
      }
      CompanyPayRun: {
        payload: Prisma.$CompanyPayRunPayload<ExtArgs>
        fields: Prisma.CompanyPayRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyPayRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyPayRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload>
          }
          findFirst: {
            args: Prisma.CompanyPayRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyPayRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload>
          }
          findMany: {
            args: Prisma.CompanyPayRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload>[]
          }
          create: {
            args: Prisma.CompanyPayRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload>
          }
          createMany: {
            args: Prisma.CompanyPayRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyPayRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload>
          }
          update: {
            args: Prisma.CompanyPayRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload>
          }
          deleteMany: {
            args: Prisma.CompanyPayRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyPayRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyPayRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayRunPayload>
          }
          aggregate: {
            args: Prisma.CompanyPayRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyPayRun>
          }
          groupBy: {
            args: Prisma.CompanyPayRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyPayRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyPayRunCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyPayRunCountAggregateOutputType> | number
          }
        }
      }
      CompanyBulletin: {
        payload: Prisma.$CompanyBulletinPayload<ExtArgs>
        fields: Prisma.CompanyBulletinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyBulletinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyBulletinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload>
          }
          findFirst: {
            args: Prisma.CompanyBulletinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyBulletinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload>
          }
          findMany: {
            args: Prisma.CompanyBulletinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload>[]
          }
          create: {
            args: Prisma.CompanyBulletinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload>
          }
          createMany: {
            args: Prisma.CompanyBulletinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyBulletinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload>
          }
          update: {
            args: Prisma.CompanyBulletinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload>
          }
          deleteMany: {
            args: Prisma.CompanyBulletinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyBulletinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyBulletinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyBulletinPayload>
          }
          aggregate: {
            args: Prisma.CompanyBulletinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyBulletin>
          }
          groupBy: {
            args: Prisma.CompanyBulletinGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyBulletinGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyBulletinCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyBulletinCountAggregateOutputType> | number
          }
        }
      }
      CompanyPaiement: {
        payload: Prisma.$CompanyPaiementPayload<ExtArgs>
        fields: Prisma.CompanyPaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyPaiementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyPaiementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload>
          }
          findFirst: {
            args: Prisma.CompanyPaiementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyPaiementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload>
          }
          findMany: {
            args: Prisma.CompanyPaiementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload>[]
          }
          create: {
            args: Prisma.CompanyPaiementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload>
          }
          createMany: {
            args: Prisma.CompanyPaiementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyPaiementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload>
          }
          update: {
            args: Prisma.CompanyPaiementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload>
          }
          deleteMany: {
            args: Prisma.CompanyPaiementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyPaiementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyPaiementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPaiementPayload>
          }
          aggregate: {
            args: Prisma.CompanyPaiementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyPaiement>
          }
          groupBy: {
            args: Prisma.CompanyPaiementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyPaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyPaiementCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyPaiementCountAggregateOutputType> | number
          }
        }
      }
      CompanyTemplate: {
        payload: Prisma.$CompanyTemplatePayload<ExtArgs>
        fields: Prisma.CompanyTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload>
          }
          findFirst: {
            args: Prisma.CompanyTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload>
          }
          findMany: {
            args: Prisma.CompanyTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload>[]
          }
          create: {
            args: Prisma.CompanyTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload>
          }
          createMany: {
            args: Prisma.CompanyTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload>
          }
          update: {
            args: Prisma.CompanyTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload>
          }
          deleteMany: {
            args: Prisma.CompanyTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTemplatePayload>
          }
          aggregate: {
            args: Prisma.CompanyTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyTemplate>
          }
          groupBy: {
            args: Prisma.CompanyTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyTemplateCountAggregateOutputType> | number
          }
        }
      }
      CompanySetting: {
        payload: Prisma.$CompanySettingPayload<ExtArgs>
        fields: Prisma.CompanySettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanySettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanySettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload>
          }
          findFirst: {
            args: Prisma.CompanySettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanySettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload>
          }
          findMany: {
            args: Prisma.CompanySettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload>[]
          }
          create: {
            args: Prisma.CompanySettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload>
          }
          createMany: {
            args: Prisma.CompanySettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanySettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload>
          }
          update: {
            args: Prisma.CompanySettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload>
          }
          deleteMany: {
            args: Prisma.CompanySettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanySettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanySettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingPayload>
          }
          aggregate: {
            args: Prisma.CompanySettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanySetting>
          }
          groupBy: {
            args: Prisma.CompanySettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanySettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanySettingCountArgs<ExtArgs>
            result: $Utils.Optional<CompanySettingCountAggregateOutputType> | number
          }
        }
      }
      CompanyDocument: {
        payload: Prisma.$CompanyDocumentPayload<ExtArgs>
        fields: Prisma.CompanyDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          findFirst: {
            args: Prisma.CompanyDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          findMany: {
            args: Prisma.CompanyDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>[]
          }
          create: {
            args: Prisma.CompanyDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          createMany: {
            args: Prisma.CompanyDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          update: {
            args: Prisma.CompanyDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyDocumentPayload>
          }
          aggregate: {
            args: Prisma.CompanyDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyDocument>
          }
          groupBy: {
            args: Prisma.CompanyDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyDocumentCountAggregateOutputType> | number
          }
        }
      }
      CompanyModeleDocument: {
        payload: Prisma.$CompanyModeleDocumentPayload<ExtArgs>
        fields: Prisma.CompanyModeleDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyModeleDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyModeleDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload>
          }
          findFirst: {
            args: Prisma.CompanyModeleDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyModeleDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload>
          }
          findMany: {
            args: Prisma.CompanyModeleDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload>[]
          }
          create: {
            args: Prisma.CompanyModeleDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload>
          }
          createMany: {
            args: Prisma.CompanyModeleDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyModeleDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload>
          }
          update: {
            args: Prisma.CompanyModeleDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload>
          }
          deleteMany: {
            args: Prisma.CompanyModeleDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyModeleDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyModeleDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyModeleDocumentPayload>
          }
          aggregate: {
            args: Prisma.CompanyModeleDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyModeleDocument>
          }
          groupBy: {
            args: Prisma.CompanyModeleDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyModeleDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyModeleDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyModeleDocumentCountAggregateOutputType> | number
          }
        }
      }
      CompanyPeriodePaie: {
        payload: Prisma.$CompanyPeriodePaiePayload<ExtArgs>
        fields: Prisma.CompanyPeriodePaieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyPeriodePaieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyPeriodePaieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload>
          }
          findFirst: {
            args: Prisma.CompanyPeriodePaieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyPeriodePaieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload>
          }
          findMany: {
            args: Prisma.CompanyPeriodePaieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload>[]
          }
          create: {
            args: Prisma.CompanyPeriodePaieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload>
          }
          createMany: {
            args: Prisma.CompanyPeriodePaieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyPeriodePaieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload>
          }
          update: {
            args: Prisma.CompanyPeriodePaieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload>
          }
          deleteMany: {
            args: Prisma.CompanyPeriodePaieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyPeriodePaieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyPeriodePaieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPeriodePaiePayload>
          }
          aggregate: {
            args: Prisma.CompanyPeriodePaieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyPeriodePaie>
          }
          groupBy: {
            args: Prisma.CompanyPeriodePaieGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyPeriodePaieGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyPeriodePaieCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyPeriodePaieCountAggregateOutputType> | number
          }
        }
      }
      CompanyConfigurationPaie: {
        payload: Prisma.$CompanyConfigurationPaiePayload<ExtArgs>
        fields: Prisma.CompanyConfigurationPaieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyConfigurationPaieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyConfigurationPaieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload>
          }
          findFirst: {
            args: Prisma.CompanyConfigurationPaieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyConfigurationPaieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload>
          }
          findMany: {
            args: Prisma.CompanyConfigurationPaieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload>[]
          }
          create: {
            args: Prisma.CompanyConfigurationPaieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload>
          }
          createMany: {
            args: Prisma.CompanyConfigurationPaieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyConfigurationPaieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload>
          }
          update: {
            args: Prisma.CompanyConfigurationPaieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload>
          }
          deleteMany: {
            args: Prisma.CompanyConfigurationPaieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyConfigurationPaieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyConfigurationPaieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyConfigurationPaiePayload>
          }
          aggregate: {
            args: Prisma.CompanyConfigurationPaieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyConfigurationPaie>
          }
          groupBy: {
            args: Prisma.CompanyConfigurationPaieGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyConfigurationPaieGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyConfigurationPaieCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyConfigurationPaieCountAggregateOutputType> | number
          }
        }
      }
      CompanyHistoriqueSalaire: {
        payload: Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>
        fields: Prisma.CompanyHistoriqueSalaireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyHistoriqueSalaireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyHistoriqueSalaireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload>
          }
          findFirst: {
            args: Prisma.CompanyHistoriqueSalaireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyHistoriqueSalaireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload>
          }
          findMany: {
            args: Prisma.CompanyHistoriqueSalaireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload>[]
          }
          create: {
            args: Prisma.CompanyHistoriqueSalaireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload>
          }
          createMany: {
            args: Prisma.CompanyHistoriqueSalaireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyHistoriqueSalaireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload>
          }
          update: {
            args: Prisma.CompanyHistoriqueSalaireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload>
          }
          deleteMany: {
            args: Prisma.CompanyHistoriqueSalaireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyHistoriqueSalaireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyHistoriqueSalaireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyHistoriqueSalairePayload>
          }
          aggregate: {
            args: Prisma.CompanyHistoriqueSalaireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyHistoriqueSalaire>
          }
          groupBy: {
            args: Prisma.CompanyHistoriqueSalaireGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyHistoriqueSalaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyHistoriqueSalaireCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyHistoriqueSalaireCountAggregateOutputType> | number
          }
        }
      }
      CompanyRegleDeduction: {
        payload: Prisma.$CompanyRegleDeductionPayload<ExtArgs>
        fields: Prisma.CompanyRegleDeductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyRegleDeductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyRegleDeductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload>
          }
          findFirst: {
            args: Prisma.CompanyRegleDeductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyRegleDeductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload>
          }
          findMany: {
            args: Prisma.CompanyRegleDeductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload>[]
          }
          create: {
            args: Prisma.CompanyRegleDeductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload>
          }
          createMany: {
            args: Prisma.CompanyRegleDeductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyRegleDeductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload>
          }
          update: {
            args: Prisma.CompanyRegleDeductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload>
          }
          deleteMany: {
            args: Prisma.CompanyRegleDeductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyRegleDeductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyRegleDeductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyRegleDeductionPayload>
          }
          aggregate: {
            args: Prisma.CompanyRegleDeductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyRegleDeduction>
          }
          groupBy: {
            args: Prisma.CompanyRegleDeductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyRegleDeductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyRegleDeductionCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyRegleDeductionCountAggregateOutputType> | number
          }
        }
      }
      Pointage: {
        payload: Prisma.$PointagePayload<ExtArgs>
        fields: Prisma.PointageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload>
          }
          findFirst: {
            args: Prisma.PointageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload>
          }
          findMany: {
            args: Prisma.PointageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload>[]
          }
          create: {
            args: Prisma.PointageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload>
          }
          createMany: {
            args: Prisma.PointageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PointageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload>
          }
          update: {
            args: Prisma.PointageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload>
          }
          deleteMany: {
            args: Prisma.PointageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointagePayload>
          }
          aggregate: {
            args: Prisma.PointageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointage>
          }
          groupBy: {
            args: Prisma.PointageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointageCountArgs<ExtArgs>
            result: $Utils.Optional<PointageCountAggregateOutputType> | number
          }
        }
      }
      ReglePointage: {
        payload: Prisma.$ReglePointagePayload<ExtArgs>
        fields: Prisma.ReglePointageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReglePointageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReglePointageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload>
          }
          findFirst: {
            args: Prisma.ReglePointageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReglePointageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload>
          }
          findMany: {
            args: Prisma.ReglePointageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload>[]
          }
          create: {
            args: Prisma.ReglePointageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload>
          }
          createMany: {
            args: Prisma.ReglePointageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReglePointageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload>
          }
          update: {
            args: Prisma.ReglePointageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload>
          }
          deleteMany: {
            args: Prisma.ReglePointageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReglePointageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReglePointageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReglePointagePayload>
          }
          aggregate: {
            args: Prisma.ReglePointageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReglePointage>
          }
          groupBy: {
            args: Prisma.ReglePointageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReglePointageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReglePointageCountArgs<ExtArgs>
            result: $Utils.Optional<ReglePointageCountAggregateOutputType> | number
          }
        }
      }
      Absence: {
        payload: Prisma.$AbsencePayload<ExtArgs>
        fields: Prisma.AbsenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbsenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbsenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          findFirst: {
            args: Prisma.AbsenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbsenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          findMany: {
            args: Prisma.AbsenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>[]
          }
          create: {
            args: Prisma.AbsenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          createMany: {
            args: Prisma.AbsenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AbsenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          update: {
            args: Prisma.AbsenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          deleteMany: {
            args: Prisma.AbsenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbsenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AbsenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbsencePayload>
          }
          aggregate: {
            args: Prisma.AbsenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbsence>
          }
          groupBy: {
            args: Prisma.AbsenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbsenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbsenceCountArgs<ExtArgs>
            result: $Utils.Optional<AbsenceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    employee?: EmployeeOmit
    entreprise?: EntrepriseOmit
    journalAudit?: JournalAuditOmit
    payment?: PaymentOmit
    notification?: NotificationOmit
    companyFacture?: CompanyFactureOmit
    companyLigneFacture?: CompanyLigneFactureOmit
    companyPayRun?: CompanyPayRunOmit
    companyBulletin?: CompanyBulletinOmit
    companyPaiement?: CompanyPaiementOmit
    companyTemplate?: CompanyTemplateOmit
    companySetting?: CompanySettingOmit
    companyDocument?: CompanyDocumentOmit
    companyModeleDocument?: CompanyModeleDocumentOmit
    companyPeriodePaie?: CompanyPeriodePaieOmit
    companyConfigurationPaie?: CompanyConfigurationPaieOmit
    companyHistoriqueSalaire?: CompanyHistoriqueSalaireOmit
    companyRegleDeduction?: CompanyRegleDeductionOmit
    pointage?: PointageOmit
    reglePointage?: ReglePointageOmit
    absence?: AbsenceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    journalAudit: number
    processedPayments: number
    notifications: number
    createdFactures: number
    createdPayRuns: number
    approvedPayRuns: number
    processedPaymentsCompany: number
    uploadedDocuments: number
    createdModeles: number
    modifiedSalaries: number
    validatedPointages: number
    approvedAbsences: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalAudit?: boolean | UserCountOutputTypeCountJournalAuditArgs
    processedPayments?: boolean | UserCountOutputTypeCountProcessedPaymentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    createdFactures?: boolean | UserCountOutputTypeCountCreatedFacturesArgs
    createdPayRuns?: boolean | UserCountOutputTypeCountCreatedPayRunsArgs
    approvedPayRuns?: boolean | UserCountOutputTypeCountApprovedPayRunsArgs
    processedPaymentsCompany?: boolean | UserCountOutputTypeCountProcessedPaymentsCompanyArgs
    uploadedDocuments?: boolean | UserCountOutputTypeCountUploadedDocumentsArgs
    createdModeles?: boolean | UserCountOutputTypeCountCreatedModelesArgs
    modifiedSalaries?: boolean | UserCountOutputTypeCountModifiedSalariesArgs
    validatedPointages?: boolean | UserCountOutputTypeCountValidatedPointagesArgs
    approvedAbsences?: boolean | UserCountOutputTypeCountApprovedAbsencesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJournalAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalAuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedFacturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFactureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPayRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPayRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedPayRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPayRunWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProcessedPaymentsCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPaiementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedModelesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyModeleDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModifiedSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyHistoriqueSalaireWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountValidatedPointagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedAbsencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbsenceWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    payments: number
    factures: number
    bulletins: number
    documents: number
    salaryHistory: number
    pointages: number
    absences: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | EmployeeCountOutputTypeCountPaymentsArgs
    factures?: boolean | EmployeeCountOutputTypeCountFacturesArgs
    bulletins?: boolean | EmployeeCountOutputTypeCountBulletinsArgs
    documents?: boolean | EmployeeCountOutputTypeCountDocumentsArgs
    salaryHistory?: boolean | EmployeeCountOutputTypeCountSalaryHistoryArgs
    pointages?: boolean | EmployeeCountOutputTypeCountPointagesArgs
    absences?: boolean | EmployeeCountOutputTypeCountAbsencesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountFacturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFactureWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountBulletinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBulletinWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSalaryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyHistoriqueSalaireWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPointagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointageWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAbsencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbsenceWhereInput
  }


  /**
   * Count Type EntrepriseCountOutputType
   */

  export type EntrepriseCountOutputType = {
    employees: number
    payRuns: number
    templates: number
    settings: number
    modeles: number
    periodesPaie: number
    configurationsPaie: number
  }

  export type EntrepriseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EntrepriseCountOutputTypeCountEmployeesArgs
    payRuns?: boolean | EntrepriseCountOutputTypeCountPayRunsArgs
    templates?: boolean | EntrepriseCountOutputTypeCountTemplatesArgs
    settings?: boolean | EntrepriseCountOutputTypeCountSettingsArgs
    modeles?: boolean | EntrepriseCountOutputTypeCountModelesArgs
    periodesPaie?: boolean | EntrepriseCountOutputTypeCountPeriodesPaieArgs
    configurationsPaie?: boolean | EntrepriseCountOutputTypeCountConfigurationsPaieArgs
  }

  // Custom InputTypes
  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntrepriseCountOutputType
     */
    select?: EntrepriseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountPayRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPayRunWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyTemplateWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySettingWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountModelesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyModeleDocumentWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountPeriodesPaieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPeriodePaieWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountConfigurationsPaieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyConfigurationPaieWhereInput
  }


  /**
   * Count Type CompanyFactureCountOutputType
   */

  export type CompanyFactureCountOutputType = {
    lignesFacture: number
  }

  export type CompanyFactureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignesFacture?: boolean | CompanyFactureCountOutputTypeCountLignesFactureArgs
  }

  // Custom InputTypes
  /**
   * CompanyFactureCountOutputType without action
   */
  export type CompanyFactureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFactureCountOutputType
     */
    select?: CompanyFactureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyFactureCountOutputType without action
   */
  export type CompanyFactureCountOutputTypeCountLignesFactureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyLigneFactureWhereInput
  }


  /**
   * Count Type CompanyPayRunCountOutputType
   */

  export type CompanyPayRunCountOutputType = {
    bulletins: number
  }

  export type CompanyPayRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bulletins?: boolean | CompanyPayRunCountOutputTypeCountBulletinsArgs
  }

  // Custom InputTypes
  /**
   * CompanyPayRunCountOutputType without action
   */
  export type CompanyPayRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRunCountOutputType
     */
    select?: CompanyPayRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyPayRunCountOutputType without action
   */
  export type CompanyPayRunCountOutputTypeCountBulletinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBulletinWhereInput
  }


  /**
   * Count Type CompanyBulletinCountOutputType
   */

  export type CompanyBulletinCountOutputType = {
    paiements: number
  }

  export type CompanyBulletinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiements?: boolean | CompanyBulletinCountOutputTypeCountPaiementsArgs
  }

  // Custom InputTypes
  /**
   * CompanyBulletinCountOutputType without action
   */
  export type CompanyBulletinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletinCountOutputType
     */
    select?: CompanyBulletinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyBulletinCountOutputType without action
   */
  export type CompanyBulletinCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPaiementWhereInput
  }


  /**
   * Count Type CompanyPeriodePaieCountOutputType
   */

  export type CompanyPeriodePaieCountOutputType = {
    payRuns: number
  }

  export type CompanyPeriodePaieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payRuns?: boolean | CompanyPeriodePaieCountOutputTypeCountPayRunsArgs
  }

  // Custom InputTypes
  /**
   * CompanyPeriodePaieCountOutputType without action
   */
  export type CompanyPeriodePaieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaieCountOutputType
     */
    select?: CompanyPeriodePaieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyPeriodePaieCountOutputType without action
   */
  export type CompanyPeriodePaieCountOutputTypeCountPayRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPayRunWhereInput
  }


  /**
   * Count Type CompanyConfigurationPaieCountOutputType
   */

  export type CompanyConfigurationPaieCountOutputType = {
    reglesDeduction: number
  }

  export type CompanyConfigurationPaieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reglesDeduction?: boolean | CompanyConfigurationPaieCountOutputTypeCountReglesDeductionArgs
  }

  // Custom InputTypes
  /**
   * CompanyConfigurationPaieCountOutputType without action
   */
  export type CompanyConfigurationPaieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaieCountOutputType
     */
    select?: CompanyConfigurationPaieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyConfigurationPaieCountOutputType without action
   */
  export type CompanyConfigurationPaieCountOutputTypeCountReglesDeductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyRegleDeductionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    role: $Enums.Role | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    role: number
    firstName: number
    lastName: number
    phone: number
    twoFactorEnabled: number
    twoFactorSecret: number
    lastLogin: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    firstName?: true
    lastName?: true
    phone?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    firstName?: true
    lastName?: true
    phone?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    firstName?: true
    lastName?: true
    phone?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    lastLogin?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string
    role: $Enums.Role
    firstName: string
    lastName: string
    phone: string | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    lastLogin: Date | null
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    lastLogin?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | User$employeeArgs<ExtArgs>
    journalAudit?: boolean | User$journalAuditArgs<ExtArgs>
    processedPayments?: boolean | User$processedPaymentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    createdFactures?: boolean | User$createdFacturesArgs<ExtArgs>
    createdPayRuns?: boolean | User$createdPayRunsArgs<ExtArgs>
    approvedPayRuns?: boolean | User$approvedPayRunsArgs<ExtArgs>
    processedPaymentsCompany?: boolean | User$processedPaymentsCompanyArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    createdModeles?: boolean | User$createdModelesArgs<ExtArgs>
    modifiedSalaries?: boolean | User$modifiedSalariesArgs<ExtArgs>
    validatedPointages?: boolean | User$validatedPointagesArgs<ExtArgs>
    approvedAbsences?: boolean | User$approvedAbsencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    lastLogin?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "role" | "firstName" | "lastName" | "phone" | "twoFactorEnabled" | "twoFactorSecret" | "lastLogin" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User$employeeArgs<ExtArgs>
    journalAudit?: boolean | User$journalAuditArgs<ExtArgs>
    processedPayments?: boolean | User$processedPaymentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    createdFactures?: boolean | User$createdFacturesArgs<ExtArgs>
    createdPayRuns?: boolean | User$createdPayRunsArgs<ExtArgs>
    approvedPayRuns?: boolean | User$approvedPayRunsArgs<ExtArgs>
    processedPaymentsCompany?: boolean | User$processedPaymentsCompanyArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    createdModeles?: boolean | User$createdModelesArgs<ExtArgs>
    modifiedSalaries?: boolean | User$modifiedSalariesArgs<ExtArgs>
    validatedPointages?: boolean | User$validatedPointagesArgs<ExtArgs>
    approvedAbsences?: boolean | User$approvedAbsencesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      journalAudit: Prisma.$JournalAuditPayload<ExtArgs>[]
      processedPayments: Prisma.$PaymentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      createdFactures: Prisma.$CompanyFacturePayload<ExtArgs>[]
      createdPayRuns: Prisma.$CompanyPayRunPayload<ExtArgs>[]
      approvedPayRuns: Prisma.$CompanyPayRunPayload<ExtArgs>[]
      processedPaymentsCompany: Prisma.$CompanyPaiementPayload<ExtArgs>[]
      uploadedDocuments: Prisma.$CompanyDocumentPayload<ExtArgs>[]
      createdModeles: Prisma.$CompanyModeleDocumentPayload<ExtArgs>[]
      modifiedSalaries: Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>[]
      validatedPointages: Prisma.$PointagePayload<ExtArgs>[]
      approvedAbsences: Prisma.$AbsencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      passwordHash: string
      role: $Enums.Role
      firstName: string
      lastName: string
      phone: string | null
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      lastLogin: Date | null
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    journalAudit<T extends User$journalAuditArgs<ExtArgs> = {}>(args?: Subset<T, User$journalAuditArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processedPayments<T extends User$processedPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$processedPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFactures<T extends User$createdFacturesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdFacturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdPayRuns<T extends User$createdPayRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPayRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedPayRuns<T extends User$approvedPayRunsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedPayRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processedPaymentsCompany<T extends User$processedPaymentsCompanyArgs<ExtArgs> = {}>(args?: Subset<T, User$processedPaymentsCompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDocuments<T extends User$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdModeles<T extends User$createdModelesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdModelesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modifiedSalaries<T extends User$modifiedSalariesArgs<ExtArgs> = {}>(args?: Subset<T, User$modifiedSalariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validatedPointages<T extends User$validatedPointagesArgs<ExtArgs> = {}>(args?: Subset<T, User$validatedPointagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedAbsences<T extends User$approvedAbsencesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedAbsencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly permissions: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.journalAudit
   */
  export type User$journalAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    where?: JournalAuditWhereInput
    orderBy?: JournalAuditOrderByWithRelationInput | JournalAuditOrderByWithRelationInput[]
    cursor?: JournalAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalAuditScalarFieldEnum | JournalAuditScalarFieldEnum[]
  }

  /**
   * User.processedPayments
   */
  export type User$processedPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.createdFactures
   */
  export type User$createdFacturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    where?: CompanyFactureWhereInput
    orderBy?: CompanyFactureOrderByWithRelationInput | CompanyFactureOrderByWithRelationInput[]
    cursor?: CompanyFactureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFactureScalarFieldEnum | CompanyFactureScalarFieldEnum[]
  }

  /**
   * User.createdPayRuns
   */
  export type User$createdPayRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    where?: CompanyPayRunWhereInput
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    cursor?: CompanyPayRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPayRunScalarFieldEnum | CompanyPayRunScalarFieldEnum[]
  }

  /**
   * User.approvedPayRuns
   */
  export type User$approvedPayRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    where?: CompanyPayRunWhereInput
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    cursor?: CompanyPayRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPayRunScalarFieldEnum | CompanyPayRunScalarFieldEnum[]
  }

  /**
   * User.processedPaymentsCompany
   */
  export type User$processedPaymentsCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    where?: CompanyPaiementWhereInput
    orderBy?: CompanyPaiementOrderByWithRelationInput | CompanyPaiementOrderByWithRelationInput[]
    cursor?: CompanyPaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPaiementScalarFieldEnum | CompanyPaiementScalarFieldEnum[]
  }

  /**
   * User.uploadedDocuments
   */
  export type User$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    cursor?: CompanyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * User.createdModeles
   */
  export type User$createdModelesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    where?: CompanyModeleDocumentWhereInput
    orderBy?: CompanyModeleDocumentOrderByWithRelationInput | CompanyModeleDocumentOrderByWithRelationInput[]
    cursor?: CompanyModeleDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyModeleDocumentScalarFieldEnum | CompanyModeleDocumentScalarFieldEnum[]
  }

  /**
   * User.modifiedSalaries
   */
  export type User$modifiedSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    where?: CompanyHistoriqueSalaireWhereInput
    orderBy?: CompanyHistoriqueSalaireOrderByWithRelationInput | CompanyHistoriqueSalaireOrderByWithRelationInput[]
    cursor?: CompanyHistoriqueSalaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyHistoriqueSalaireScalarFieldEnum | CompanyHistoriqueSalaireScalarFieldEnum[]
  }

  /**
   * User.validatedPointages
   */
  export type User$validatedPointagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    where?: PointageWhereInput
    orderBy?: PointageOrderByWithRelationInput | PointageOrderByWithRelationInput[]
    cursor?: PointageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointageScalarFieldEnum | PointageScalarFieldEnum[]
  }

  /**
   * User.approvedAbsences
   */
  export type User$approvedAbsencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    where?: AbsenceWhereInput
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    cursor?: AbsenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    entrepriseId: number | null
    salary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    entrepriseId: number | null
    salary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    entrepriseId: number | null
    employeeId: string | null
    department: string | null
    position: string | null
    contractType: $Enums.ContractType | null
    salary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
    hireDate: Date | null
    phone: string | null
    address: string | null
    status: $Enums.EmployeeStatus | null
    qrCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    entrepriseId: number | null
    employeeId: string | null
    department: string | null
    position: string | null
    contractType: $Enums.ContractType | null
    salary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
    hireDate: Date | null
    phone: string | null
    address: string | null
    status: $Enums.EmployeeStatus | null
    qrCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    userId: number
    entrepriseId: number
    employeeId: number
    department: number
    position: number
    contractType: number
    salary: number
    dailyRate: number
    hourlyRate: number
    hireDate: number
    phone: number
    address: number
    status: number
    qrCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    userId?: true
    entrepriseId?: true
    salary?: true
    dailyRate?: true
    hourlyRate?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    userId?: true
    entrepriseId?: true
    salary?: true
    dailyRate?: true
    hourlyRate?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    entrepriseId?: true
    employeeId?: true
    department?: true
    position?: true
    contractType?: true
    salary?: true
    dailyRate?: true
    hourlyRate?: true
    hireDate?: true
    phone?: true
    address?: true
    status?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    entrepriseId?: true
    employeeId?: true
    department?: true
    position?: true
    contractType?: true
    salary?: true
    dailyRate?: true
    hourlyRate?: true
    hireDate?: true
    phone?: true
    address?: true
    status?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    entrepriseId?: true
    employeeId?: true
    department?: true
    position?: true
    contractType?: true
    salary?: true
    dailyRate?: true
    hourlyRate?: true
    hireDate?: true
    phone?: true
    address?: true
    status?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    userId: number
    entrepriseId: number
    employeeId: string
    department: string | null
    position: string | null
    contractType: $Enums.ContractType
    salary: Decimal | null
    dailyRate: Decimal | null
    hourlyRate: Decimal | null
    hireDate: Date | null
    phone: string | null
    address: string | null
    status: $Enums.EmployeeStatus
    qrCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entrepriseId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    contractType?: boolean
    salary?: boolean
    dailyRate?: boolean
    hourlyRate?: boolean
    hireDate?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    payments?: boolean | Employee$paymentsArgs<ExtArgs>
    factures?: boolean | Employee$facturesArgs<ExtArgs>
    bulletins?: boolean | Employee$bulletinsArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    salaryHistory?: boolean | Employee$salaryHistoryArgs<ExtArgs>
    pointages?: boolean | Employee$pointagesArgs<ExtArgs>
    absences?: boolean | Employee$absencesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type EmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    entrepriseId?: boolean
    employeeId?: boolean
    department?: boolean
    position?: boolean
    contractType?: boolean
    salary?: boolean
    dailyRate?: boolean
    hourlyRate?: boolean
    hireDate?: boolean
    phone?: boolean
    address?: boolean
    status?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "entrepriseId" | "employeeId" | "department" | "position" | "contractType" | "salary" | "dailyRate" | "hourlyRate" | "hireDate" | "phone" | "address" | "status" | "qrCode" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    payments?: boolean | Employee$paymentsArgs<ExtArgs>
    factures?: boolean | Employee$facturesArgs<ExtArgs>
    bulletins?: boolean | Employee$bulletinsArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    salaryHistory?: boolean | Employee$salaryHistoryArgs<ExtArgs>
    pointages?: boolean | Employee$pointagesArgs<ExtArgs>
    absences?: boolean | Employee$absencesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      factures: Prisma.$CompanyFacturePayload<ExtArgs>[]
      bulletins: Prisma.$CompanyBulletinPayload<ExtArgs>[]
      documents: Prisma.$CompanyDocumentPayload<ExtArgs>[]
      salaryHistory: Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>[]
      pointages: Prisma.$PointagePayload<ExtArgs>[]
      absences: Prisma.$AbsencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      entrepriseId: number
      employeeId: string
      department: string | null
      position: string | null
      contractType: $Enums.ContractType
      salary: Prisma.Decimal | null
      dailyRate: Prisma.Decimal | null
      hourlyRate: Prisma.Decimal | null
      hireDate: Date | null
      phone: string | null
      address: string | null
      status: $Enums.EmployeeStatus
      qrCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Employee$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    factures<T extends Employee$facturesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$facturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bulletins<T extends Employee$bulletinsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$bulletinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Employee$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryHistory<T extends Employee$salaryHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Employee$salaryHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointages<T extends Employee$pointagesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$pointagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    absences<T extends Employee$absencesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$absencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly userId: FieldRef<"Employee", 'Int'>
    readonly entrepriseId: FieldRef<"Employee", 'Int'>
    readonly employeeId: FieldRef<"Employee", 'String'>
    readonly department: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly contractType: FieldRef<"Employee", 'ContractType'>
    readonly salary: FieldRef<"Employee", 'Decimal'>
    readonly dailyRate: FieldRef<"Employee", 'Decimal'>
    readonly hourlyRate: FieldRef<"Employee", 'Decimal'>
    readonly hireDate: FieldRef<"Employee", 'DateTime'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly status: FieldRef<"Employee", 'EmployeeStatus'>
    readonly qrCode: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.payments
   */
  export type Employee$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Employee.factures
   */
  export type Employee$facturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    where?: CompanyFactureWhereInput
    orderBy?: CompanyFactureOrderByWithRelationInput | CompanyFactureOrderByWithRelationInput[]
    cursor?: CompanyFactureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyFactureScalarFieldEnum | CompanyFactureScalarFieldEnum[]
  }

  /**
   * Employee.bulletins
   */
  export type Employee$bulletinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    where?: CompanyBulletinWhereInput
    orderBy?: CompanyBulletinOrderByWithRelationInput | CompanyBulletinOrderByWithRelationInput[]
    cursor?: CompanyBulletinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyBulletinScalarFieldEnum | CompanyBulletinScalarFieldEnum[]
  }

  /**
   * Employee.documents
   */
  export type Employee$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    cursor?: CompanyDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * Employee.salaryHistory
   */
  export type Employee$salaryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    where?: CompanyHistoriqueSalaireWhereInput
    orderBy?: CompanyHistoriqueSalaireOrderByWithRelationInput | CompanyHistoriqueSalaireOrderByWithRelationInput[]
    cursor?: CompanyHistoriqueSalaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyHistoriqueSalaireScalarFieldEnum | CompanyHistoriqueSalaireScalarFieldEnum[]
  }

  /**
   * Employee.pointages
   */
  export type Employee$pointagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    where?: PointageWhereInput
    orderBy?: PointageOrderByWithRelationInput | PointageOrderByWithRelationInput[]
    cursor?: PointageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointageScalarFieldEnum | PointageScalarFieldEnum[]
  }

  /**
   * Employee.absences
   */
  export type Employee$absencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    where?: AbsenceWhereInput
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    cursor?: AbsenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Entreprise
   */

  export type AggregateEntreprise = {
    _count: EntrepriseCountAggregateOutputType | null
    _avg: EntrepriseAvgAggregateOutputType | null
    _sum: EntrepriseSumAggregateOutputType | null
    _min: EntrepriseMinAggregateOutputType | null
    _max: EntrepriseMaxAggregateOutputType | null
  }

  export type EntrepriseAvgAggregateOutputType = {
    id: number | null
  }

  export type EntrepriseSumAggregateOutputType = {
    id: number | null
  }

  export type EntrepriseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    adresse: string | null
    telephone: string | null
    email: string | null
    siteWeb: string | null
    logo: string | null
    couleurPrimaire: string | null
    couleurSecondaire: string | null
    couleurDashboard: string | null
    description: string | null
    devise: string | null
    timezone: string | null
    periodePayroll: string | null
    estActive: boolean | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type EntrepriseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    adresse: string | null
    telephone: string | null
    email: string | null
    siteWeb: string | null
    logo: string | null
    couleurPrimaire: string | null
    couleurSecondaire: string | null
    couleurDashboard: string | null
    description: string | null
    devise: string | null
    timezone: string | null
    periodePayroll: string | null
    estActive: boolean | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type EntrepriseCountAggregateOutputType = {
    id: number
    nom: number
    adresse: number
    telephone: number
    email: number
    siteWeb: number
    logo: number
    couleurPrimaire: number
    couleurSecondaire: number
    couleurDashboard: number
    description: number
    devise: number
    timezone: number
    periodePayroll: number
    estActive: number
    parametres: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type EntrepriseAvgAggregateInputType = {
    id?: true
  }

  export type EntrepriseSumAggregateInputType = {
    id?: true
  }

  export type EntrepriseMinAggregateInputType = {
    id?: true
    nom?: true
    adresse?: true
    telephone?: true
    email?: true
    siteWeb?: true
    logo?: true
    couleurPrimaire?: true
    couleurSecondaire?: true
    couleurDashboard?: true
    description?: true
    devise?: true
    timezone?: true
    periodePayroll?: true
    estActive?: true
    creeLe?: true
    modifieLe?: true
  }

  export type EntrepriseMaxAggregateInputType = {
    id?: true
    nom?: true
    adresse?: true
    telephone?: true
    email?: true
    siteWeb?: true
    logo?: true
    couleurPrimaire?: true
    couleurSecondaire?: true
    couleurDashboard?: true
    description?: true
    devise?: true
    timezone?: true
    periodePayroll?: true
    estActive?: true
    creeLe?: true
    modifieLe?: true
  }

  export type EntrepriseCountAggregateInputType = {
    id?: true
    nom?: true
    adresse?: true
    telephone?: true
    email?: true
    siteWeb?: true
    logo?: true
    couleurPrimaire?: true
    couleurSecondaire?: true
    couleurDashboard?: true
    description?: true
    devise?: true
    timezone?: true
    periodePayroll?: true
    estActive?: true
    parametres?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type EntrepriseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entreprise to aggregate.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entreprises
    **/
    _count?: true | EntrepriseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntrepriseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrepriseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntrepriseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntrepriseMaxAggregateInputType
  }

  export type GetEntrepriseAggregateType<T extends EntrepriseAggregateArgs> = {
        [P in keyof T & keyof AggregateEntreprise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntreprise[P]>
      : GetScalarType<T[P], AggregateEntreprise[P]>
  }




  export type EntrepriseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntrepriseWhereInput
    orderBy?: EntrepriseOrderByWithAggregationInput | EntrepriseOrderByWithAggregationInput[]
    by: EntrepriseScalarFieldEnum[] | EntrepriseScalarFieldEnum
    having?: EntrepriseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntrepriseCountAggregateInputType | true
    _avg?: EntrepriseAvgAggregateInputType
    _sum?: EntrepriseSumAggregateInputType
    _min?: EntrepriseMinAggregateInputType
    _max?: EntrepriseMaxAggregateInputType
  }

  export type EntrepriseGroupByOutputType = {
    id: number
    nom: string
    adresse: string | null
    telephone: string | null
    email: string | null
    siteWeb: string | null
    logo: string | null
    couleurPrimaire: string | null
    couleurSecondaire: string | null
    couleurDashboard: string | null
    description: string | null
    devise: string
    timezone: string
    periodePayroll: string
    estActive: boolean
    parametres: JsonValue | null
    creeLe: Date
    modifieLe: Date
    _count: EntrepriseCountAggregateOutputType | null
    _avg: EntrepriseAvgAggregateOutputType | null
    _sum: EntrepriseSumAggregateOutputType | null
    _min: EntrepriseMinAggregateOutputType | null
    _max: EntrepriseMaxAggregateOutputType | null
  }

  type GetEntrepriseGroupByPayload<T extends EntrepriseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntrepriseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntrepriseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntrepriseGroupByOutputType[P]>
            : GetScalarType<T[P], EntrepriseGroupByOutputType[P]>
        }
      >
    >


  export type EntrepriseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    adresse?: boolean
    telephone?: boolean
    email?: boolean
    siteWeb?: boolean
    logo?: boolean
    couleurPrimaire?: boolean
    couleurSecondaire?: boolean
    couleurDashboard?: boolean
    description?: boolean
    devise?: boolean
    timezone?: boolean
    periodePayroll?: boolean
    estActive?: boolean
    parametres?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    employees?: boolean | Entreprise$employeesArgs<ExtArgs>
    payRuns?: boolean | Entreprise$payRunsArgs<ExtArgs>
    templates?: boolean | Entreprise$templatesArgs<ExtArgs>
    settings?: boolean | Entreprise$settingsArgs<ExtArgs>
    modeles?: boolean | Entreprise$modelesArgs<ExtArgs>
    periodesPaie?: boolean | Entreprise$periodesPaieArgs<ExtArgs>
    configurationsPaie?: boolean | Entreprise$configurationsPaieArgs<ExtArgs>
    reglePointage?: boolean | Entreprise$reglePointageArgs<ExtArgs>
    _count?: boolean | EntrepriseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entreprise"]>



  export type EntrepriseSelectScalar = {
    id?: boolean
    nom?: boolean
    adresse?: boolean
    telephone?: boolean
    email?: boolean
    siteWeb?: boolean
    logo?: boolean
    couleurPrimaire?: boolean
    couleurSecondaire?: boolean
    couleurDashboard?: boolean
    description?: boolean
    devise?: boolean
    timezone?: boolean
    periodePayroll?: boolean
    estActive?: boolean
    parametres?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type EntrepriseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "adresse" | "telephone" | "email" | "siteWeb" | "logo" | "couleurPrimaire" | "couleurSecondaire" | "couleurDashboard" | "description" | "devise" | "timezone" | "periodePayroll" | "estActive" | "parametres" | "creeLe" | "modifieLe", ExtArgs["result"]["entreprise"]>
  export type EntrepriseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Entreprise$employeesArgs<ExtArgs>
    payRuns?: boolean | Entreprise$payRunsArgs<ExtArgs>
    templates?: boolean | Entreprise$templatesArgs<ExtArgs>
    settings?: boolean | Entreprise$settingsArgs<ExtArgs>
    modeles?: boolean | Entreprise$modelesArgs<ExtArgs>
    periodesPaie?: boolean | Entreprise$periodesPaieArgs<ExtArgs>
    configurationsPaie?: boolean | Entreprise$configurationsPaieArgs<ExtArgs>
    reglePointage?: boolean | Entreprise$reglePointageArgs<ExtArgs>
    _count?: boolean | EntrepriseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EntreprisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entreprise"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      payRuns: Prisma.$CompanyPayRunPayload<ExtArgs>[]
      templates: Prisma.$CompanyTemplatePayload<ExtArgs>[]
      settings: Prisma.$CompanySettingPayload<ExtArgs>[]
      modeles: Prisma.$CompanyModeleDocumentPayload<ExtArgs>[]
      periodesPaie: Prisma.$CompanyPeriodePaiePayload<ExtArgs>[]
      configurationsPaie: Prisma.$CompanyConfigurationPaiePayload<ExtArgs>[]
      reglePointage: Prisma.$ReglePointagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      adresse: string | null
      telephone: string | null
      email: string | null
      siteWeb: string | null
      logo: string | null
      couleurPrimaire: string | null
      couleurSecondaire: string | null
      couleurDashboard: string | null
      description: string | null
      devise: string
      timezone: string
      periodePayroll: string
      estActive: boolean
      parametres: Prisma.JsonValue | null
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["entreprise"]>
    composites: {}
  }

  type EntrepriseGetPayload<S extends boolean | null | undefined | EntrepriseDefaultArgs> = $Result.GetResult<Prisma.$EntreprisePayload, S>

  type EntrepriseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EntrepriseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntrepriseCountAggregateInputType | true
    }

  export interface EntrepriseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entreprise'], meta: { name: 'Entreprise' } }
    /**
     * Find zero or one Entreprise that matches the filter.
     * @param {EntrepriseFindUniqueArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntrepriseFindUniqueArgs>(args: SelectSubset<T, EntrepriseFindUniqueArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entreprise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EntrepriseFindUniqueOrThrowArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntrepriseFindUniqueOrThrowArgs>(args: SelectSubset<T, EntrepriseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entreprise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindFirstArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntrepriseFindFirstArgs>(args?: SelectSubset<T, EntrepriseFindFirstArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entreprise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindFirstOrThrowArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntrepriseFindFirstOrThrowArgs>(args?: SelectSubset<T, EntrepriseFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entreprises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entreprises
     * const entreprises = await prisma.entreprise.findMany()
     * 
     * // Get first 10 Entreprises
     * const entreprises = await prisma.entreprise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entrepriseWithIdOnly = await prisma.entreprise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntrepriseFindManyArgs>(args?: SelectSubset<T, EntrepriseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entreprise.
     * @param {EntrepriseCreateArgs} args - Arguments to create a Entreprise.
     * @example
     * // Create one Entreprise
     * const Entreprise = await prisma.entreprise.create({
     *   data: {
     *     // ... data to create a Entreprise
     *   }
     * })
     * 
     */
    create<T extends EntrepriseCreateArgs>(args: SelectSubset<T, EntrepriseCreateArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entreprises.
     * @param {EntrepriseCreateManyArgs} args - Arguments to create many Entreprises.
     * @example
     * // Create many Entreprises
     * const entreprise = await prisma.entreprise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntrepriseCreateManyArgs>(args?: SelectSubset<T, EntrepriseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entreprise.
     * @param {EntrepriseDeleteArgs} args - Arguments to delete one Entreprise.
     * @example
     * // Delete one Entreprise
     * const Entreprise = await prisma.entreprise.delete({
     *   where: {
     *     // ... filter to delete one Entreprise
     *   }
     * })
     * 
     */
    delete<T extends EntrepriseDeleteArgs>(args: SelectSubset<T, EntrepriseDeleteArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entreprise.
     * @param {EntrepriseUpdateArgs} args - Arguments to update one Entreprise.
     * @example
     * // Update one Entreprise
     * const entreprise = await prisma.entreprise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntrepriseUpdateArgs>(args: SelectSubset<T, EntrepriseUpdateArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entreprises.
     * @param {EntrepriseDeleteManyArgs} args - Arguments to filter Entreprises to delete.
     * @example
     * // Delete a few Entreprises
     * const { count } = await prisma.entreprise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntrepriseDeleteManyArgs>(args?: SelectSubset<T, EntrepriseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entreprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entreprises
     * const entreprise = await prisma.entreprise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntrepriseUpdateManyArgs>(args: SelectSubset<T, EntrepriseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entreprise.
     * @param {EntrepriseUpsertArgs} args - Arguments to update or create a Entreprise.
     * @example
     * // Update or create a Entreprise
     * const entreprise = await prisma.entreprise.upsert({
     *   create: {
     *     // ... data to create a Entreprise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entreprise we want to update
     *   }
     * })
     */
    upsert<T extends EntrepriseUpsertArgs>(args: SelectSubset<T, EntrepriseUpsertArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entreprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseCountArgs} args - Arguments to filter Entreprises to count.
     * @example
     * // Count the number of Entreprises
     * const count = await prisma.entreprise.count({
     *   where: {
     *     // ... the filter for the Entreprises we want to count
     *   }
     * })
    **/
    count<T extends EntrepriseCountArgs>(
      args?: Subset<T, EntrepriseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntrepriseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entreprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntrepriseAggregateArgs>(args: Subset<T, EntrepriseAggregateArgs>): Prisma.PrismaPromise<GetEntrepriseAggregateType<T>>

    /**
     * Group by Entreprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntrepriseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntrepriseGroupByArgs['orderBy'] }
        : { orderBy?: EntrepriseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntrepriseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntrepriseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entreprise model
   */
  readonly fields: EntrepriseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entreprise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntrepriseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Entreprise$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payRuns<T extends Entreprise$payRunsArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$payRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    templates<T extends Entreprise$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Entreprise$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modeles<T extends Entreprise$modelesArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$modelesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    periodesPaie<T extends Entreprise$periodesPaieArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$periodesPaieArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    configurationsPaie<T extends Entreprise$configurationsPaieArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$configurationsPaieArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reglePointage<T extends Entreprise$reglePointageArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$reglePointageArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entreprise model
   */
  interface EntrepriseFieldRefs {
    readonly id: FieldRef<"Entreprise", 'Int'>
    readonly nom: FieldRef<"Entreprise", 'String'>
    readonly adresse: FieldRef<"Entreprise", 'String'>
    readonly telephone: FieldRef<"Entreprise", 'String'>
    readonly email: FieldRef<"Entreprise", 'String'>
    readonly siteWeb: FieldRef<"Entreprise", 'String'>
    readonly logo: FieldRef<"Entreprise", 'String'>
    readonly couleurPrimaire: FieldRef<"Entreprise", 'String'>
    readonly couleurSecondaire: FieldRef<"Entreprise", 'String'>
    readonly couleurDashboard: FieldRef<"Entreprise", 'String'>
    readonly description: FieldRef<"Entreprise", 'String'>
    readonly devise: FieldRef<"Entreprise", 'String'>
    readonly timezone: FieldRef<"Entreprise", 'String'>
    readonly periodePayroll: FieldRef<"Entreprise", 'String'>
    readonly estActive: FieldRef<"Entreprise", 'Boolean'>
    readonly parametres: FieldRef<"Entreprise", 'Json'>
    readonly creeLe: FieldRef<"Entreprise", 'DateTime'>
    readonly modifieLe: FieldRef<"Entreprise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entreprise findUnique
   */
  export type EntrepriseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise findUniqueOrThrow
   */
  export type EntrepriseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise findFirst
   */
  export type EntrepriseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entreprises.
     */
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise findFirstOrThrow
   */
  export type EntrepriseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entreprises.
     */
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise findMany
   */
  export type EntrepriseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprises to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise create
   */
  export type EntrepriseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * The data needed to create a Entreprise.
     */
    data: XOR<EntrepriseCreateInput, EntrepriseUncheckedCreateInput>
  }

  /**
   * Entreprise createMany
   */
  export type EntrepriseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entreprises.
     */
    data: EntrepriseCreateManyInput | EntrepriseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entreprise update
   */
  export type EntrepriseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * The data needed to update a Entreprise.
     */
    data: XOR<EntrepriseUpdateInput, EntrepriseUncheckedUpdateInput>
    /**
     * Choose, which Entreprise to update.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise updateMany
   */
  export type EntrepriseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entreprises.
     */
    data: XOR<EntrepriseUpdateManyMutationInput, EntrepriseUncheckedUpdateManyInput>
    /**
     * Filter which Entreprises to update
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to update.
     */
    limit?: number
  }

  /**
   * Entreprise upsert
   */
  export type EntrepriseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * The filter to search for the Entreprise to update in case it exists.
     */
    where: EntrepriseWhereUniqueInput
    /**
     * In case the Entreprise found by the `where` argument doesn't exist, create a new Entreprise with this data.
     */
    create: XOR<EntrepriseCreateInput, EntrepriseUncheckedCreateInput>
    /**
     * In case the Entreprise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntrepriseUpdateInput, EntrepriseUncheckedUpdateInput>
  }

  /**
   * Entreprise delete
   */
  export type EntrepriseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter which Entreprise to delete.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise deleteMany
   */
  export type EntrepriseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entreprises to delete
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to delete.
     */
    limit?: number
  }

  /**
   * Entreprise.employees
   */
  export type Entreprise$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Entreprise.payRuns
   */
  export type Entreprise$payRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    where?: CompanyPayRunWhereInput
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    cursor?: CompanyPayRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPayRunScalarFieldEnum | CompanyPayRunScalarFieldEnum[]
  }

  /**
   * Entreprise.templates
   */
  export type Entreprise$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    where?: CompanyTemplateWhereInput
    orderBy?: CompanyTemplateOrderByWithRelationInput | CompanyTemplateOrderByWithRelationInput[]
    cursor?: CompanyTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyTemplateScalarFieldEnum | CompanyTemplateScalarFieldEnum[]
  }

  /**
   * Entreprise.settings
   */
  export type Entreprise$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    where?: CompanySettingWhereInput
    orderBy?: CompanySettingOrderByWithRelationInput | CompanySettingOrderByWithRelationInput[]
    cursor?: CompanySettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanySettingScalarFieldEnum | CompanySettingScalarFieldEnum[]
  }

  /**
   * Entreprise.modeles
   */
  export type Entreprise$modelesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    where?: CompanyModeleDocumentWhereInput
    orderBy?: CompanyModeleDocumentOrderByWithRelationInput | CompanyModeleDocumentOrderByWithRelationInput[]
    cursor?: CompanyModeleDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyModeleDocumentScalarFieldEnum | CompanyModeleDocumentScalarFieldEnum[]
  }

  /**
   * Entreprise.periodesPaie
   */
  export type Entreprise$periodesPaieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    where?: CompanyPeriodePaieWhereInput
    orderBy?: CompanyPeriodePaieOrderByWithRelationInput | CompanyPeriodePaieOrderByWithRelationInput[]
    cursor?: CompanyPeriodePaieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPeriodePaieScalarFieldEnum | CompanyPeriodePaieScalarFieldEnum[]
  }

  /**
   * Entreprise.configurationsPaie
   */
  export type Entreprise$configurationsPaieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    where?: CompanyConfigurationPaieWhereInput
    orderBy?: CompanyConfigurationPaieOrderByWithRelationInput | CompanyConfigurationPaieOrderByWithRelationInput[]
    cursor?: CompanyConfigurationPaieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyConfigurationPaieScalarFieldEnum | CompanyConfigurationPaieScalarFieldEnum[]
  }

  /**
   * Entreprise.reglePointage
   */
  export type Entreprise$reglePointageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    where?: ReglePointageWhereInput
  }

  /**
   * Entreprise without action
   */
  export type EntrepriseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
  }


  /**
   * Model JournalAudit
   */

  export type AggregateJournalAudit = {
    _count: JournalAuditCountAggregateOutputType | null
    _avg: JournalAuditAvgAggregateOutputType | null
    _sum: JournalAuditSumAggregateOutputType | null
    _min: JournalAuditMinAggregateOutputType | null
    _max: JournalAuditMaxAggregateOutputType | null
  }

  export type JournalAuditAvgAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    idEnregistrement: number | null
  }

  export type JournalAuditSumAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    idEnregistrement: number | null
  }

  export type JournalAuditMinAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    action: string | null
    nomTable: string | null
    idEnregistrement: number | null
    creeLe: Date | null
  }

  export type JournalAuditMaxAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    action: string | null
    nomTable: string | null
    idEnregistrement: number | null
    creeLe: Date | null
  }

  export type JournalAuditCountAggregateOutputType = {
    id: number
    utilisateurId: number
    action: number
    nomTable: number
    idEnregistrement: number
    anciennes_valeurs: number
    nouvelles_valeurs: number
    creeLe: number
    _all: number
  }


  export type JournalAuditAvgAggregateInputType = {
    id?: true
    utilisateurId?: true
    idEnregistrement?: true
  }

  export type JournalAuditSumAggregateInputType = {
    id?: true
    utilisateurId?: true
    idEnregistrement?: true
  }

  export type JournalAuditMinAggregateInputType = {
    id?: true
    utilisateurId?: true
    action?: true
    nomTable?: true
    idEnregistrement?: true
    creeLe?: true
  }

  export type JournalAuditMaxAggregateInputType = {
    id?: true
    utilisateurId?: true
    action?: true
    nomTable?: true
    idEnregistrement?: true
    creeLe?: true
  }

  export type JournalAuditCountAggregateInputType = {
    id?: true
    utilisateurId?: true
    action?: true
    nomTable?: true
    idEnregistrement?: true
    anciennes_valeurs?: true
    nouvelles_valeurs?: true
    creeLe?: true
    _all?: true
  }

  export type JournalAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalAudit to aggregate.
     */
    where?: JournalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalAudits to fetch.
     */
    orderBy?: JournalAuditOrderByWithRelationInput | JournalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalAudits
    **/
    _count?: true | JournalAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalAuditMaxAggregateInputType
  }

  export type GetJournalAuditAggregateType<T extends JournalAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalAudit[P]>
      : GetScalarType<T[P], AggregateJournalAudit[P]>
  }




  export type JournalAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalAuditWhereInput
    orderBy?: JournalAuditOrderByWithAggregationInput | JournalAuditOrderByWithAggregationInput[]
    by: JournalAuditScalarFieldEnum[] | JournalAuditScalarFieldEnum
    having?: JournalAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalAuditCountAggregateInputType | true
    _avg?: JournalAuditAvgAggregateInputType
    _sum?: JournalAuditSumAggregateInputType
    _min?: JournalAuditMinAggregateInputType
    _max?: JournalAuditMaxAggregateInputType
  }

  export type JournalAuditGroupByOutputType = {
    id: number
    utilisateurId: number | null
    action: string
    nomTable: string
    idEnregistrement: number | null
    anciennes_valeurs: JsonValue | null
    nouvelles_valeurs: JsonValue | null
    creeLe: Date
    _count: JournalAuditCountAggregateOutputType | null
    _avg: JournalAuditAvgAggregateOutputType | null
    _sum: JournalAuditSumAggregateOutputType | null
    _min: JournalAuditMinAggregateOutputType | null
    _max: JournalAuditMaxAggregateOutputType | null
  }

  type GetJournalAuditGroupByPayload<T extends JournalAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalAuditGroupByOutputType[P]>
            : GetScalarType<T[P], JournalAuditGroupByOutputType[P]>
        }
      >
    >


  export type JournalAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    action?: boolean
    nomTable?: boolean
    idEnregistrement?: boolean
    anciennes_valeurs?: boolean
    nouvelles_valeurs?: boolean
    creeLe?: boolean
    utilisateur?: boolean | JournalAudit$utilisateurArgs<ExtArgs>
  }, ExtArgs["result"]["journalAudit"]>



  export type JournalAuditSelectScalar = {
    id?: boolean
    utilisateurId?: boolean
    action?: boolean
    nomTable?: boolean
    idEnregistrement?: boolean
    anciennes_valeurs?: boolean
    nouvelles_valeurs?: boolean
    creeLe?: boolean
  }

  export type JournalAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "utilisateurId" | "action" | "nomTable" | "idEnregistrement" | "anciennes_valeurs" | "nouvelles_valeurs" | "creeLe", ExtArgs["result"]["journalAudit"]>
  export type JournalAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | JournalAudit$utilisateurArgs<ExtArgs>
  }

  export type $JournalAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalAudit"
    objects: {
      utilisateur: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      utilisateurId: number | null
      action: string
      nomTable: string
      idEnregistrement: number | null
      anciennes_valeurs: Prisma.JsonValue | null
      nouvelles_valeurs: Prisma.JsonValue | null
      creeLe: Date
    }, ExtArgs["result"]["journalAudit"]>
    composites: {}
  }

  type JournalAuditGetPayload<S extends boolean | null | undefined | JournalAuditDefaultArgs> = $Result.GetResult<Prisma.$JournalAuditPayload, S>

  type JournalAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalAuditCountAggregateInputType | true
    }

  export interface JournalAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalAudit'], meta: { name: 'JournalAudit' } }
    /**
     * Find zero or one JournalAudit that matches the filter.
     * @param {JournalAuditFindUniqueArgs} args - Arguments to find a JournalAudit
     * @example
     * // Get one JournalAudit
     * const journalAudit = await prisma.journalAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalAuditFindUniqueArgs>(args: SelectSubset<T, JournalAuditFindUniqueArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalAuditFindUniqueOrThrowArgs} args - Arguments to find a JournalAudit
     * @example
     * // Get one JournalAudit
     * const journalAudit = await prisma.journalAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAuditFindFirstArgs} args - Arguments to find a JournalAudit
     * @example
     * // Get one JournalAudit
     * const journalAudit = await prisma.journalAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalAuditFindFirstArgs>(args?: SelectSubset<T, JournalAuditFindFirstArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAuditFindFirstOrThrowArgs} args - Arguments to find a JournalAudit
     * @example
     * // Get one JournalAudit
     * const journalAudit = await prisma.journalAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalAudits
     * const journalAudits = await prisma.journalAudit.findMany()
     * 
     * // Get first 10 JournalAudits
     * const journalAudits = await prisma.journalAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalAuditWithIdOnly = await prisma.journalAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalAuditFindManyArgs>(args?: SelectSubset<T, JournalAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalAudit.
     * @param {JournalAuditCreateArgs} args - Arguments to create a JournalAudit.
     * @example
     * // Create one JournalAudit
     * const JournalAudit = await prisma.journalAudit.create({
     *   data: {
     *     // ... data to create a JournalAudit
     *   }
     * })
     * 
     */
    create<T extends JournalAuditCreateArgs>(args: SelectSubset<T, JournalAuditCreateArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalAudits.
     * @param {JournalAuditCreateManyArgs} args - Arguments to create many JournalAudits.
     * @example
     * // Create many JournalAudits
     * const journalAudit = await prisma.journalAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalAuditCreateManyArgs>(args?: SelectSubset<T, JournalAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JournalAudit.
     * @param {JournalAuditDeleteArgs} args - Arguments to delete one JournalAudit.
     * @example
     * // Delete one JournalAudit
     * const JournalAudit = await prisma.journalAudit.delete({
     *   where: {
     *     // ... filter to delete one JournalAudit
     *   }
     * })
     * 
     */
    delete<T extends JournalAuditDeleteArgs>(args: SelectSubset<T, JournalAuditDeleteArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalAudit.
     * @param {JournalAuditUpdateArgs} args - Arguments to update one JournalAudit.
     * @example
     * // Update one JournalAudit
     * const journalAudit = await prisma.journalAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalAuditUpdateArgs>(args: SelectSubset<T, JournalAuditUpdateArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalAudits.
     * @param {JournalAuditDeleteManyArgs} args - Arguments to filter JournalAudits to delete.
     * @example
     * // Delete a few JournalAudits
     * const { count } = await prisma.journalAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalAuditDeleteManyArgs>(args?: SelectSubset<T, JournalAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalAudits
     * const journalAudit = await prisma.journalAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalAuditUpdateManyArgs>(args: SelectSubset<T, JournalAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalAudit.
     * @param {JournalAuditUpsertArgs} args - Arguments to update or create a JournalAudit.
     * @example
     * // Update or create a JournalAudit
     * const journalAudit = await prisma.journalAudit.upsert({
     *   create: {
     *     // ... data to create a JournalAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalAudit we want to update
     *   }
     * })
     */
    upsert<T extends JournalAuditUpsertArgs>(args: SelectSubset<T, JournalAuditUpsertArgs<ExtArgs>>): Prisma__JournalAuditClient<$Result.GetResult<Prisma.$JournalAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAuditCountArgs} args - Arguments to filter JournalAudits to count.
     * @example
     * // Count the number of JournalAudits
     * const count = await prisma.journalAudit.count({
     *   where: {
     *     // ... the filter for the JournalAudits we want to count
     *   }
     * })
    **/
    count<T extends JournalAuditCountArgs>(
      args?: Subset<T, JournalAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAuditAggregateArgs>(args: Subset<T, JournalAuditAggregateArgs>): Prisma.PrismaPromise<GetJournalAuditAggregateType<T>>

    /**
     * Group by JournalAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalAuditGroupByArgs['orderBy'] }
        : { orderBy?: JournalAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalAudit model
   */
  readonly fields: JournalAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends JournalAudit$utilisateurArgs<ExtArgs> = {}>(args?: Subset<T, JournalAudit$utilisateurArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalAudit model
   */
  interface JournalAuditFieldRefs {
    readonly id: FieldRef<"JournalAudit", 'Int'>
    readonly utilisateurId: FieldRef<"JournalAudit", 'Int'>
    readonly action: FieldRef<"JournalAudit", 'String'>
    readonly nomTable: FieldRef<"JournalAudit", 'String'>
    readonly idEnregistrement: FieldRef<"JournalAudit", 'Int'>
    readonly anciennes_valeurs: FieldRef<"JournalAudit", 'Json'>
    readonly nouvelles_valeurs: FieldRef<"JournalAudit", 'Json'>
    readonly creeLe: FieldRef<"JournalAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalAudit findUnique
   */
  export type JournalAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * Filter, which JournalAudit to fetch.
     */
    where: JournalAuditWhereUniqueInput
  }

  /**
   * JournalAudit findUniqueOrThrow
   */
  export type JournalAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * Filter, which JournalAudit to fetch.
     */
    where: JournalAuditWhereUniqueInput
  }

  /**
   * JournalAudit findFirst
   */
  export type JournalAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * Filter, which JournalAudit to fetch.
     */
    where?: JournalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalAudits to fetch.
     */
    orderBy?: JournalAuditOrderByWithRelationInput | JournalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalAudits.
     */
    cursor?: JournalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalAudits.
     */
    distinct?: JournalAuditScalarFieldEnum | JournalAuditScalarFieldEnum[]
  }

  /**
   * JournalAudit findFirstOrThrow
   */
  export type JournalAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * Filter, which JournalAudit to fetch.
     */
    where?: JournalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalAudits to fetch.
     */
    orderBy?: JournalAuditOrderByWithRelationInput | JournalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalAudits.
     */
    cursor?: JournalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalAudits.
     */
    distinct?: JournalAuditScalarFieldEnum | JournalAuditScalarFieldEnum[]
  }

  /**
   * JournalAudit findMany
   */
  export type JournalAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * Filter, which JournalAudits to fetch.
     */
    where?: JournalAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalAudits to fetch.
     */
    orderBy?: JournalAuditOrderByWithRelationInput | JournalAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalAudits.
     */
    cursor?: JournalAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalAudits.
     */
    skip?: number
    distinct?: JournalAuditScalarFieldEnum | JournalAuditScalarFieldEnum[]
  }

  /**
   * JournalAudit create
   */
  export type JournalAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalAudit.
     */
    data: XOR<JournalAuditCreateInput, JournalAuditUncheckedCreateInput>
  }

  /**
   * JournalAudit createMany
   */
  export type JournalAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalAudits.
     */
    data: JournalAuditCreateManyInput | JournalAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalAudit update
   */
  export type JournalAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalAudit.
     */
    data: XOR<JournalAuditUpdateInput, JournalAuditUncheckedUpdateInput>
    /**
     * Choose, which JournalAudit to update.
     */
    where: JournalAuditWhereUniqueInput
  }

  /**
   * JournalAudit updateMany
   */
  export type JournalAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalAudits.
     */
    data: XOR<JournalAuditUpdateManyMutationInput, JournalAuditUncheckedUpdateManyInput>
    /**
     * Filter which JournalAudits to update
     */
    where?: JournalAuditWhereInput
    /**
     * Limit how many JournalAudits to update.
     */
    limit?: number
  }

  /**
   * JournalAudit upsert
   */
  export type JournalAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalAudit to update in case it exists.
     */
    where: JournalAuditWhereUniqueInput
    /**
     * In case the JournalAudit found by the `where` argument doesn't exist, create a new JournalAudit with this data.
     */
    create: XOR<JournalAuditCreateInput, JournalAuditUncheckedCreateInput>
    /**
     * In case the JournalAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalAuditUpdateInput, JournalAuditUncheckedUpdateInput>
  }

  /**
   * JournalAudit delete
   */
  export type JournalAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
    /**
     * Filter which JournalAudit to delete.
     */
    where: JournalAuditWhereUniqueInput
  }

  /**
   * JournalAudit deleteMany
   */
  export type JournalAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalAudits to delete
     */
    where?: JournalAuditWhereInput
    /**
     * Limit how many JournalAudits to delete.
     */
    limit?: number
  }

  /**
   * JournalAudit.utilisateur
   */
  export type JournalAudit$utilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * JournalAudit without action
   */
  export type JournalAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalAudit
     */
    select?: JournalAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalAudit
     */
    omit?: JournalAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalAuditInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    processedBy: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    processedBy: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    status: $Enums.PaymentStatus | null
    notes: string | null
    processedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    status: $Enums.PaymentStatus | null
    notes: string | null
    processedBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    employeeId: number
    amount: number
    paymentDate: number
    paymentMethod: number
    reference: number
    status: number
    notes: number
    processedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    processedBy?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    processedBy?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    status?: true
    notes?: true
    processedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    status?: true
    notes?: true
    processedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    status?: true
    notes?: true
    processedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    employeeId: number
    amount: Decimal
    paymentDate: Date
    paymentMethod: $Enums.PaymentMethod
    reference: string | null
    status: $Enums.PaymentStatus
    notes: string | null
    processedBy: number | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    status?: boolean
    notes?: boolean
    processedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    cashier?: boolean | Payment$cashierArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    status?: boolean
    notes?: boolean
    processedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "amount" | "paymentDate" | "paymentMethod" | "reference" | "status" | "notes" | "processedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    cashier?: boolean | Payment$cashierArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      cashier: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      amount: Prisma.Decimal
      paymentDate: Date
      paymentMethod: $Enums.PaymentMethod
      reference: string | null
      status: $Enums.PaymentStatus
      notes: string | null
      processedBy: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cashier<T extends Payment$cashierArgs<ExtArgs> = {}>(args?: Subset<T, Payment$cashierArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly employeeId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly processedBy: FieldRef<"Payment", 'Int'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.cashier
   */
  export type Payment$cashierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    category: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    category: string | null
    isRead: boolean | null
    link: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    category: number
    isRead: number
    link: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    category?: true
    isRead?: true
    link?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    category?: true
    isRead?: true
    link?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    category?: true
    isRead?: true
    link?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    title: string
    message: string
    type: $Enums.NotificationType
    category: string
    isRead: boolean
    link: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    category?: boolean
    isRead?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    category?: boolean
    isRead?: boolean
    link?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "category" | "isRead" | "link" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      message: string
      type: $Enums.NotificationType
      category: string
      isRead: boolean
      link: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly category: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model CompanyFacture
   */

  export type AggregateCompanyFacture = {
    _count: CompanyFactureCountAggregateOutputType | null
    _avg: CompanyFactureAvgAggregateOutputType | null
    _sum: CompanyFactureSumAggregateOutputType | null
    _min: CompanyFactureMinAggregateOutputType | null
    _max: CompanyFactureMaxAggregateOutputType | null
  }

  export type CompanyFactureAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    montant: Decimal | null
    creePar: number | null
  }

  export type CompanyFactureSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    montant: Decimal | null
    creePar: number | null
  }

  export type CompanyFactureMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    numeroFacture: string | null
    montant: Decimal | null
    description: string | null
    statut: $Enums.CompanyStatutFacture | null
    dateEcheance: Date | null
    datePaiement: Date | null
    creePar: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyFactureMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    numeroFacture: string | null
    montant: Decimal | null
    description: string | null
    statut: $Enums.CompanyStatutFacture | null
    dateEcheance: Date | null
    datePaiement: Date | null
    creePar: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyFactureCountAggregateOutputType = {
    id: number
    employeeId: number
    numeroFacture: number
    montant: number
    description: number
    statut: number
    dateEcheance: number
    datePaiement: number
    creePar: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type CompanyFactureAvgAggregateInputType = {
    id?: true
    employeeId?: true
    montant?: true
    creePar?: true
  }

  export type CompanyFactureSumAggregateInputType = {
    id?: true
    employeeId?: true
    montant?: true
    creePar?: true
  }

  export type CompanyFactureMinAggregateInputType = {
    id?: true
    employeeId?: true
    numeroFacture?: true
    montant?: true
    description?: true
    statut?: true
    dateEcheance?: true
    datePaiement?: true
    creePar?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyFactureMaxAggregateInputType = {
    id?: true
    employeeId?: true
    numeroFacture?: true
    montant?: true
    description?: true
    statut?: true
    dateEcheance?: true
    datePaiement?: true
    creePar?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyFactureCountAggregateInputType = {
    id?: true
    employeeId?: true
    numeroFacture?: true
    montant?: true
    description?: true
    statut?: true
    dateEcheance?: true
    datePaiement?: true
    creePar?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyFactureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFacture to aggregate.
     */
    where?: CompanyFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFactures to fetch.
     */
    orderBy?: CompanyFactureOrderByWithRelationInput | CompanyFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyFactures
    **/
    _count?: true | CompanyFactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyFactureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyFactureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyFactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyFactureMaxAggregateInputType
  }

  export type GetCompanyFactureAggregateType<T extends CompanyFactureAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyFacture[P]>
      : GetScalarType<T[P], AggregateCompanyFacture[P]>
  }




  export type CompanyFactureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyFactureWhereInput
    orderBy?: CompanyFactureOrderByWithAggregationInput | CompanyFactureOrderByWithAggregationInput[]
    by: CompanyFactureScalarFieldEnum[] | CompanyFactureScalarFieldEnum
    having?: CompanyFactureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyFactureCountAggregateInputType | true
    _avg?: CompanyFactureAvgAggregateInputType
    _sum?: CompanyFactureSumAggregateInputType
    _min?: CompanyFactureMinAggregateInputType
    _max?: CompanyFactureMaxAggregateInputType
  }

  export type CompanyFactureGroupByOutputType = {
    id: number
    employeeId: number
    numeroFacture: string
    montant: Decimal
    description: string | null
    statut: $Enums.CompanyStatutFacture
    dateEcheance: Date | null
    datePaiement: Date | null
    creePar: number
    creeLe: Date
    modifieLe: Date
    _count: CompanyFactureCountAggregateOutputType | null
    _avg: CompanyFactureAvgAggregateOutputType | null
    _sum: CompanyFactureSumAggregateOutputType | null
    _min: CompanyFactureMinAggregateOutputType | null
    _max: CompanyFactureMaxAggregateOutputType | null
  }

  type GetCompanyFactureGroupByPayload<T extends CompanyFactureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyFactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyFactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyFactureGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyFactureGroupByOutputType[P]>
        }
      >
    >


  export type CompanyFactureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    numeroFacture?: boolean
    montant?: boolean
    description?: boolean
    statut?: boolean
    dateEcheance?: boolean
    datePaiement?: boolean
    creePar?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lignesFacture?: boolean | CompanyFacture$lignesFactureArgs<ExtArgs>
    _count?: boolean | CompanyFactureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyFacture"]>



  export type CompanyFactureSelectScalar = {
    id?: boolean
    employeeId?: boolean
    numeroFacture?: boolean
    montant?: boolean
    description?: boolean
    statut?: boolean
    dateEcheance?: boolean
    datePaiement?: boolean
    creePar?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type CompanyFactureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "numeroFacture" | "montant" | "description" | "statut" | "dateEcheance" | "datePaiement" | "creePar" | "creeLe" | "modifieLe", ExtArgs["result"]["companyFacture"]>
  export type CompanyFactureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    lignesFacture?: boolean | CompanyFacture$lignesFactureArgs<ExtArgs>
    _count?: boolean | CompanyFactureCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyFacturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyFacture"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      lignesFacture: Prisma.$CompanyLigneFacturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      numeroFacture: string
      montant: Prisma.Decimal
      description: string | null
      statut: $Enums.CompanyStatutFacture
      dateEcheance: Date | null
      datePaiement: Date | null
      creePar: number
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["companyFacture"]>
    composites: {}
  }

  type CompanyFactureGetPayload<S extends boolean | null | undefined | CompanyFactureDefaultArgs> = $Result.GetResult<Prisma.$CompanyFacturePayload, S>

  type CompanyFactureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFactureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyFactureCountAggregateInputType | true
    }

  export interface CompanyFactureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyFacture'], meta: { name: 'CompanyFacture' } }
    /**
     * Find zero or one CompanyFacture that matches the filter.
     * @param {CompanyFactureFindUniqueArgs} args - Arguments to find a CompanyFacture
     * @example
     * // Get one CompanyFacture
     * const companyFacture = await prisma.companyFacture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFactureFindUniqueArgs>(args: SelectSubset<T, CompanyFactureFindUniqueArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyFacture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFactureFindUniqueOrThrowArgs} args - Arguments to find a CompanyFacture
     * @example
     * // Get one CompanyFacture
     * const companyFacture = await prisma.companyFacture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFactureFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFactureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFacture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFactureFindFirstArgs} args - Arguments to find a CompanyFacture
     * @example
     * // Get one CompanyFacture
     * const companyFacture = await prisma.companyFacture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFactureFindFirstArgs>(args?: SelectSubset<T, CompanyFactureFindFirstArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyFacture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFactureFindFirstOrThrowArgs} args - Arguments to find a CompanyFacture
     * @example
     * // Get one CompanyFacture
     * const companyFacture = await prisma.companyFacture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFactureFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFactureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyFactures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFactureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyFactures
     * const companyFactures = await prisma.companyFacture.findMany()
     * 
     * // Get first 10 CompanyFactures
     * const companyFactures = await prisma.companyFacture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyFactureWithIdOnly = await prisma.companyFacture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFactureFindManyArgs>(args?: SelectSubset<T, CompanyFactureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyFacture.
     * @param {CompanyFactureCreateArgs} args - Arguments to create a CompanyFacture.
     * @example
     * // Create one CompanyFacture
     * const CompanyFacture = await prisma.companyFacture.create({
     *   data: {
     *     // ... data to create a CompanyFacture
     *   }
     * })
     * 
     */
    create<T extends CompanyFactureCreateArgs>(args: SelectSubset<T, CompanyFactureCreateArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyFactures.
     * @param {CompanyFactureCreateManyArgs} args - Arguments to create many CompanyFactures.
     * @example
     * // Create many CompanyFactures
     * const companyFacture = await prisma.companyFacture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyFactureCreateManyArgs>(args?: SelectSubset<T, CompanyFactureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyFacture.
     * @param {CompanyFactureDeleteArgs} args - Arguments to delete one CompanyFacture.
     * @example
     * // Delete one CompanyFacture
     * const CompanyFacture = await prisma.companyFacture.delete({
     *   where: {
     *     // ... filter to delete one CompanyFacture
     *   }
     * })
     * 
     */
    delete<T extends CompanyFactureDeleteArgs>(args: SelectSubset<T, CompanyFactureDeleteArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyFacture.
     * @param {CompanyFactureUpdateArgs} args - Arguments to update one CompanyFacture.
     * @example
     * // Update one CompanyFacture
     * const companyFacture = await prisma.companyFacture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyFactureUpdateArgs>(args: SelectSubset<T, CompanyFactureUpdateArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyFactures.
     * @param {CompanyFactureDeleteManyArgs} args - Arguments to filter CompanyFactures to delete.
     * @example
     * // Delete a few CompanyFactures
     * const { count } = await prisma.companyFacture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyFactureDeleteManyArgs>(args?: SelectSubset<T, CompanyFactureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFactureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyFactures
     * const companyFacture = await prisma.companyFacture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyFactureUpdateManyArgs>(args: SelectSubset<T, CompanyFactureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyFacture.
     * @param {CompanyFactureUpsertArgs} args - Arguments to update or create a CompanyFacture.
     * @example
     * // Update or create a CompanyFacture
     * const companyFacture = await prisma.companyFacture.upsert({
     *   create: {
     *     // ... data to create a CompanyFacture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyFacture we want to update
     *   }
     * })
     */
    upsert<T extends CompanyFactureUpsertArgs>(args: SelectSubset<T, CompanyFactureUpsertArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFactureCountArgs} args - Arguments to filter CompanyFactures to count.
     * @example
     * // Count the number of CompanyFactures
     * const count = await prisma.companyFacture.count({
     *   where: {
     *     // ... the filter for the CompanyFactures we want to count
     *   }
     * })
    **/
    count<T extends CompanyFactureCountArgs>(
      args?: Subset<T, CompanyFactureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyFactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyFactureAggregateArgs>(args: Subset<T, CompanyFactureAggregateArgs>): Prisma.PrismaPromise<GetCompanyFactureAggregateType<T>>

    /**
     * Group by CompanyFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFactureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyFactureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyFactureGroupByArgs['orderBy'] }
        : { orderBy?: CompanyFactureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyFactureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyFacture model
   */
  readonly fields: CompanyFactureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyFacture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyFactureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lignesFacture<T extends CompanyFacture$lignesFactureArgs<ExtArgs> = {}>(args?: Subset<T, CompanyFacture$lignesFactureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyFacture model
   */
  interface CompanyFactureFieldRefs {
    readonly id: FieldRef<"CompanyFacture", 'Int'>
    readonly employeeId: FieldRef<"CompanyFacture", 'Int'>
    readonly numeroFacture: FieldRef<"CompanyFacture", 'String'>
    readonly montant: FieldRef<"CompanyFacture", 'Decimal'>
    readonly description: FieldRef<"CompanyFacture", 'String'>
    readonly statut: FieldRef<"CompanyFacture", 'CompanyStatutFacture'>
    readonly dateEcheance: FieldRef<"CompanyFacture", 'DateTime'>
    readonly datePaiement: FieldRef<"CompanyFacture", 'DateTime'>
    readonly creePar: FieldRef<"CompanyFacture", 'Int'>
    readonly creeLe: FieldRef<"CompanyFacture", 'DateTime'>
    readonly modifieLe: FieldRef<"CompanyFacture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyFacture findUnique
   */
  export type CompanyFactureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFacture to fetch.
     */
    where: CompanyFactureWhereUniqueInput
  }

  /**
   * CompanyFacture findUniqueOrThrow
   */
  export type CompanyFactureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFacture to fetch.
     */
    where: CompanyFactureWhereUniqueInput
  }

  /**
   * CompanyFacture findFirst
   */
  export type CompanyFactureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFacture to fetch.
     */
    where?: CompanyFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFactures to fetch.
     */
    orderBy?: CompanyFactureOrderByWithRelationInput | CompanyFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFactures.
     */
    cursor?: CompanyFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFactures.
     */
    distinct?: CompanyFactureScalarFieldEnum | CompanyFactureScalarFieldEnum[]
  }

  /**
   * CompanyFacture findFirstOrThrow
   */
  export type CompanyFactureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFacture to fetch.
     */
    where?: CompanyFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFactures to fetch.
     */
    orderBy?: CompanyFactureOrderByWithRelationInput | CompanyFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyFactures.
     */
    cursor?: CompanyFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyFactures.
     */
    distinct?: CompanyFactureScalarFieldEnum | CompanyFactureScalarFieldEnum[]
  }

  /**
   * CompanyFacture findMany
   */
  export type CompanyFactureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyFactures to fetch.
     */
    where?: CompanyFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyFactures to fetch.
     */
    orderBy?: CompanyFactureOrderByWithRelationInput | CompanyFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyFactures.
     */
    cursor?: CompanyFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyFactures.
     */
    skip?: number
    distinct?: CompanyFactureScalarFieldEnum | CompanyFactureScalarFieldEnum[]
  }

  /**
   * CompanyFacture create
   */
  export type CompanyFactureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyFacture.
     */
    data: XOR<CompanyFactureCreateInput, CompanyFactureUncheckedCreateInput>
  }

  /**
   * CompanyFacture createMany
   */
  export type CompanyFactureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyFactures.
     */
    data: CompanyFactureCreateManyInput | CompanyFactureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyFacture update
   */
  export type CompanyFactureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyFacture.
     */
    data: XOR<CompanyFactureUpdateInput, CompanyFactureUncheckedUpdateInput>
    /**
     * Choose, which CompanyFacture to update.
     */
    where: CompanyFactureWhereUniqueInput
  }

  /**
   * CompanyFacture updateMany
   */
  export type CompanyFactureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyFactures.
     */
    data: XOR<CompanyFactureUpdateManyMutationInput, CompanyFactureUncheckedUpdateManyInput>
    /**
     * Filter which CompanyFactures to update
     */
    where?: CompanyFactureWhereInput
    /**
     * Limit how many CompanyFactures to update.
     */
    limit?: number
  }

  /**
   * CompanyFacture upsert
   */
  export type CompanyFactureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyFacture to update in case it exists.
     */
    where: CompanyFactureWhereUniqueInput
    /**
     * In case the CompanyFacture found by the `where` argument doesn't exist, create a new CompanyFacture with this data.
     */
    create: XOR<CompanyFactureCreateInput, CompanyFactureUncheckedCreateInput>
    /**
     * In case the CompanyFacture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyFactureUpdateInput, CompanyFactureUncheckedUpdateInput>
  }

  /**
   * CompanyFacture delete
   */
  export type CompanyFactureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
    /**
     * Filter which CompanyFacture to delete.
     */
    where: CompanyFactureWhereUniqueInput
  }

  /**
   * CompanyFacture deleteMany
   */
  export type CompanyFactureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyFactures to delete
     */
    where?: CompanyFactureWhereInput
    /**
     * Limit how many CompanyFactures to delete.
     */
    limit?: number
  }

  /**
   * CompanyFacture.lignesFacture
   */
  export type CompanyFacture$lignesFactureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    where?: CompanyLigneFactureWhereInput
    orderBy?: CompanyLigneFactureOrderByWithRelationInput | CompanyLigneFactureOrderByWithRelationInput[]
    cursor?: CompanyLigneFactureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyLigneFactureScalarFieldEnum | CompanyLigneFactureScalarFieldEnum[]
  }

  /**
   * CompanyFacture without action
   */
  export type CompanyFactureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyFacture
     */
    select?: CompanyFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyFacture
     */
    omit?: CompanyFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyFactureInclude<ExtArgs> | null
  }


  /**
   * Model CompanyLigneFacture
   */

  export type AggregateCompanyLigneFacture = {
    _count: CompanyLigneFactureCountAggregateOutputType | null
    _avg: CompanyLigneFactureAvgAggregateOutputType | null
    _sum: CompanyLigneFactureSumAggregateOutputType | null
    _min: CompanyLigneFactureMinAggregateOutputType | null
    _max: CompanyLigneFactureMaxAggregateOutputType | null
  }

  export type CompanyLigneFactureAvgAggregateOutputType = {
    id: number | null
    factureId: number | null
    quantite: number | null
    prixUnitaire: Decimal | null
    prixTotal: Decimal | null
  }

  export type CompanyLigneFactureSumAggregateOutputType = {
    id: number | null
    factureId: number | null
    quantite: number | null
    prixUnitaire: Decimal | null
    prixTotal: Decimal | null
  }

  export type CompanyLigneFactureMinAggregateOutputType = {
    id: number | null
    factureId: number | null
    description: string | null
    quantite: number | null
    prixUnitaire: Decimal | null
    prixTotal: Decimal | null
    creeLe: Date | null
  }

  export type CompanyLigneFactureMaxAggregateOutputType = {
    id: number | null
    factureId: number | null
    description: string | null
    quantite: number | null
    prixUnitaire: Decimal | null
    prixTotal: Decimal | null
    creeLe: Date | null
  }

  export type CompanyLigneFactureCountAggregateOutputType = {
    id: number
    factureId: number
    description: number
    quantite: number
    prixUnitaire: number
    prixTotal: number
    creeLe: number
    _all: number
  }


  export type CompanyLigneFactureAvgAggregateInputType = {
    id?: true
    factureId?: true
    quantite?: true
    prixUnitaire?: true
    prixTotal?: true
  }

  export type CompanyLigneFactureSumAggregateInputType = {
    id?: true
    factureId?: true
    quantite?: true
    prixUnitaire?: true
    prixTotal?: true
  }

  export type CompanyLigneFactureMinAggregateInputType = {
    id?: true
    factureId?: true
    description?: true
    quantite?: true
    prixUnitaire?: true
    prixTotal?: true
    creeLe?: true
  }

  export type CompanyLigneFactureMaxAggregateInputType = {
    id?: true
    factureId?: true
    description?: true
    quantite?: true
    prixUnitaire?: true
    prixTotal?: true
    creeLe?: true
  }

  export type CompanyLigneFactureCountAggregateInputType = {
    id?: true
    factureId?: true
    description?: true
    quantite?: true
    prixUnitaire?: true
    prixTotal?: true
    creeLe?: true
    _all?: true
  }

  export type CompanyLigneFactureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyLigneFacture to aggregate.
     */
    where?: CompanyLigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyLigneFactures to fetch.
     */
    orderBy?: CompanyLigneFactureOrderByWithRelationInput | CompanyLigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyLigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyLigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyLigneFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyLigneFactures
    **/
    _count?: true | CompanyLigneFactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyLigneFactureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyLigneFactureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyLigneFactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyLigneFactureMaxAggregateInputType
  }

  export type GetCompanyLigneFactureAggregateType<T extends CompanyLigneFactureAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyLigneFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyLigneFacture[P]>
      : GetScalarType<T[P], AggregateCompanyLigneFacture[P]>
  }




  export type CompanyLigneFactureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyLigneFactureWhereInput
    orderBy?: CompanyLigneFactureOrderByWithAggregationInput | CompanyLigneFactureOrderByWithAggregationInput[]
    by: CompanyLigneFactureScalarFieldEnum[] | CompanyLigneFactureScalarFieldEnum
    having?: CompanyLigneFactureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyLigneFactureCountAggregateInputType | true
    _avg?: CompanyLigneFactureAvgAggregateInputType
    _sum?: CompanyLigneFactureSumAggregateInputType
    _min?: CompanyLigneFactureMinAggregateInputType
    _max?: CompanyLigneFactureMaxAggregateInputType
  }

  export type CompanyLigneFactureGroupByOutputType = {
    id: number
    factureId: number
    description: string
    quantite: number
    prixUnitaire: Decimal
    prixTotal: Decimal
    creeLe: Date
    _count: CompanyLigneFactureCountAggregateOutputType | null
    _avg: CompanyLigneFactureAvgAggregateOutputType | null
    _sum: CompanyLigneFactureSumAggregateOutputType | null
    _min: CompanyLigneFactureMinAggregateOutputType | null
    _max: CompanyLigneFactureMaxAggregateOutputType | null
  }

  type GetCompanyLigneFactureGroupByPayload<T extends CompanyLigneFactureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyLigneFactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyLigneFactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyLigneFactureGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyLigneFactureGroupByOutputType[P]>
        }
      >
    >


  export type CompanyLigneFactureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    description?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    prixTotal?: boolean
    creeLe?: boolean
    facture?: boolean | CompanyFactureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyLigneFacture"]>



  export type CompanyLigneFactureSelectScalar = {
    id?: boolean
    factureId?: boolean
    description?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    prixTotal?: boolean
    creeLe?: boolean
  }

  export type CompanyLigneFactureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "factureId" | "description" | "quantite" | "prixUnitaire" | "prixTotal" | "creeLe", ExtArgs["result"]["companyLigneFacture"]>
  export type CompanyLigneFactureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | CompanyFactureDefaultArgs<ExtArgs>
  }

  export type $CompanyLigneFacturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyLigneFacture"
    objects: {
      facture: Prisma.$CompanyFacturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      factureId: number
      description: string
      quantite: number
      prixUnitaire: Prisma.Decimal
      prixTotal: Prisma.Decimal
      creeLe: Date
    }, ExtArgs["result"]["companyLigneFacture"]>
    composites: {}
  }

  type CompanyLigneFactureGetPayload<S extends boolean | null | undefined | CompanyLigneFactureDefaultArgs> = $Result.GetResult<Prisma.$CompanyLigneFacturePayload, S>

  type CompanyLigneFactureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyLigneFactureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyLigneFactureCountAggregateInputType | true
    }

  export interface CompanyLigneFactureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyLigneFacture'], meta: { name: 'CompanyLigneFacture' } }
    /**
     * Find zero or one CompanyLigneFacture that matches the filter.
     * @param {CompanyLigneFactureFindUniqueArgs} args - Arguments to find a CompanyLigneFacture
     * @example
     * // Get one CompanyLigneFacture
     * const companyLigneFacture = await prisma.companyLigneFacture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyLigneFactureFindUniqueArgs>(args: SelectSubset<T, CompanyLigneFactureFindUniqueArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyLigneFacture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyLigneFactureFindUniqueOrThrowArgs} args - Arguments to find a CompanyLigneFacture
     * @example
     * // Get one CompanyLigneFacture
     * const companyLigneFacture = await prisma.companyLigneFacture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyLigneFactureFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyLigneFactureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyLigneFacture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLigneFactureFindFirstArgs} args - Arguments to find a CompanyLigneFacture
     * @example
     * // Get one CompanyLigneFacture
     * const companyLigneFacture = await prisma.companyLigneFacture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyLigneFactureFindFirstArgs>(args?: SelectSubset<T, CompanyLigneFactureFindFirstArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyLigneFacture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLigneFactureFindFirstOrThrowArgs} args - Arguments to find a CompanyLigneFacture
     * @example
     * // Get one CompanyLigneFacture
     * const companyLigneFacture = await prisma.companyLigneFacture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyLigneFactureFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyLigneFactureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyLigneFactures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLigneFactureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyLigneFactures
     * const companyLigneFactures = await prisma.companyLigneFacture.findMany()
     * 
     * // Get first 10 CompanyLigneFactures
     * const companyLigneFactures = await prisma.companyLigneFacture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyLigneFactureWithIdOnly = await prisma.companyLigneFacture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyLigneFactureFindManyArgs>(args?: SelectSubset<T, CompanyLigneFactureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyLigneFacture.
     * @param {CompanyLigneFactureCreateArgs} args - Arguments to create a CompanyLigneFacture.
     * @example
     * // Create one CompanyLigneFacture
     * const CompanyLigneFacture = await prisma.companyLigneFacture.create({
     *   data: {
     *     // ... data to create a CompanyLigneFacture
     *   }
     * })
     * 
     */
    create<T extends CompanyLigneFactureCreateArgs>(args: SelectSubset<T, CompanyLigneFactureCreateArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyLigneFactures.
     * @param {CompanyLigneFactureCreateManyArgs} args - Arguments to create many CompanyLigneFactures.
     * @example
     * // Create many CompanyLigneFactures
     * const companyLigneFacture = await prisma.companyLigneFacture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyLigneFactureCreateManyArgs>(args?: SelectSubset<T, CompanyLigneFactureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyLigneFacture.
     * @param {CompanyLigneFactureDeleteArgs} args - Arguments to delete one CompanyLigneFacture.
     * @example
     * // Delete one CompanyLigneFacture
     * const CompanyLigneFacture = await prisma.companyLigneFacture.delete({
     *   where: {
     *     // ... filter to delete one CompanyLigneFacture
     *   }
     * })
     * 
     */
    delete<T extends CompanyLigneFactureDeleteArgs>(args: SelectSubset<T, CompanyLigneFactureDeleteArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyLigneFacture.
     * @param {CompanyLigneFactureUpdateArgs} args - Arguments to update one CompanyLigneFacture.
     * @example
     * // Update one CompanyLigneFacture
     * const companyLigneFacture = await prisma.companyLigneFacture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyLigneFactureUpdateArgs>(args: SelectSubset<T, CompanyLigneFactureUpdateArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyLigneFactures.
     * @param {CompanyLigneFactureDeleteManyArgs} args - Arguments to filter CompanyLigneFactures to delete.
     * @example
     * // Delete a few CompanyLigneFactures
     * const { count } = await prisma.companyLigneFacture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyLigneFactureDeleteManyArgs>(args?: SelectSubset<T, CompanyLigneFactureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyLigneFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLigneFactureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyLigneFactures
     * const companyLigneFacture = await prisma.companyLigneFacture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyLigneFactureUpdateManyArgs>(args: SelectSubset<T, CompanyLigneFactureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyLigneFacture.
     * @param {CompanyLigneFactureUpsertArgs} args - Arguments to update or create a CompanyLigneFacture.
     * @example
     * // Update or create a CompanyLigneFacture
     * const companyLigneFacture = await prisma.companyLigneFacture.upsert({
     *   create: {
     *     // ... data to create a CompanyLigneFacture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyLigneFacture we want to update
     *   }
     * })
     */
    upsert<T extends CompanyLigneFactureUpsertArgs>(args: SelectSubset<T, CompanyLigneFactureUpsertArgs<ExtArgs>>): Prisma__CompanyLigneFactureClient<$Result.GetResult<Prisma.$CompanyLigneFacturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyLigneFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLigneFactureCountArgs} args - Arguments to filter CompanyLigneFactures to count.
     * @example
     * // Count the number of CompanyLigneFactures
     * const count = await prisma.companyLigneFacture.count({
     *   where: {
     *     // ... the filter for the CompanyLigneFactures we want to count
     *   }
     * })
    **/
    count<T extends CompanyLigneFactureCountArgs>(
      args?: Subset<T, CompanyLigneFactureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyLigneFactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyLigneFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLigneFactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyLigneFactureAggregateArgs>(args: Subset<T, CompanyLigneFactureAggregateArgs>): Prisma.PrismaPromise<GetCompanyLigneFactureAggregateType<T>>

    /**
     * Group by CompanyLigneFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLigneFactureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyLigneFactureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyLigneFactureGroupByArgs['orderBy'] }
        : { orderBy?: CompanyLigneFactureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyLigneFactureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyLigneFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyLigneFacture model
   */
  readonly fields: CompanyLigneFactureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyLigneFacture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyLigneFactureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facture<T extends CompanyFactureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyFactureDefaultArgs<ExtArgs>>): Prisma__CompanyFactureClient<$Result.GetResult<Prisma.$CompanyFacturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyLigneFacture model
   */
  interface CompanyLigneFactureFieldRefs {
    readonly id: FieldRef<"CompanyLigneFacture", 'Int'>
    readonly factureId: FieldRef<"CompanyLigneFacture", 'Int'>
    readonly description: FieldRef<"CompanyLigneFacture", 'String'>
    readonly quantite: FieldRef<"CompanyLigneFacture", 'Int'>
    readonly prixUnitaire: FieldRef<"CompanyLigneFacture", 'Decimal'>
    readonly prixTotal: FieldRef<"CompanyLigneFacture", 'Decimal'>
    readonly creeLe: FieldRef<"CompanyLigneFacture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyLigneFacture findUnique
   */
  export type CompanyLigneFactureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyLigneFacture to fetch.
     */
    where: CompanyLigneFactureWhereUniqueInput
  }

  /**
   * CompanyLigneFacture findUniqueOrThrow
   */
  export type CompanyLigneFactureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyLigneFacture to fetch.
     */
    where: CompanyLigneFactureWhereUniqueInput
  }

  /**
   * CompanyLigneFacture findFirst
   */
  export type CompanyLigneFactureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyLigneFacture to fetch.
     */
    where?: CompanyLigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyLigneFactures to fetch.
     */
    orderBy?: CompanyLigneFactureOrderByWithRelationInput | CompanyLigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyLigneFactures.
     */
    cursor?: CompanyLigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyLigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyLigneFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyLigneFactures.
     */
    distinct?: CompanyLigneFactureScalarFieldEnum | CompanyLigneFactureScalarFieldEnum[]
  }

  /**
   * CompanyLigneFacture findFirstOrThrow
   */
  export type CompanyLigneFactureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyLigneFacture to fetch.
     */
    where?: CompanyLigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyLigneFactures to fetch.
     */
    orderBy?: CompanyLigneFactureOrderByWithRelationInput | CompanyLigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyLigneFactures.
     */
    cursor?: CompanyLigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyLigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyLigneFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyLigneFactures.
     */
    distinct?: CompanyLigneFactureScalarFieldEnum | CompanyLigneFactureScalarFieldEnum[]
  }

  /**
   * CompanyLigneFacture findMany
   */
  export type CompanyLigneFactureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which CompanyLigneFactures to fetch.
     */
    where?: CompanyLigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyLigneFactures to fetch.
     */
    orderBy?: CompanyLigneFactureOrderByWithRelationInput | CompanyLigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyLigneFactures.
     */
    cursor?: CompanyLigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyLigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyLigneFactures.
     */
    skip?: number
    distinct?: CompanyLigneFactureScalarFieldEnum | CompanyLigneFactureScalarFieldEnum[]
  }

  /**
   * CompanyLigneFacture create
   */
  export type CompanyLigneFactureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyLigneFacture.
     */
    data: XOR<CompanyLigneFactureCreateInput, CompanyLigneFactureUncheckedCreateInput>
  }

  /**
   * CompanyLigneFacture createMany
   */
  export type CompanyLigneFactureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyLigneFactures.
     */
    data: CompanyLigneFactureCreateManyInput | CompanyLigneFactureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyLigneFacture update
   */
  export type CompanyLigneFactureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyLigneFacture.
     */
    data: XOR<CompanyLigneFactureUpdateInput, CompanyLigneFactureUncheckedUpdateInput>
    /**
     * Choose, which CompanyLigneFacture to update.
     */
    where: CompanyLigneFactureWhereUniqueInput
  }

  /**
   * CompanyLigneFacture updateMany
   */
  export type CompanyLigneFactureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyLigneFactures.
     */
    data: XOR<CompanyLigneFactureUpdateManyMutationInput, CompanyLigneFactureUncheckedUpdateManyInput>
    /**
     * Filter which CompanyLigneFactures to update
     */
    where?: CompanyLigneFactureWhereInput
    /**
     * Limit how many CompanyLigneFactures to update.
     */
    limit?: number
  }

  /**
   * CompanyLigneFacture upsert
   */
  export type CompanyLigneFactureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyLigneFacture to update in case it exists.
     */
    where: CompanyLigneFactureWhereUniqueInput
    /**
     * In case the CompanyLigneFacture found by the `where` argument doesn't exist, create a new CompanyLigneFacture with this data.
     */
    create: XOR<CompanyLigneFactureCreateInput, CompanyLigneFactureUncheckedCreateInput>
    /**
     * In case the CompanyLigneFacture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyLigneFactureUpdateInput, CompanyLigneFactureUncheckedUpdateInput>
  }

  /**
   * CompanyLigneFacture delete
   */
  export type CompanyLigneFactureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
    /**
     * Filter which CompanyLigneFacture to delete.
     */
    where: CompanyLigneFactureWhereUniqueInput
  }

  /**
   * CompanyLigneFacture deleteMany
   */
  export type CompanyLigneFactureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyLigneFactures to delete
     */
    where?: CompanyLigneFactureWhereInput
    /**
     * Limit how many CompanyLigneFactures to delete.
     */
    limit?: number
  }

  /**
   * CompanyLigneFacture without action
   */
  export type CompanyLigneFactureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLigneFacture
     */
    select?: CompanyLigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyLigneFacture
     */
    omit?: CompanyLigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyLigneFactureInclude<ExtArgs> | null
  }


  /**
   * Model CompanyPayRun
   */

  export type AggregateCompanyPayRun = {
    _count: CompanyPayRunCountAggregateOutputType | null
    _avg: CompanyPayRunAvgAggregateOutputType | null
    _sum: CompanyPayRunSumAggregateOutputType | null
    _min: CompanyPayRunMinAggregateOutputType | null
    _max: CompanyPayRunMaxAggregateOutputType | null
  }

  export type CompanyPayRunAvgAggregateOutputType = {
    id: number | null
    totalBrut: Decimal | null
    totalNet: Decimal | null
    totalDeductions: Decimal | null
    nombreEmployes: number | null
    entrepriseId: number | null
    periodePaieId: number | null
    creePar: number | null
    approuvePar: number | null
  }

  export type CompanyPayRunSumAggregateOutputType = {
    id: number | null
    totalBrut: Decimal | null
    totalNet: Decimal | null
    totalDeductions: Decimal | null
    nombreEmployes: number | null
    entrepriseId: number | null
    periodePaieId: number | null
    creePar: number | null
    approuvePar: number | null
  }

  export type CompanyPayRunMinAggregateOutputType = {
    id: number | null
    reference: string | null
    dateDebut: Date | null
    dateFin: Date | null
    datePaiement: Date | null
    statut: $Enums.CompanyStatutPayRun | null
    totalBrut: Decimal | null
    totalNet: Decimal | null
    totalDeductions: Decimal | null
    nombreEmployes: number | null
    entrepriseId: number | null
    periodePaieId: number | null
    creePar: number | null
    creeLe: Date | null
    approuveLe: Date | null
    approuvePar: number | null
  }

  export type CompanyPayRunMaxAggregateOutputType = {
    id: number | null
    reference: string | null
    dateDebut: Date | null
    dateFin: Date | null
    datePaiement: Date | null
    statut: $Enums.CompanyStatutPayRun | null
    totalBrut: Decimal | null
    totalNet: Decimal | null
    totalDeductions: Decimal | null
    nombreEmployes: number | null
    entrepriseId: number | null
    periodePaieId: number | null
    creePar: number | null
    creeLe: Date | null
    approuveLe: Date | null
    approuvePar: number | null
  }

  export type CompanyPayRunCountAggregateOutputType = {
    id: number
    reference: number
    dateDebut: number
    dateFin: number
    datePaiement: number
    statut: number
    totalBrut: number
    totalNet: number
    totalDeductions: number
    nombreEmployes: number
    metadata: number
    entrepriseId: number
    periodePaieId: number
    creePar: number
    creeLe: number
    approuveLe: number
    approuvePar: number
    _all: number
  }


  export type CompanyPayRunAvgAggregateInputType = {
    id?: true
    totalBrut?: true
    totalNet?: true
    totalDeductions?: true
    nombreEmployes?: true
    entrepriseId?: true
    periodePaieId?: true
    creePar?: true
    approuvePar?: true
  }

  export type CompanyPayRunSumAggregateInputType = {
    id?: true
    totalBrut?: true
    totalNet?: true
    totalDeductions?: true
    nombreEmployes?: true
    entrepriseId?: true
    periodePaieId?: true
    creePar?: true
    approuvePar?: true
  }

  export type CompanyPayRunMinAggregateInputType = {
    id?: true
    reference?: true
    dateDebut?: true
    dateFin?: true
    datePaiement?: true
    statut?: true
    totalBrut?: true
    totalNet?: true
    totalDeductions?: true
    nombreEmployes?: true
    entrepriseId?: true
    periodePaieId?: true
    creePar?: true
    creeLe?: true
    approuveLe?: true
    approuvePar?: true
  }

  export type CompanyPayRunMaxAggregateInputType = {
    id?: true
    reference?: true
    dateDebut?: true
    dateFin?: true
    datePaiement?: true
    statut?: true
    totalBrut?: true
    totalNet?: true
    totalDeductions?: true
    nombreEmployes?: true
    entrepriseId?: true
    periodePaieId?: true
    creePar?: true
    creeLe?: true
    approuveLe?: true
    approuvePar?: true
  }

  export type CompanyPayRunCountAggregateInputType = {
    id?: true
    reference?: true
    dateDebut?: true
    dateFin?: true
    datePaiement?: true
    statut?: true
    totalBrut?: true
    totalNet?: true
    totalDeductions?: true
    nombreEmployes?: true
    metadata?: true
    entrepriseId?: true
    periodePaieId?: true
    creePar?: true
    creeLe?: true
    approuveLe?: true
    approuvePar?: true
    _all?: true
  }

  export type CompanyPayRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPayRun to aggregate.
     */
    where?: CompanyPayRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPayRuns to fetch.
     */
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyPayRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPayRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPayRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyPayRuns
    **/
    _count?: true | CompanyPayRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyPayRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyPayRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyPayRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyPayRunMaxAggregateInputType
  }

  export type GetCompanyPayRunAggregateType<T extends CompanyPayRunAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyPayRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyPayRun[P]>
      : GetScalarType<T[P], AggregateCompanyPayRun[P]>
  }




  export type CompanyPayRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPayRunWhereInput
    orderBy?: CompanyPayRunOrderByWithAggregationInput | CompanyPayRunOrderByWithAggregationInput[]
    by: CompanyPayRunScalarFieldEnum[] | CompanyPayRunScalarFieldEnum
    having?: CompanyPayRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyPayRunCountAggregateInputType | true
    _avg?: CompanyPayRunAvgAggregateInputType
    _sum?: CompanyPayRunSumAggregateInputType
    _min?: CompanyPayRunMinAggregateInputType
    _max?: CompanyPayRunMaxAggregateInputType
  }

  export type CompanyPayRunGroupByOutputType = {
    id: number
    reference: string
    dateDebut: Date
    dateFin: Date
    datePaiement: Date
    statut: $Enums.CompanyStatutPayRun
    totalBrut: Decimal
    totalNet: Decimal
    totalDeductions: Decimal
    nombreEmployes: number
    metadata: JsonValue | null
    entrepriseId: number
    periodePaieId: number
    creePar: number
    creeLe: Date
    approuveLe: Date | null
    approuvePar: number | null
    _count: CompanyPayRunCountAggregateOutputType | null
    _avg: CompanyPayRunAvgAggregateOutputType | null
    _sum: CompanyPayRunSumAggregateOutputType | null
    _min: CompanyPayRunMinAggregateOutputType | null
    _max: CompanyPayRunMaxAggregateOutputType | null
  }

  type GetCompanyPayRunGroupByPayload<T extends CompanyPayRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyPayRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyPayRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyPayRunGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyPayRunGroupByOutputType[P]>
        }
      >
    >


  export type CompanyPayRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    datePaiement?: boolean
    statut?: boolean
    totalBrut?: boolean
    totalNet?: boolean
    totalDeductions?: boolean
    nombreEmployes?: boolean
    metadata?: boolean
    entrepriseId?: boolean
    periodePaieId?: boolean
    creePar?: boolean
    creeLe?: boolean
    approuveLe?: boolean
    approuvePar?: boolean
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    periodePaie?: boolean | CompanyPeriodePaieDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | CompanyPayRun$approverArgs<ExtArgs>
    bulletins?: boolean | CompanyPayRun$bulletinsArgs<ExtArgs>
    _count?: boolean | CompanyPayRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyPayRun"]>



  export type CompanyPayRunSelectScalar = {
    id?: boolean
    reference?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    datePaiement?: boolean
    statut?: boolean
    totalBrut?: boolean
    totalNet?: boolean
    totalDeductions?: boolean
    nombreEmployes?: boolean
    metadata?: boolean
    entrepriseId?: boolean
    periodePaieId?: boolean
    creePar?: boolean
    creeLe?: boolean
    approuveLe?: boolean
    approuvePar?: boolean
  }

  export type CompanyPayRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reference" | "dateDebut" | "dateFin" | "datePaiement" | "statut" | "totalBrut" | "totalNet" | "totalDeductions" | "nombreEmployes" | "metadata" | "entrepriseId" | "periodePaieId" | "creePar" | "creeLe" | "approuveLe" | "approuvePar", ExtArgs["result"]["companyPayRun"]>
  export type CompanyPayRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    periodePaie?: boolean | CompanyPeriodePaieDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | CompanyPayRun$approverArgs<ExtArgs>
    bulletins?: boolean | CompanyPayRun$bulletinsArgs<ExtArgs>
    _count?: boolean | CompanyPayRunCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyPayRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyPayRun"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
      periodePaie: Prisma.$CompanyPeriodePaiePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      bulletins: Prisma.$CompanyBulletinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reference: string
      dateDebut: Date
      dateFin: Date
      datePaiement: Date
      statut: $Enums.CompanyStatutPayRun
      totalBrut: Prisma.Decimal
      totalNet: Prisma.Decimal
      totalDeductions: Prisma.Decimal
      nombreEmployes: number
      metadata: Prisma.JsonValue | null
      entrepriseId: number
      periodePaieId: number
      creePar: number
      creeLe: Date
      approuveLe: Date | null
      approuvePar: number | null
    }, ExtArgs["result"]["companyPayRun"]>
    composites: {}
  }

  type CompanyPayRunGetPayload<S extends boolean | null | undefined | CompanyPayRunDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayRunPayload, S>

  type CompanyPayRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyPayRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyPayRunCountAggregateInputType | true
    }

  export interface CompanyPayRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyPayRun'], meta: { name: 'CompanyPayRun' } }
    /**
     * Find zero or one CompanyPayRun that matches the filter.
     * @param {CompanyPayRunFindUniqueArgs} args - Arguments to find a CompanyPayRun
     * @example
     * // Get one CompanyPayRun
     * const companyPayRun = await prisma.companyPayRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyPayRunFindUniqueArgs>(args: SelectSubset<T, CompanyPayRunFindUniqueArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyPayRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyPayRunFindUniqueOrThrowArgs} args - Arguments to find a CompanyPayRun
     * @example
     * // Get one CompanyPayRun
     * const companyPayRun = await prisma.companyPayRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyPayRunFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyPayRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyPayRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPayRunFindFirstArgs} args - Arguments to find a CompanyPayRun
     * @example
     * // Get one CompanyPayRun
     * const companyPayRun = await prisma.companyPayRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyPayRunFindFirstArgs>(args?: SelectSubset<T, CompanyPayRunFindFirstArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyPayRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPayRunFindFirstOrThrowArgs} args - Arguments to find a CompanyPayRun
     * @example
     * // Get one CompanyPayRun
     * const companyPayRun = await prisma.companyPayRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyPayRunFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyPayRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyPayRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPayRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyPayRuns
     * const companyPayRuns = await prisma.companyPayRun.findMany()
     * 
     * // Get first 10 CompanyPayRuns
     * const companyPayRuns = await prisma.companyPayRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyPayRunWithIdOnly = await prisma.companyPayRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyPayRunFindManyArgs>(args?: SelectSubset<T, CompanyPayRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyPayRun.
     * @param {CompanyPayRunCreateArgs} args - Arguments to create a CompanyPayRun.
     * @example
     * // Create one CompanyPayRun
     * const CompanyPayRun = await prisma.companyPayRun.create({
     *   data: {
     *     // ... data to create a CompanyPayRun
     *   }
     * })
     * 
     */
    create<T extends CompanyPayRunCreateArgs>(args: SelectSubset<T, CompanyPayRunCreateArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyPayRuns.
     * @param {CompanyPayRunCreateManyArgs} args - Arguments to create many CompanyPayRuns.
     * @example
     * // Create many CompanyPayRuns
     * const companyPayRun = await prisma.companyPayRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyPayRunCreateManyArgs>(args?: SelectSubset<T, CompanyPayRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyPayRun.
     * @param {CompanyPayRunDeleteArgs} args - Arguments to delete one CompanyPayRun.
     * @example
     * // Delete one CompanyPayRun
     * const CompanyPayRun = await prisma.companyPayRun.delete({
     *   where: {
     *     // ... filter to delete one CompanyPayRun
     *   }
     * })
     * 
     */
    delete<T extends CompanyPayRunDeleteArgs>(args: SelectSubset<T, CompanyPayRunDeleteArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyPayRun.
     * @param {CompanyPayRunUpdateArgs} args - Arguments to update one CompanyPayRun.
     * @example
     * // Update one CompanyPayRun
     * const companyPayRun = await prisma.companyPayRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyPayRunUpdateArgs>(args: SelectSubset<T, CompanyPayRunUpdateArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyPayRuns.
     * @param {CompanyPayRunDeleteManyArgs} args - Arguments to filter CompanyPayRuns to delete.
     * @example
     * // Delete a few CompanyPayRuns
     * const { count } = await prisma.companyPayRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyPayRunDeleteManyArgs>(args?: SelectSubset<T, CompanyPayRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyPayRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPayRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyPayRuns
     * const companyPayRun = await prisma.companyPayRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyPayRunUpdateManyArgs>(args: SelectSubset<T, CompanyPayRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyPayRun.
     * @param {CompanyPayRunUpsertArgs} args - Arguments to update or create a CompanyPayRun.
     * @example
     * // Update or create a CompanyPayRun
     * const companyPayRun = await prisma.companyPayRun.upsert({
     *   create: {
     *     // ... data to create a CompanyPayRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyPayRun we want to update
     *   }
     * })
     */
    upsert<T extends CompanyPayRunUpsertArgs>(args: SelectSubset<T, CompanyPayRunUpsertArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyPayRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPayRunCountArgs} args - Arguments to filter CompanyPayRuns to count.
     * @example
     * // Count the number of CompanyPayRuns
     * const count = await prisma.companyPayRun.count({
     *   where: {
     *     // ... the filter for the CompanyPayRuns we want to count
     *   }
     * })
    **/
    count<T extends CompanyPayRunCountArgs>(
      args?: Subset<T, CompanyPayRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyPayRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyPayRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPayRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyPayRunAggregateArgs>(args: Subset<T, CompanyPayRunAggregateArgs>): Prisma.PrismaPromise<GetCompanyPayRunAggregateType<T>>

    /**
     * Group by CompanyPayRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPayRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyPayRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyPayRunGroupByArgs['orderBy'] }
        : { orderBy?: CompanyPayRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyPayRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyPayRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyPayRun model
   */
  readonly fields: CompanyPayRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyPayRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyPayRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    periodePaie<T extends CompanyPeriodePaieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyPeriodePaieDefaultArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends CompanyPayRun$approverArgs<ExtArgs> = {}>(args?: Subset<T, CompanyPayRun$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bulletins<T extends CompanyPayRun$bulletinsArgs<ExtArgs> = {}>(args?: Subset<T, CompanyPayRun$bulletinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyPayRun model
   */
  interface CompanyPayRunFieldRefs {
    readonly id: FieldRef<"CompanyPayRun", 'Int'>
    readonly reference: FieldRef<"CompanyPayRun", 'String'>
    readonly dateDebut: FieldRef<"CompanyPayRun", 'DateTime'>
    readonly dateFin: FieldRef<"CompanyPayRun", 'DateTime'>
    readonly datePaiement: FieldRef<"CompanyPayRun", 'DateTime'>
    readonly statut: FieldRef<"CompanyPayRun", 'CompanyStatutPayRun'>
    readonly totalBrut: FieldRef<"CompanyPayRun", 'Decimal'>
    readonly totalNet: FieldRef<"CompanyPayRun", 'Decimal'>
    readonly totalDeductions: FieldRef<"CompanyPayRun", 'Decimal'>
    readonly nombreEmployes: FieldRef<"CompanyPayRun", 'Int'>
    readonly metadata: FieldRef<"CompanyPayRun", 'Json'>
    readonly entrepriseId: FieldRef<"CompanyPayRun", 'Int'>
    readonly periodePaieId: FieldRef<"CompanyPayRun", 'Int'>
    readonly creePar: FieldRef<"CompanyPayRun", 'Int'>
    readonly creeLe: FieldRef<"CompanyPayRun", 'DateTime'>
    readonly approuveLe: FieldRef<"CompanyPayRun", 'DateTime'>
    readonly approuvePar: FieldRef<"CompanyPayRun", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CompanyPayRun findUnique
   */
  export type CompanyPayRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPayRun to fetch.
     */
    where: CompanyPayRunWhereUniqueInput
  }

  /**
   * CompanyPayRun findUniqueOrThrow
   */
  export type CompanyPayRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPayRun to fetch.
     */
    where: CompanyPayRunWhereUniqueInput
  }

  /**
   * CompanyPayRun findFirst
   */
  export type CompanyPayRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPayRun to fetch.
     */
    where?: CompanyPayRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPayRuns to fetch.
     */
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPayRuns.
     */
    cursor?: CompanyPayRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPayRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPayRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPayRuns.
     */
    distinct?: CompanyPayRunScalarFieldEnum | CompanyPayRunScalarFieldEnum[]
  }

  /**
   * CompanyPayRun findFirstOrThrow
   */
  export type CompanyPayRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPayRun to fetch.
     */
    where?: CompanyPayRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPayRuns to fetch.
     */
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPayRuns.
     */
    cursor?: CompanyPayRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPayRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPayRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPayRuns.
     */
    distinct?: CompanyPayRunScalarFieldEnum | CompanyPayRunScalarFieldEnum[]
  }

  /**
   * CompanyPayRun findMany
   */
  export type CompanyPayRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPayRuns to fetch.
     */
    where?: CompanyPayRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPayRuns to fetch.
     */
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyPayRuns.
     */
    cursor?: CompanyPayRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPayRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPayRuns.
     */
    skip?: number
    distinct?: CompanyPayRunScalarFieldEnum | CompanyPayRunScalarFieldEnum[]
  }

  /**
   * CompanyPayRun create
   */
  export type CompanyPayRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyPayRun.
     */
    data: XOR<CompanyPayRunCreateInput, CompanyPayRunUncheckedCreateInput>
  }

  /**
   * CompanyPayRun createMany
   */
  export type CompanyPayRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyPayRuns.
     */
    data: CompanyPayRunCreateManyInput | CompanyPayRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyPayRun update
   */
  export type CompanyPayRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyPayRun.
     */
    data: XOR<CompanyPayRunUpdateInput, CompanyPayRunUncheckedUpdateInput>
    /**
     * Choose, which CompanyPayRun to update.
     */
    where: CompanyPayRunWhereUniqueInput
  }

  /**
   * CompanyPayRun updateMany
   */
  export type CompanyPayRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyPayRuns.
     */
    data: XOR<CompanyPayRunUpdateManyMutationInput, CompanyPayRunUncheckedUpdateManyInput>
    /**
     * Filter which CompanyPayRuns to update
     */
    where?: CompanyPayRunWhereInput
    /**
     * Limit how many CompanyPayRuns to update.
     */
    limit?: number
  }

  /**
   * CompanyPayRun upsert
   */
  export type CompanyPayRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyPayRun to update in case it exists.
     */
    where: CompanyPayRunWhereUniqueInput
    /**
     * In case the CompanyPayRun found by the `where` argument doesn't exist, create a new CompanyPayRun with this data.
     */
    create: XOR<CompanyPayRunCreateInput, CompanyPayRunUncheckedCreateInput>
    /**
     * In case the CompanyPayRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyPayRunUpdateInput, CompanyPayRunUncheckedUpdateInput>
  }

  /**
   * CompanyPayRun delete
   */
  export type CompanyPayRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    /**
     * Filter which CompanyPayRun to delete.
     */
    where: CompanyPayRunWhereUniqueInput
  }

  /**
   * CompanyPayRun deleteMany
   */
  export type CompanyPayRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPayRuns to delete
     */
    where?: CompanyPayRunWhereInput
    /**
     * Limit how many CompanyPayRuns to delete.
     */
    limit?: number
  }

  /**
   * CompanyPayRun.approver
   */
  export type CompanyPayRun$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CompanyPayRun.bulletins
   */
  export type CompanyPayRun$bulletinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    where?: CompanyBulletinWhereInput
    orderBy?: CompanyBulletinOrderByWithRelationInput | CompanyBulletinOrderByWithRelationInput[]
    cursor?: CompanyBulletinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyBulletinScalarFieldEnum | CompanyBulletinScalarFieldEnum[]
  }

  /**
   * CompanyPayRun without action
   */
  export type CompanyPayRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
  }


  /**
   * Model CompanyBulletin
   */

  export type AggregateCompanyBulletin = {
    _count: CompanyBulletinCountAggregateOutputType | null
    _avg: CompanyBulletinAvgAggregateOutputType | null
    _sum: CompanyBulletinSumAggregateOutputType | null
    _min: CompanyBulletinMinAggregateOutputType | null
    _max: CompanyBulletinMaxAggregateOutputType | null
  }

  export type CompanyBulletinAvgAggregateOutputType = {
    id: number | null
    joursTravailles: number | null
    heuresTravailes: number | null
    salaireBrut: Decimal | null
    salaireBase: Decimal | null
    montantHeuresSupp: Decimal | null
    montantBonus: Decimal | null
    indemnites: Decimal | null
    totalDeductions: Decimal | null
    salaireNet: Decimal | null
    montantPaye: Decimal | null
    resteAPayer: Decimal | null
    payRunId: number | null
    employeId: number | null
  }

  export type CompanyBulletinSumAggregateOutputType = {
    id: number | null
    joursTravailles: number | null
    heuresTravailes: number | null
    salaireBrut: Decimal | null
    salaireBase: Decimal | null
    montantHeuresSupp: Decimal | null
    montantBonus: Decimal | null
    indemnites: Decimal | null
    totalDeductions: Decimal | null
    salaireNet: Decimal | null
    montantPaye: Decimal | null
    resteAPayer: Decimal | null
    payRunId: number | null
    employeId: number | null
  }

  export type CompanyBulletinMinAggregateOutputType = {
    id: number | null
    numeroBulletin: string | null
    datePaiement: Date | null
    joursTravailles: number | null
    heuresTravailes: number | null
    salaireBrut: Decimal | null
    salaireBase: Decimal | null
    montantHeuresSupp: Decimal | null
    montantBonus: Decimal | null
    indemnites: Decimal | null
    totalDeductions: Decimal | null
    salaireNet: Decimal | null
    montantPaye: Decimal | null
    resteAPayer: Decimal | null
    statutPaiement: string | null
    cheminPDF: string | null
    estVerrouille: boolean | null
    payRunId: number | null
    employeId: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyBulletinMaxAggregateOutputType = {
    id: number | null
    numeroBulletin: string | null
    datePaiement: Date | null
    joursTravailles: number | null
    heuresTravailes: number | null
    salaireBrut: Decimal | null
    salaireBase: Decimal | null
    montantHeuresSupp: Decimal | null
    montantBonus: Decimal | null
    indemnites: Decimal | null
    totalDeductions: Decimal | null
    salaireNet: Decimal | null
    montantPaye: Decimal | null
    resteAPayer: Decimal | null
    statutPaiement: string | null
    cheminPDF: string | null
    estVerrouille: boolean | null
    payRunId: number | null
    employeId: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyBulletinCountAggregateOutputType = {
    id: number
    numeroBulletin: number
    datePaiement: number
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: number
    salaireBase: number
    montantHeuresSupp: number
    montantBonus: number
    indemnites: number
    deductions: number
    totalDeductions: number
    salaireNet: number
    montantPaye: number
    resteAPayer: number
    statutPaiement: number
    cheminPDF: number
    calculs: number
    estVerrouille: number
    payRunId: number
    employeId: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type CompanyBulletinAvgAggregateInputType = {
    id?: true
    joursTravailles?: true
    heuresTravailes?: true
    salaireBrut?: true
    salaireBase?: true
    montantHeuresSupp?: true
    montantBonus?: true
    indemnites?: true
    totalDeductions?: true
    salaireNet?: true
    montantPaye?: true
    resteAPayer?: true
    payRunId?: true
    employeId?: true
  }

  export type CompanyBulletinSumAggregateInputType = {
    id?: true
    joursTravailles?: true
    heuresTravailes?: true
    salaireBrut?: true
    salaireBase?: true
    montantHeuresSupp?: true
    montantBonus?: true
    indemnites?: true
    totalDeductions?: true
    salaireNet?: true
    montantPaye?: true
    resteAPayer?: true
    payRunId?: true
    employeId?: true
  }

  export type CompanyBulletinMinAggregateInputType = {
    id?: true
    numeroBulletin?: true
    datePaiement?: true
    joursTravailles?: true
    heuresTravailes?: true
    salaireBrut?: true
    salaireBase?: true
    montantHeuresSupp?: true
    montantBonus?: true
    indemnites?: true
    totalDeductions?: true
    salaireNet?: true
    montantPaye?: true
    resteAPayer?: true
    statutPaiement?: true
    cheminPDF?: true
    estVerrouille?: true
    payRunId?: true
    employeId?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyBulletinMaxAggregateInputType = {
    id?: true
    numeroBulletin?: true
    datePaiement?: true
    joursTravailles?: true
    heuresTravailes?: true
    salaireBrut?: true
    salaireBase?: true
    montantHeuresSupp?: true
    montantBonus?: true
    indemnites?: true
    totalDeductions?: true
    salaireNet?: true
    montantPaye?: true
    resteAPayer?: true
    statutPaiement?: true
    cheminPDF?: true
    estVerrouille?: true
    payRunId?: true
    employeId?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyBulletinCountAggregateInputType = {
    id?: true
    numeroBulletin?: true
    datePaiement?: true
    joursTravailles?: true
    heuresTravailes?: true
    salaireBrut?: true
    salaireBase?: true
    montantHeuresSupp?: true
    montantBonus?: true
    indemnites?: true
    deductions?: true
    totalDeductions?: true
    salaireNet?: true
    montantPaye?: true
    resteAPayer?: true
    statutPaiement?: true
    cheminPDF?: true
    calculs?: true
    estVerrouille?: true
    payRunId?: true
    employeId?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyBulletinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBulletin to aggregate.
     */
    where?: CompanyBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBulletins to fetch.
     */
    orderBy?: CompanyBulletinOrderByWithRelationInput | CompanyBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBulletins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyBulletins
    **/
    _count?: true | CompanyBulletinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyBulletinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyBulletinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyBulletinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyBulletinMaxAggregateInputType
  }

  export type GetCompanyBulletinAggregateType<T extends CompanyBulletinAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyBulletin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyBulletin[P]>
      : GetScalarType<T[P], AggregateCompanyBulletin[P]>
  }




  export type CompanyBulletinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyBulletinWhereInput
    orderBy?: CompanyBulletinOrderByWithAggregationInput | CompanyBulletinOrderByWithAggregationInput[]
    by: CompanyBulletinScalarFieldEnum[] | CompanyBulletinScalarFieldEnum
    having?: CompanyBulletinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyBulletinCountAggregateInputType | true
    _avg?: CompanyBulletinAvgAggregateInputType
    _sum?: CompanyBulletinSumAggregateInputType
    _min?: CompanyBulletinMinAggregateInputType
    _max?: CompanyBulletinMaxAggregateInputType
  }

  export type CompanyBulletinGroupByOutputType = {
    id: number
    numeroBulletin: string
    datePaiement: Date
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal
    salaireBase: Decimal
    montantHeuresSupp: Decimal
    montantBonus: Decimal
    indemnites: Decimal
    deductions: JsonValue
    totalDeductions: Decimal
    salaireNet: Decimal
    montantPaye: Decimal
    resteAPayer: Decimal
    statutPaiement: string
    cheminPDF: string | null
    calculs: JsonValue | null
    estVerrouille: boolean
    payRunId: number
    employeId: number
    creeLe: Date
    modifieLe: Date
    _count: CompanyBulletinCountAggregateOutputType | null
    _avg: CompanyBulletinAvgAggregateOutputType | null
    _sum: CompanyBulletinSumAggregateOutputType | null
    _min: CompanyBulletinMinAggregateOutputType | null
    _max: CompanyBulletinMaxAggregateOutputType | null
  }

  type GetCompanyBulletinGroupByPayload<T extends CompanyBulletinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyBulletinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyBulletinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyBulletinGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyBulletinGroupByOutputType[P]>
        }
      >
    >


  export type CompanyBulletinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroBulletin?: boolean
    datePaiement?: boolean
    joursTravailles?: boolean
    heuresTravailes?: boolean
    salaireBrut?: boolean
    salaireBase?: boolean
    montantHeuresSupp?: boolean
    montantBonus?: boolean
    indemnites?: boolean
    deductions?: boolean
    totalDeductions?: boolean
    salaireNet?: boolean
    montantPaye?: boolean
    resteAPayer?: boolean
    statutPaiement?: boolean
    cheminPDF?: boolean
    calculs?: boolean
    estVerrouille?: boolean
    payRunId?: boolean
    employeId?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    payRun?: boolean | CompanyPayRunDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    paiements?: boolean | CompanyBulletin$paiementsArgs<ExtArgs>
    _count?: boolean | CompanyBulletinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyBulletin"]>



  export type CompanyBulletinSelectScalar = {
    id?: boolean
    numeroBulletin?: boolean
    datePaiement?: boolean
    joursTravailles?: boolean
    heuresTravailes?: boolean
    salaireBrut?: boolean
    salaireBase?: boolean
    montantHeuresSupp?: boolean
    montantBonus?: boolean
    indemnites?: boolean
    deductions?: boolean
    totalDeductions?: boolean
    salaireNet?: boolean
    montantPaye?: boolean
    resteAPayer?: boolean
    statutPaiement?: boolean
    cheminPDF?: boolean
    calculs?: boolean
    estVerrouille?: boolean
    payRunId?: boolean
    employeId?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type CompanyBulletinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroBulletin" | "datePaiement" | "joursTravailles" | "heuresTravailes" | "salaireBrut" | "salaireBase" | "montantHeuresSupp" | "montantBonus" | "indemnites" | "deductions" | "totalDeductions" | "salaireNet" | "montantPaye" | "resteAPayer" | "statutPaiement" | "cheminPDF" | "calculs" | "estVerrouille" | "payRunId" | "employeId" | "creeLe" | "modifieLe", ExtArgs["result"]["companyBulletin"]>
  export type CompanyBulletinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payRun?: boolean | CompanyPayRunDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    paiements?: boolean | CompanyBulletin$paiementsArgs<ExtArgs>
    _count?: boolean | CompanyBulletinCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyBulletinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyBulletin"
    objects: {
      payRun: Prisma.$CompanyPayRunPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      paiements: Prisma.$CompanyPaiementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numeroBulletin: string
      datePaiement: Date
      joursTravailles: number
      heuresTravailes: number
      salaireBrut: Prisma.Decimal
      salaireBase: Prisma.Decimal
      montantHeuresSupp: Prisma.Decimal
      montantBonus: Prisma.Decimal
      indemnites: Prisma.Decimal
      deductions: Prisma.JsonValue
      totalDeductions: Prisma.Decimal
      salaireNet: Prisma.Decimal
      montantPaye: Prisma.Decimal
      resteAPayer: Prisma.Decimal
      statutPaiement: string
      cheminPDF: string | null
      calculs: Prisma.JsonValue | null
      estVerrouille: boolean
      payRunId: number
      employeId: number
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["companyBulletin"]>
    composites: {}
  }

  type CompanyBulletinGetPayload<S extends boolean | null | undefined | CompanyBulletinDefaultArgs> = $Result.GetResult<Prisma.$CompanyBulletinPayload, S>

  type CompanyBulletinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyBulletinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyBulletinCountAggregateInputType | true
    }

  export interface CompanyBulletinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyBulletin'], meta: { name: 'CompanyBulletin' } }
    /**
     * Find zero or one CompanyBulletin that matches the filter.
     * @param {CompanyBulletinFindUniqueArgs} args - Arguments to find a CompanyBulletin
     * @example
     * // Get one CompanyBulletin
     * const companyBulletin = await prisma.companyBulletin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyBulletinFindUniqueArgs>(args: SelectSubset<T, CompanyBulletinFindUniqueArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyBulletin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyBulletinFindUniqueOrThrowArgs} args - Arguments to find a CompanyBulletin
     * @example
     * // Get one CompanyBulletin
     * const companyBulletin = await prisma.companyBulletin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyBulletinFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyBulletinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyBulletin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBulletinFindFirstArgs} args - Arguments to find a CompanyBulletin
     * @example
     * // Get one CompanyBulletin
     * const companyBulletin = await prisma.companyBulletin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyBulletinFindFirstArgs>(args?: SelectSubset<T, CompanyBulletinFindFirstArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyBulletin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBulletinFindFirstOrThrowArgs} args - Arguments to find a CompanyBulletin
     * @example
     * // Get one CompanyBulletin
     * const companyBulletin = await prisma.companyBulletin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyBulletinFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyBulletinFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyBulletins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBulletinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyBulletins
     * const companyBulletins = await prisma.companyBulletin.findMany()
     * 
     * // Get first 10 CompanyBulletins
     * const companyBulletins = await prisma.companyBulletin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyBulletinWithIdOnly = await prisma.companyBulletin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyBulletinFindManyArgs>(args?: SelectSubset<T, CompanyBulletinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyBulletin.
     * @param {CompanyBulletinCreateArgs} args - Arguments to create a CompanyBulletin.
     * @example
     * // Create one CompanyBulletin
     * const CompanyBulletin = await prisma.companyBulletin.create({
     *   data: {
     *     // ... data to create a CompanyBulletin
     *   }
     * })
     * 
     */
    create<T extends CompanyBulletinCreateArgs>(args: SelectSubset<T, CompanyBulletinCreateArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyBulletins.
     * @param {CompanyBulletinCreateManyArgs} args - Arguments to create many CompanyBulletins.
     * @example
     * // Create many CompanyBulletins
     * const companyBulletin = await prisma.companyBulletin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyBulletinCreateManyArgs>(args?: SelectSubset<T, CompanyBulletinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyBulletin.
     * @param {CompanyBulletinDeleteArgs} args - Arguments to delete one CompanyBulletin.
     * @example
     * // Delete one CompanyBulletin
     * const CompanyBulletin = await prisma.companyBulletin.delete({
     *   where: {
     *     // ... filter to delete one CompanyBulletin
     *   }
     * })
     * 
     */
    delete<T extends CompanyBulletinDeleteArgs>(args: SelectSubset<T, CompanyBulletinDeleteArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyBulletin.
     * @param {CompanyBulletinUpdateArgs} args - Arguments to update one CompanyBulletin.
     * @example
     * // Update one CompanyBulletin
     * const companyBulletin = await prisma.companyBulletin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyBulletinUpdateArgs>(args: SelectSubset<T, CompanyBulletinUpdateArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyBulletins.
     * @param {CompanyBulletinDeleteManyArgs} args - Arguments to filter CompanyBulletins to delete.
     * @example
     * // Delete a few CompanyBulletins
     * const { count } = await prisma.companyBulletin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyBulletinDeleteManyArgs>(args?: SelectSubset<T, CompanyBulletinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyBulletins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBulletinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyBulletins
     * const companyBulletin = await prisma.companyBulletin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyBulletinUpdateManyArgs>(args: SelectSubset<T, CompanyBulletinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyBulletin.
     * @param {CompanyBulletinUpsertArgs} args - Arguments to update or create a CompanyBulletin.
     * @example
     * // Update or create a CompanyBulletin
     * const companyBulletin = await prisma.companyBulletin.upsert({
     *   create: {
     *     // ... data to create a CompanyBulletin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyBulletin we want to update
     *   }
     * })
     */
    upsert<T extends CompanyBulletinUpsertArgs>(args: SelectSubset<T, CompanyBulletinUpsertArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyBulletins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBulletinCountArgs} args - Arguments to filter CompanyBulletins to count.
     * @example
     * // Count the number of CompanyBulletins
     * const count = await prisma.companyBulletin.count({
     *   where: {
     *     // ... the filter for the CompanyBulletins we want to count
     *   }
     * })
    **/
    count<T extends CompanyBulletinCountArgs>(
      args?: Subset<T, CompanyBulletinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyBulletinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyBulletin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBulletinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyBulletinAggregateArgs>(args: Subset<T, CompanyBulletinAggregateArgs>): Prisma.PrismaPromise<GetCompanyBulletinAggregateType<T>>

    /**
     * Group by CompanyBulletin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyBulletinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyBulletinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyBulletinGroupByArgs['orderBy'] }
        : { orderBy?: CompanyBulletinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyBulletinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyBulletinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyBulletin model
   */
  readonly fields: CompanyBulletinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyBulletin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyBulletinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payRun<T extends CompanyPayRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyPayRunDefaultArgs<ExtArgs>>): Prisma__CompanyPayRunClient<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paiements<T extends CompanyBulletin$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, CompanyBulletin$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyBulletin model
   */
  interface CompanyBulletinFieldRefs {
    readonly id: FieldRef<"CompanyBulletin", 'Int'>
    readonly numeroBulletin: FieldRef<"CompanyBulletin", 'String'>
    readonly datePaiement: FieldRef<"CompanyBulletin", 'DateTime'>
    readonly joursTravailles: FieldRef<"CompanyBulletin", 'Int'>
    readonly heuresTravailes: FieldRef<"CompanyBulletin", 'Int'>
    readonly salaireBrut: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly salaireBase: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly montantHeuresSupp: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly montantBonus: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly indemnites: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly deductions: FieldRef<"CompanyBulletin", 'Json'>
    readonly totalDeductions: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly salaireNet: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly montantPaye: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly resteAPayer: FieldRef<"CompanyBulletin", 'Decimal'>
    readonly statutPaiement: FieldRef<"CompanyBulletin", 'String'>
    readonly cheminPDF: FieldRef<"CompanyBulletin", 'String'>
    readonly calculs: FieldRef<"CompanyBulletin", 'Json'>
    readonly estVerrouille: FieldRef<"CompanyBulletin", 'Boolean'>
    readonly payRunId: FieldRef<"CompanyBulletin", 'Int'>
    readonly employeId: FieldRef<"CompanyBulletin", 'Int'>
    readonly creeLe: FieldRef<"CompanyBulletin", 'DateTime'>
    readonly modifieLe: FieldRef<"CompanyBulletin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyBulletin findUnique
   */
  export type CompanyBulletinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBulletin to fetch.
     */
    where: CompanyBulletinWhereUniqueInput
  }

  /**
   * CompanyBulletin findUniqueOrThrow
   */
  export type CompanyBulletinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBulletin to fetch.
     */
    where: CompanyBulletinWhereUniqueInput
  }

  /**
   * CompanyBulletin findFirst
   */
  export type CompanyBulletinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBulletin to fetch.
     */
    where?: CompanyBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBulletins to fetch.
     */
    orderBy?: CompanyBulletinOrderByWithRelationInput | CompanyBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBulletins.
     */
    cursor?: CompanyBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBulletins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBulletins.
     */
    distinct?: CompanyBulletinScalarFieldEnum | CompanyBulletinScalarFieldEnum[]
  }

  /**
   * CompanyBulletin findFirstOrThrow
   */
  export type CompanyBulletinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBulletin to fetch.
     */
    where?: CompanyBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBulletins to fetch.
     */
    orderBy?: CompanyBulletinOrderByWithRelationInput | CompanyBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyBulletins.
     */
    cursor?: CompanyBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBulletins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyBulletins.
     */
    distinct?: CompanyBulletinScalarFieldEnum | CompanyBulletinScalarFieldEnum[]
  }

  /**
   * CompanyBulletin findMany
   */
  export type CompanyBulletinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * Filter, which CompanyBulletins to fetch.
     */
    where?: CompanyBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyBulletins to fetch.
     */
    orderBy?: CompanyBulletinOrderByWithRelationInput | CompanyBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyBulletins.
     */
    cursor?: CompanyBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyBulletins.
     */
    skip?: number
    distinct?: CompanyBulletinScalarFieldEnum | CompanyBulletinScalarFieldEnum[]
  }

  /**
   * CompanyBulletin create
   */
  export type CompanyBulletinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyBulletin.
     */
    data: XOR<CompanyBulletinCreateInput, CompanyBulletinUncheckedCreateInput>
  }

  /**
   * CompanyBulletin createMany
   */
  export type CompanyBulletinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyBulletins.
     */
    data: CompanyBulletinCreateManyInput | CompanyBulletinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyBulletin update
   */
  export type CompanyBulletinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyBulletin.
     */
    data: XOR<CompanyBulletinUpdateInput, CompanyBulletinUncheckedUpdateInput>
    /**
     * Choose, which CompanyBulletin to update.
     */
    where: CompanyBulletinWhereUniqueInput
  }

  /**
   * CompanyBulletin updateMany
   */
  export type CompanyBulletinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyBulletins.
     */
    data: XOR<CompanyBulletinUpdateManyMutationInput, CompanyBulletinUncheckedUpdateManyInput>
    /**
     * Filter which CompanyBulletins to update
     */
    where?: CompanyBulletinWhereInput
    /**
     * Limit how many CompanyBulletins to update.
     */
    limit?: number
  }

  /**
   * CompanyBulletin upsert
   */
  export type CompanyBulletinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyBulletin to update in case it exists.
     */
    where: CompanyBulletinWhereUniqueInput
    /**
     * In case the CompanyBulletin found by the `where` argument doesn't exist, create a new CompanyBulletin with this data.
     */
    create: XOR<CompanyBulletinCreateInput, CompanyBulletinUncheckedCreateInput>
    /**
     * In case the CompanyBulletin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyBulletinUpdateInput, CompanyBulletinUncheckedUpdateInput>
  }

  /**
   * CompanyBulletin delete
   */
  export type CompanyBulletinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
    /**
     * Filter which CompanyBulletin to delete.
     */
    where: CompanyBulletinWhereUniqueInput
  }

  /**
   * CompanyBulletin deleteMany
   */
  export type CompanyBulletinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyBulletins to delete
     */
    where?: CompanyBulletinWhereInput
    /**
     * Limit how many CompanyBulletins to delete.
     */
    limit?: number
  }

  /**
   * CompanyBulletin.paiements
   */
  export type CompanyBulletin$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    where?: CompanyPaiementWhereInput
    orderBy?: CompanyPaiementOrderByWithRelationInput | CompanyPaiementOrderByWithRelationInput[]
    cursor?: CompanyPaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPaiementScalarFieldEnum | CompanyPaiementScalarFieldEnum[]
  }

  /**
   * CompanyBulletin without action
   */
  export type CompanyBulletinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyBulletin
     */
    select?: CompanyBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyBulletin
     */
    omit?: CompanyBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyBulletinInclude<ExtArgs> | null
  }


  /**
   * Model CompanyPaiement
   */

  export type AggregateCompanyPaiement = {
    _count: CompanyPaiementCountAggregateOutputType | null
    _avg: CompanyPaiementAvgAggregateOutputType | null
    _sum: CompanyPaiementSumAggregateOutputType | null
    _min: CompanyPaiementMinAggregateOutputType | null
    _max: CompanyPaiementMaxAggregateOutputType | null
  }

  export type CompanyPaiementAvgAggregateOutputType = {
    id: number | null
    montant: Decimal | null
    bulletinId: number | null
    traitePar: number | null
  }

  export type CompanyPaiementSumAggregateOutputType = {
    id: number | null
    montant: Decimal | null
    bulletinId: number | null
    traitePar: number | null
  }

  export type CompanyPaiementMinAggregateOutputType = {
    id: number | null
    referenceTransaction: string | null
    montant: Decimal | null
    methodePaiement: string | null
    referencePaiement: string | null
    datePaiement: Date | null
    notes: string | null
    cheminRecu: string | null
    statut: string | null
    bulletinId: number | null
    traitePar: number | null
    creeLe: Date | null
  }

  export type CompanyPaiementMaxAggregateOutputType = {
    id: number | null
    referenceTransaction: string | null
    montant: Decimal | null
    methodePaiement: string | null
    referencePaiement: string | null
    datePaiement: Date | null
    notes: string | null
    cheminRecu: string | null
    statut: string | null
    bulletinId: number | null
    traitePar: number | null
    creeLe: Date | null
  }

  export type CompanyPaiementCountAggregateOutputType = {
    id: number
    referenceTransaction: number
    montant: number
    methodePaiement: number
    referencePaiement: number
    datePaiement: number
    notes: number
    cheminRecu: number
    statut: number
    metadata: number
    bulletinId: number
    traitePar: number
    creeLe: number
    _all: number
  }


  export type CompanyPaiementAvgAggregateInputType = {
    id?: true
    montant?: true
    bulletinId?: true
    traitePar?: true
  }

  export type CompanyPaiementSumAggregateInputType = {
    id?: true
    montant?: true
    bulletinId?: true
    traitePar?: true
  }

  export type CompanyPaiementMinAggregateInputType = {
    id?: true
    referenceTransaction?: true
    montant?: true
    methodePaiement?: true
    referencePaiement?: true
    datePaiement?: true
    notes?: true
    cheminRecu?: true
    statut?: true
    bulletinId?: true
    traitePar?: true
    creeLe?: true
  }

  export type CompanyPaiementMaxAggregateInputType = {
    id?: true
    referenceTransaction?: true
    montant?: true
    methodePaiement?: true
    referencePaiement?: true
    datePaiement?: true
    notes?: true
    cheminRecu?: true
    statut?: true
    bulletinId?: true
    traitePar?: true
    creeLe?: true
  }

  export type CompanyPaiementCountAggregateInputType = {
    id?: true
    referenceTransaction?: true
    montant?: true
    methodePaiement?: true
    referencePaiement?: true
    datePaiement?: true
    notes?: true
    cheminRecu?: true
    statut?: true
    metadata?: true
    bulletinId?: true
    traitePar?: true
    creeLe?: true
    _all?: true
  }

  export type CompanyPaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPaiement to aggregate.
     */
    where?: CompanyPaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPaiements to fetch.
     */
    orderBy?: CompanyPaiementOrderByWithRelationInput | CompanyPaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyPaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPaiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyPaiements
    **/
    _count?: true | CompanyPaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyPaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyPaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyPaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyPaiementMaxAggregateInputType
  }

  export type GetCompanyPaiementAggregateType<T extends CompanyPaiementAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyPaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyPaiement[P]>
      : GetScalarType<T[P], AggregateCompanyPaiement[P]>
  }




  export type CompanyPaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPaiementWhereInput
    orderBy?: CompanyPaiementOrderByWithAggregationInput | CompanyPaiementOrderByWithAggregationInput[]
    by: CompanyPaiementScalarFieldEnum[] | CompanyPaiementScalarFieldEnum
    having?: CompanyPaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyPaiementCountAggregateInputType | true
    _avg?: CompanyPaiementAvgAggregateInputType
    _sum?: CompanyPaiementSumAggregateInputType
    _min?: CompanyPaiementMinAggregateInputType
    _max?: CompanyPaiementMaxAggregateInputType
  }

  export type CompanyPaiementGroupByOutputType = {
    id: number
    referenceTransaction: string
    montant: Decimal
    methodePaiement: string
    referencePaiement: string | null
    datePaiement: Date
    notes: string | null
    cheminRecu: string | null
    statut: string
    metadata: JsonValue | null
    bulletinId: number
    traitePar: number
    creeLe: Date
    _count: CompanyPaiementCountAggregateOutputType | null
    _avg: CompanyPaiementAvgAggregateOutputType | null
    _sum: CompanyPaiementSumAggregateOutputType | null
    _min: CompanyPaiementMinAggregateOutputType | null
    _max: CompanyPaiementMaxAggregateOutputType | null
  }

  type GetCompanyPaiementGroupByPayload<T extends CompanyPaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyPaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyPaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyPaiementGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyPaiementGroupByOutputType[P]>
        }
      >
    >


  export type CompanyPaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceTransaction?: boolean
    montant?: boolean
    methodePaiement?: boolean
    referencePaiement?: boolean
    datePaiement?: boolean
    notes?: boolean
    cheminRecu?: boolean
    statut?: boolean
    metadata?: boolean
    bulletinId?: boolean
    traitePar?: boolean
    creeLe?: boolean
    bulletin?: boolean | CompanyBulletinDefaultArgs<ExtArgs>
    processor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyPaiement"]>



  export type CompanyPaiementSelectScalar = {
    id?: boolean
    referenceTransaction?: boolean
    montant?: boolean
    methodePaiement?: boolean
    referencePaiement?: boolean
    datePaiement?: boolean
    notes?: boolean
    cheminRecu?: boolean
    statut?: boolean
    metadata?: boolean
    bulletinId?: boolean
    traitePar?: boolean
    creeLe?: boolean
  }

  export type CompanyPaiementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceTransaction" | "montant" | "methodePaiement" | "referencePaiement" | "datePaiement" | "notes" | "cheminRecu" | "statut" | "metadata" | "bulletinId" | "traitePar" | "creeLe", ExtArgs["result"]["companyPaiement"]>
  export type CompanyPaiementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bulletin?: boolean | CompanyBulletinDefaultArgs<ExtArgs>
    processor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyPaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyPaiement"
    objects: {
      bulletin: Prisma.$CompanyBulletinPayload<ExtArgs>
      processor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      referenceTransaction: string
      montant: Prisma.Decimal
      methodePaiement: string
      referencePaiement: string | null
      datePaiement: Date
      notes: string | null
      cheminRecu: string | null
      statut: string
      metadata: Prisma.JsonValue | null
      bulletinId: number
      traitePar: number
      creeLe: Date
    }, ExtArgs["result"]["companyPaiement"]>
    composites: {}
  }

  type CompanyPaiementGetPayload<S extends boolean | null | undefined | CompanyPaiementDefaultArgs> = $Result.GetResult<Prisma.$CompanyPaiementPayload, S>

  type CompanyPaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyPaiementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyPaiementCountAggregateInputType | true
    }

  export interface CompanyPaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyPaiement'], meta: { name: 'CompanyPaiement' } }
    /**
     * Find zero or one CompanyPaiement that matches the filter.
     * @param {CompanyPaiementFindUniqueArgs} args - Arguments to find a CompanyPaiement
     * @example
     * // Get one CompanyPaiement
     * const companyPaiement = await prisma.companyPaiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyPaiementFindUniqueArgs>(args: SelectSubset<T, CompanyPaiementFindUniqueArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyPaiement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyPaiementFindUniqueOrThrowArgs} args - Arguments to find a CompanyPaiement
     * @example
     * // Get one CompanyPaiement
     * const companyPaiement = await prisma.companyPaiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyPaiementFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyPaiementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyPaiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPaiementFindFirstArgs} args - Arguments to find a CompanyPaiement
     * @example
     * // Get one CompanyPaiement
     * const companyPaiement = await prisma.companyPaiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyPaiementFindFirstArgs>(args?: SelectSubset<T, CompanyPaiementFindFirstArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyPaiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPaiementFindFirstOrThrowArgs} args - Arguments to find a CompanyPaiement
     * @example
     * // Get one CompanyPaiement
     * const companyPaiement = await prisma.companyPaiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyPaiementFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyPaiementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyPaiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPaiementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyPaiements
     * const companyPaiements = await prisma.companyPaiement.findMany()
     * 
     * // Get first 10 CompanyPaiements
     * const companyPaiements = await prisma.companyPaiement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyPaiementWithIdOnly = await prisma.companyPaiement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyPaiementFindManyArgs>(args?: SelectSubset<T, CompanyPaiementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyPaiement.
     * @param {CompanyPaiementCreateArgs} args - Arguments to create a CompanyPaiement.
     * @example
     * // Create one CompanyPaiement
     * const CompanyPaiement = await prisma.companyPaiement.create({
     *   data: {
     *     // ... data to create a CompanyPaiement
     *   }
     * })
     * 
     */
    create<T extends CompanyPaiementCreateArgs>(args: SelectSubset<T, CompanyPaiementCreateArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyPaiements.
     * @param {CompanyPaiementCreateManyArgs} args - Arguments to create many CompanyPaiements.
     * @example
     * // Create many CompanyPaiements
     * const companyPaiement = await prisma.companyPaiement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyPaiementCreateManyArgs>(args?: SelectSubset<T, CompanyPaiementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyPaiement.
     * @param {CompanyPaiementDeleteArgs} args - Arguments to delete one CompanyPaiement.
     * @example
     * // Delete one CompanyPaiement
     * const CompanyPaiement = await prisma.companyPaiement.delete({
     *   where: {
     *     // ... filter to delete one CompanyPaiement
     *   }
     * })
     * 
     */
    delete<T extends CompanyPaiementDeleteArgs>(args: SelectSubset<T, CompanyPaiementDeleteArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyPaiement.
     * @param {CompanyPaiementUpdateArgs} args - Arguments to update one CompanyPaiement.
     * @example
     * // Update one CompanyPaiement
     * const companyPaiement = await prisma.companyPaiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyPaiementUpdateArgs>(args: SelectSubset<T, CompanyPaiementUpdateArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyPaiements.
     * @param {CompanyPaiementDeleteManyArgs} args - Arguments to filter CompanyPaiements to delete.
     * @example
     * // Delete a few CompanyPaiements
     * const { count } = await prisma.companyPaiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyPaiementDeleteManyArgs>(args?: SelectSubset<T, CompanyPaiementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyPaiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyPaiements
     * const companyPaiement = await prisma.companyPaiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyPaiementUpdateManyArgs>(args: SelectSubset<T, CompanyPaiementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyPaiement.
     * @param {CompanyPaiementUpsertArgs} args - Arguments to update or create a CompanyPaiement.
     * @example
     * // Update or create a CompanyPaiement
     * const companyPaiement = await prisma.companyPaiement.upsert({
     *   create: {
     *     // ... data to create a CompanyPaiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyPaiement we want to update
     *   }
     * })
     */
    upsert<T extends CompanyPaiementUpsertArgs>(args: SelectSubset<T, CompanyPaiementUpsertArgs<ExtArgs>>): Prisma__CompanyPaiementClient<$Result.GetResult<Prisma.$CompanyPaiementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyPaiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPaiementCountArgs} args - Arguments to filter CompanyPaiements to count.
     * @example
     * // Count the number of CompanyPaiements
     * const count = await prisma.companyPaiement.count({
     *   where: {
     *     // ... the filter for the CompanyPaiements we want to count
     *   }
     * })
    **/
    count<T extends CompanyPaiementCountArgs>(
      args?: Subset<T, CompanyPaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyPaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyPaiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyPaiementAggregateArgs>(args: Subset<T, CompanyPaiementAggregateArgs>): Prisma.PrismaPromise<GetCompanyPaiementAggregateType<T>>

    /**
     * Group by CompanyPaiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyPaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyPaiementGroupByArgs['orderBy'] }
        : { orderBy?: CompanyPaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyPaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyPaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyPaiement model
   */
  readonly fields: CompanyPaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyPaiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyPaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bulletin<T extends CompanyBulletinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyBulletinDefaultArgs<ExtArgs>>): Prisma__CompanyBulletinClient<$Result.GetResult<Prisma.$CompanyBulletinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    processor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyPaiement model
   */
  interface CompanyPaiementFieldRefs {
    readonly id: FieldRef<"CompanyPaiement", 'Int'>
    readonly referenceTransaction: FieldRef<"CompanyPaiement", 'String'>
    readonly montant: FieldRef<"CompanyPaiement", 'Decimal'>
    readonly methodePaiement: FieldRef<"CompanyPaiement", 'String'>
    readonly referencePaiement: FieldRef<"CompanyPaiement", 'String'>
    readonly datePaiement: FieldRef<"CompanyPaiement", 'DateTime'>
    readonly notes: FieldRef<"CompanyPaiement", 'String'>
    readonly cheminRecu: FieldRef<"CompanyPaiement", 'String'>
    readonly statut: FieldRef<"CompanyPaiement", 'String'>
    readonly metadata: FieldRef<"CompanyPaiement", 'Json'>
    readonly bulletinId: FieldRef<"CompanyPaiement", 'Int'>
    readonly traitePar: FieldRef<"CompanyPaiement", 'Int'>
    readonly creeLe: FieldRef<"CompanyPaiement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyPaiement findUnique
   */
  export type CompanyPaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPaiement to fetch.
     */
    where: CompanyPaiementWhereUniqueInput
  }

  /**
   * CompanyPaiement findUniqueOrThrow
   */
  export type CompanyPaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPaiement to fetch.
     */
    where: CompanyPaiementWhereUniqueInput
  }

  /**
   * CompanyPaiement findFirst
   */
  export type CompanyPaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPaiement to fetch.
     */
    where?: CompanyPaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPaiements to fetch.
     */
    orderBy?: CompanyPaiementOrderByWithRelationInput | CompanyPaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPaiements.
     */
    cursor?: CompanyPaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPaiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPaiements.
     */
    distinct?: CompanyPaiementScalarFieldEnum | CompanyPaiementScalarFieldEnum[]
  }

  /**
   * CompanyPaiement findFirstOrThrow
   */
  export type CompanyPaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPaiement to fetch.
     */
    where?: CompanyPaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPaiements to fetch.
     */
    orderBy?: CompanyPaiementOrderByWithRelationInput | CompanyPaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPaiements.
     */
    cursor?: CompanyPaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPaiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPaiements.
     */
    distinct?: CompanyPaiementScalarFieldEnum | CompanyPaiementScalarFieldEnum[]
  }

  /**
   * CompanyPaiement findMany
   */
  export type CompanyPaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPaiements to fetch.
     */
    where?: CompanyPaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPaiements to fetch.
     */
    orderBy?: CompanyPaiementOrderByWithRelationInput | CompanyPaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyPaiements.
     */
    cursor?: CompanyPaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPaiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPaiements.
     */
    skip?: number
    distinct?: CompanyPaiementScalarFieldEnum | CompanyPaiementScalarFieldEnum[]
  }

  /**
   * CompanyPaiement create
   */
  export type CompanyPaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyPaiement.
     */
    data: XOR<CompanyPaiementCreateInput, CompanyPaiementUncheckedCreateInput>
  }

  /**
   * CompanyPaiement createMany
   */
  export type CompanyPaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyPaiements.
     */
    data: CompanyPaiementCreateManyInput | CompanyPaiementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyPaiement update
   */
  export type CompanyPaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyPaiement.
     */
    data: XOR<CompanyPaiementUpdateInput, CompanyPaiementUncheckedUpdateInput>
    /**
     * Choose, which CompanyPaiement to update.
     */
    where: CompanyPaiementWhereUniqueInput
  }

  /**
   * CompanyPaiement updateMany
   */
  export type CompanyPaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyPaiements.
     */
    data: XOR<CompanyPaiementUpdateManyMutationInput, CompanyPaiementUncheckedUpdateManyInput>
    /**
     * Filter which CompanyPaiements to update
     */
    where?: CompanyPaiementWhereInput
    /**
     * Limit how many CompanyPaiements to update.
     */
    limit?: number
  }

  /**
   * CompanyPaiement upsert
   */
  export type CompanyPaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyPaiement to update in case it exists.
     */
    where: CompanyPaiementWhereUniqueInput
    /**
     * In case the CompanyPaiement found by the `where` argument doesn't exist, create a new CompanyPaiement with this data.
     */
    create: XOR<CompanyPaiementCreateInput, CompanyPaiementUncheckedCreateInput>
    /**
     * In case the CompanyPaiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyPaiementUpdateInput, CompanyPaiementUncheckedUpdateInput>
  }

  /**
   * CompanyPaiement delete
   */
  export type CompanyPaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
    /**
     * Filter which CompanyPaiement to delete.
     */
    where: CompanyPaiementWhereUniqueInput
  }

  /**
   * CompanyPaiement deleteMany
   */
  export type CompanyPaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPaiements to delete
     */
    where?: CompanyPaiementWhereInput
    /**
     * Limit how many CompanyPaiements to delete.
     */
    limit?: number
  }

  /**
   * CompanyPaiement without action
   */
  export type CompanyPaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPaiement
     */
    select?: CompanyPaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPaiement
     */
    omit?: CompanyPaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPaiementInclude<ExtArgs> | null
  }


  /**
   * Model CompanyTemplate
   */

  export type AggregateCompanyTemplate = {
    _count: CompanyTemplateCountAggregateOutputType | null
    _avg: CompanyTemplateAvgAggregateOutputType | null
    _sum: CompanyTemplateSumAggregateOutputType | null
    _min: CompanyTemplateMinAggregateOutputType | null
    _max: CompanyTemplateMaxAggregateOutputType | null
  }

  export type CompanyTemplateAvgAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
  }

  export type CompanyTemplateSumAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
  }

  export type CompanyTemplateMinAggregateOutputType = {
    id: number | null
    typeTemplate: string | null
    nom: string | null
    contenu: string | null
    estDefaut: boolean | null
    estActif: boolean | null
    entrepriseId: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyTemplateMaxAggregateOutputType = {
    id: number | null
    typeTemplate: string | null
    nom: string | null
    contenu: string | null
    estDefaut: boolean | null
    estActif: boolean | null
    entrepriseId: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyTemplateCountAggregateOutputType = {
    id: number
    typeTemplate: number
    nom: number
    contenu: number
    variables: number
    estDefaut: number
    estActif: number
    entrepriseId: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type CompanyTemplateAvgAggregateInputType = {
    id?: true
    entrepriseId?: true
  }

  export type CompanyTemplateSumAggregateInputType = {
    id?: true
    entrepriseId?: true
  }

  export type CompanyTemplateMinAggregateInputType = {
    id?: true
    typeTemplate?: true
    nom?: true
    contenu?: true
    estDefaut?: true
    estActif?: true
    entrepriseId?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyTemplateMaxAggregateInputType = {
    id?: true
    typeTemplate?: true
    nom?: true
    contenu?: true
    estDefaut?: true
    estActif?: true
    entrepriseId?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyTemplateCountAggregateInputType = {
    id?: true
    typeTemplate?: true
    nom?: true
    contenu?: true
    variables?: true
    estDefaut?: true
    estActif?: true
    entrepriseId?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyTemplate to aggregate.
     */
    where?: CompanyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTemplates to fetch.
     */
    orderBy?: CompanyTemplateOrderByWithRelationInput | CompanyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyTemplates
    **/
    _count?: true | CompanyTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyTemplateMaxAggregateInputType
  }

  export type GetCompanyTemplateAggregateType<T extends CompanyTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyTemplate[P]>
      : GetScalarType<T[P], AggregateCompanyTemplate[P]>
  }




  export type CompanyTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyTemplateWhereInput
    orderBy?: CompanyTemplateOrderByWithAggregationInput | CompanyTemplateOrderByWithAggregationInput[]
    by: CompanyTemplateScalarFieldEnum[] | CompanyTemplateScalarFieldEnum
    having?: CompanyTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyTemplateCountAggregateInputType | true
    _avg?: CompanyTemplateAvgAggregateInputType
    _sum?: CompanyTemplateSumAggregateInputType
    _min?: CompanyTemplateMinAggregateInputType
    _max?: CompanyTemplateMaxAggregateInputType
  }

  export type CompanyTemplateGroupByOutputType = {
    id: number
    typeTemplate: string
    nom: string
    contenu: string
    variables: JsonValue
    estDefaut: boolean
    estActif: boolean
    entrepriseId: number
    creeLe: Date
    modifieLe: Date
    _count: CompanyTemplateCountAggregateOutputType | null
    _avg: CompanyTemplateAvgAggregateOutputType | null
    _sum: CompanyTemplateSumAggregateOutputType | null
    _min: CompanyTemplateMinAggregateOutputType | null
    _max: CompanyTemplateMaxAggregateOutputType | null
  }

  type GetCompanyTemplateGroupByPayload<T extends CompanyTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyTemplateGroupByOutputType[P]>
        }
      >
    >


  export type CompanyTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeTemplate?: boolean
    nom?: boolean
    contenu?: boolean
    variables?: boolean
    estDefaut?: boolean
    estActif?: boolean
    entrepriseId?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyTemplate"]>



  export type CompanyTemplateSelectScalar = {
    id?: boolean
    typeTemplate?: boolean
    nom?: boolean
    contenu?: boolean
    variables?: boolean
    estDefaut?: boolean
    estActif?: boolean
    entrepriseId?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type CompanyTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "typeTemplate" | "nom" | "contenu" | "variables" | "estDefaut" | "estActif" | "entrepriseId" | "creeLe" | "modifieLe", ExtArgs["result"]["companyTemplate"]>
  export type CompanyTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
  }

  export type $CompanyTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyTemplate"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeTemplate: string
      nom: string
      contenu: string
      variables: Prisma.JsonValue
      estDefaut: boolean
      estActif: boolean
      entrepriseId: number
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["companyTemplate"]>
    composites: {}
  }

  type CompanyTemplateGetPayload<S extends boolean | null | undefined | CompanyTemplateDefaultArgs> = $Result.GetResult<Prisma.$CompanyTemplatePayload, S>

  type CompanyTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyTemplateCountAggregateInputType | true
    }

  export interface CompanyTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyTemplate'], meta: { name: 'CompanyTemplate' } }
    /**
     * Find zero or one CompanyTemplate that matches the filter.
     * @param {CompanyTemplateFindUniqueArgs} args - Arguments to find a CompanyTemplate
     * @example
     * // Get one CompanyTemplate
     * const companyTemplate = await prisma.companyTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyTemplateFindUniqueArgs>(args: SelectSubset<T, CompanyTemplateFindUniqueArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyTemplateFindUniqueOrThrowArgs} args - Arguments to find a CompanyTemplate
     * @example
     * // Get one CompanyTemplate
     * const companyTemplate = await prisma.companyTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTemplateFindFirstArgs} args - Arguments to find a CompanyTemplate
     * @example
     * // Get one CompanyTemplate
     * const companyTemplate = await prisma.companyTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyTemplateFindFirstArgs>(args?: SelectSubset<T, CompanyTemplateFindFirstArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTemplateFindFirstOrThrowArgs} args - Arguments to find a CompanyTemplate
     * @example
     * // Get one CompanyTemplate
     * const companyTemplate = await prisma.companyTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyTemplates
     * const companyTemplates = await prisma.companyTemplate.findMany()
     * 
     * // Get first 10 CompanyTemplates
     * const companyTemplates = await prisma.companyTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyTemplateWithIdOnly = await prisma.companyTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyTemplateFindManyArgs>(args?: SelectSubset<T, CompanyTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyTemplate.
     * @param {CompanyTemplateCreateArgs} args - Arguments to create a CompanyTemplate.
     * @example
     * // Create one CompanyTemplate
     * const CompanyTemplate = await prisma.companyTemplate.create({
     *   data: {
     *     // ... data to create a CompanyTemplate
     *   }
     * })
     * 
     */
    create<T extends CompanyTemplateCreateArgs>(args: SelectSubset<T, CompanyTemplateCreateArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyTemplates.
     * @param {CompanyTemplateCreateManyArgs} args - Arguments to create many CompanyTemplates.
     * @example
     * // Create many CompanyTemplates
     * const companyTemplate = await prisma.companyTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyTemplateCreateManyArgs>(args?: SelectSubset<T, CompanyTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyTemplate.
     * @param {CompanyTemplateDeleteArgs} args - Arguments to delete one CompanyTemplate.
     * @example
     * // Delete one CompanyTemplate
     * const CompanyTemplate = await prisma.companyTemplate.delete({
     *   where: {
     *     // ... filter to delete one CompanyTemplate
     *   }
     * })
     * 
     */
    delete<T extends CompanyTemplateDeleteArgs>(args: SelectSubset<T, CompanyTemplateDeleteArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyTemplate.
     * @param {CompanyTemplateUpdateArgs} args - Arguments to update one CompanyTemplate.
     * @example
     * // Update one CompanyTemplate
     * const companyTemplate = await prisma.companyTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyTemplateUpdateArgs>(args: SelectSubset<T, CompanyTemplateUpdateArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyTemplates.
     * @param {CompanyTemplateDeleteManyArgs} args - Arguments to filter CompanyTemplates to delete.
     * @example
     * // Delete a few CompanyTemplates
     * const { count } = await prisma.companyTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyTemplateDeleteManyArgs>(args?: SelectSubset<T, CompanyTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyTemplates
     * const companyTemplate = await prisma.companyTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyTemplateUpdateManyArgs>(args: SelectSubset<T, CompanyTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyTemplate.
     * @param {CompanyTemplateUpsertArgs} args - Arguments to update or create a CompanyTemplate.
     * @example
     * // Update or create a CompanyTemplate
     * const companyTemplate = await prisma.companyTemplate.upsert({
     *   create: {
     *     // ... data to create a CompanyTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyTemplate we want to update
     *   }
     * })
     */
    upsert<T extends CompanyTemplateUpsertArgs>(args: SelectSubset<T, CompanyTemplateUpsertArgs<ExtArgs>>): Prisma__CompanyTemplateClient<$Result.GetResult<Prisma.$CompanyTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTemplateCountArgs} args - Arguments to filter CompanyTemplates to count.
     * @example
     * // Count the number of CompanyTemplates
     * const count = await prisma.companyTemplate.count({
     *   where: {
     *     // ... the filter for the CompanyTemplates we want to count
     *   }
     * })
    **/
    count<T extends CompanyTemplateCountArgs>(
      args?: Subset<T, CompanyTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyTemplateAggregateArgs>(args: Subset<T, CompanyTemplateAggregateArgs>): Prisma.PrismaPromise<GetCompanyTemplateAggregateType<T>>

    /**
     * Group by CompanyTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyTemplateGroupByArgs['orderBy'] }
        : { orderBy?: CompanyTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyTemplate model
   */
  readonly fields: CompanyTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyTemplate model
   */
  interface CompanyTemplateFieldRefs {
    readonly id: FieldRef<"CompanyTemplate", 'Int'>
    readonly typeTemplate: FieldRef<"CompanyTemplate", 'String'>
    readonly nom: FieldRef<"CompanyTemplate", 'String'>
    readonly contenu: FieldRef<"CompanyTemplate", 'String'>
    readonly variables: FieldRef<"CompanyTemplate", 'Json'>
    readonly estDefaut: FieldRef<"CompanyTemplate", 'Boolean'>
    readonly estActif: FieldRef<"CompanyTemplate", 'Boolean'>
    readonly entrepriseId: FieldRef<"CompanyTemplate", 'Int'>
    readonly creeLe: FieldRef<"CompanyTemplate", 'DateTime'>
    readonly modifieLe: FieldRef<"CompanyTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyTemplate findUnique
   */
  export type CompanyTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTemplate to fetch.
     */
    where: CompanyTemplateWhereUniqueInput
  }

  /**
   * CompanyTemplate findUniqueOrThrow
   */
  export type CompanyTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTemplate to fetch.
     */
    where: CompanyTemplateWhereUniqueInput
  }

  /**
   * CompanyTemplate findFirst
   */
  export type CompanyTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTemplate to fetch.
     */
    where?: CompanyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTemplates to fetch.
     */
    orderBy?: CompanyTemplateOrderByWithRelationInput | CompanyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyTemplates.
     */
    cursor?: CompanyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyTemplates.
     */
    distinct?: CompanyTemplateScalarFieldEnum | CompanyTemplateScalarFieldEnum[]
  }

  /**
   * CompanyTemplate findFirstOrThrow
   */
  export type CompanyTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTemplate to fetch.
     */
    where?: CompanyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTemplates to fetch.
     */
    orderBy?: CompanyTemplateOrderByWithRelationInput | CompanyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyTemplates.
     */
    cursor?: CompanyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyTemplates.
     */
    distinct?: CompanyTemplateScalarFieldEnum | CompanyTemplateScalarFieldEnum[]
  }

  /**
   * CompanyTemplate findMany
   */
  export type CompanyTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTemplates to fetch.
     */
    where?: CompanyTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTemplates to fetch.
     */
    orderBy?: CompanyTemplateOrderByWithRelationInput | CompanyTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyTemplates.
     */
    cursor?: CompanyTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTemplates.
     */
    skip?: number
    distinct?: CompanyTemplateScalarFieldEnum | CompanyTemplateScalarFieldEnum[]
  }

  /**
   * CompanyTemplate create
   */
  export type CompanyTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyTemplate.
     */
    data: XOR<CompanyTemplateCreateInput, CompanyTemplateUncheckedCreateInput>
  }

  /**
   * CompanyTemplate createMany
   */
  export type CompanyTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyTemplates.
     */
    data: CompanyTemplateCreateManyInput | CompanyTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyTemplate update
   */
  export type CompanyTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyTemplate.
     */
    data: XOR<CompanyTemplateUpdateInput, CompanyTemplateUncheckedUpdateInput>
    /**
     * Choose, which CompanyTemplate to update.
     */
    where: CompanyTemplateWhereUniqueInput
  }

  /**
   * CompanyTemplate updateMany
   */
  export type CompanyTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyTemplates.
     */
    data: XOR<CompanyTemplateUpdateManyMutationInput, CompanyTemplateUncheckedUpdateManyInput>
    /**
     * Filter which CompanyTemplates to update
     */
    where?: CompanyTemplateWhereInput
    /**
     * Limit how many CompanyTemplates to update.
     */
    limit?: number
  }

  /**
   * CompanyTemplate upsert
   */
  export type CompanyTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyTemplate to update in case it exists.
     */
    where: CompanyTemplateWhereUniqueInput
    /**
     * In case the CompanyTemplate found by the `where` argument doesn't exist, create a new CompanyTemplate with this data.
     */
    create: XOR<CompanyTemplateCreateInput, CompanyTemplateUncheckedCreateInput>
    /**
     * In case the CompanyTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyTemplateUpdateInput, CompanyTemplateUncheckedUpdateInput>
  }

  /**
   * CompanyTemplate delete
   */
  export type CompanyTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
    /**
     * Filter which CompanyTemplate to delete.
     */
    where: CompanyTemplateWhereUniqueInput
  }

  /**
   * CompanyTemplate deleteMany
   */
  export type CompanyTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyTemplates to delete
     */
    where?: CompanyTemplateWhereInput
    /**
     * Limit how many CompanyTemplates to delete.
     */
    limit?: number
  }

  /**
   * CompanyTemplate without action
   */
  export type CompanyTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTemplate
     */
    select?: CompanyTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTemplate
     */
    omit?: CompanyTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTemplateInclude<ExtArgs> | null
  }


  /**
   * Model CompanySetting
   */

  export type AggregateCompanySetting = {
    _count: CompanySettingCountAggregateOutputType | null
    _avg: CompanySettingAvgAggregateOutputType | null
    _sum: CompanySettingSumAggregateOutputType | null
    _min: CompanySettingMinAggregateOutputType | null
    _max: CompanySettingMaxAggregateOutputType | null
  }

  export type CompanySettingAvgAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
  }

  export type CompanySettingSumAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
  }

  export type CompanySettingMinAggregateOutputType = {
    id: number | null
    cle: string | null
    valeur: string | null
    description: string | null
    typeData: string | null
    estEncrypte: boolean | null
    entrepriseId: number | null
    modifieLe: Date | null
  }

  export type CompanySettingMaxAggregateOutputType = {
    id: number | null
    cle: string | null
    valeur: string | null
    description: string | null
    typeData: string | null
    estEncrypte: boolean | null
    entrepriseId: number | null
    modifieLe: Date | null
  }

  export type CompanySettingCountAggregateOutputType = {
    id: number
    cle: number
    valeur: number
    description: number
    typeData: number
    estEncrypte: number
    entrepriseId: number
    modifieLe: number
    _all: number
  }


  export type CompanySettingAvgAggregateInputType = {
    id?: true
    entrepriseId?: true
  }

  export type CompanySettingSumAggregateInputType = {
    id?: true
    entrepriseId?: true
  }

  export type CompanySettingMinAggregateInputType = {
    id?: true
    cle?: true
    valeur?: true
    description?: true
    typeData?: true
    estEncrypte?: true
    entrepriseId?: true
    modifieLe?: true
  }

  export type CompanySettingMaxAggregateInputType = {
    id?: true
    cle?: true
    valeur?: true
    description?: true
    typeData?: true
    estEncrypte?: true
    entrepriseId?: true
    modifieLe?: true
  }

  export type CompanySettingCountAggregateInputType = {
    id?: true
    cle?: true
    valeur?: true
    description?: true
    typeData?: true
    estEncrypte?: true
    entrepriseId?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanySettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySetting to aggregate.
     */
    where?: CompanySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingOrderByWithRelationInput | CompanySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanySettings
    **/
    _count?: true | CompanySettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanySettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanySettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanySettingMaxAggregateInputType
  }

  export type GetCompanySettingAggregateType<T extends CompanySettingAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanySetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanySetting[P]>
      : GetScalarType<T[P], AggregateCompanySetting[P]>
  }




  export type CompanySettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySettingWhereInput
    orderBy?: CompanySettingOrderByWithAggregationInput | CompanySettingOrderByWithAggregationInput[]
    by: CompanySettingScalarFieldEnum[] | CompanySettingScalarFieldEnum
    having?: CompanySettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanySettingCountAggregateInputType | true
    _avg?: CompanySettingAvgAggregateInputType
    _sum?: CompanySettingSumAggregateInputType
    _min?: CompanySettingMinAggregateInputType
    _max?: CompanySettingMaxAggregateInputType
  }

  export type CompanySettingGroupByOutputType = {
    id: number
    cle: string
    valeur: string
    description: string | null
    typeData: string
    estEncrypte: boolean
    entrepriseId: number
    modifieLe: Date
    _count: CompanySettingCountAggregateOutputType | null
    _avg: CompanySettingAvgAggregateOutputType | null
    _sum: CompanySettingSumAggregateOutputType | null
    _min: CompanySettingMinAggregateOutputType | null
    _max: CompanySettingMaxAggregateOutputType | null
  }

  type GetCompanySettingGroupByPayload<T extends CompanySettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanySettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanySettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanySettingGroupByOutputType[P]>
            : GetScalarType<T[P], CompanySettingGroupByOutputType[P]>
        }
      >
    >


  export type CompanySettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cle?: boolean
    valeur?: boolean
    description?: boolean
    typeData?: boolean
    estEncrypte?: boolean
    entrepriseId?: boolean
    modifieLe?: boolean
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companySetting"]>



  export type CompanySettingSelectScalar = {
    id?: boolean
    cle?: boolean
    valeur?: boolean
    description?: boolean
    typeData?: boolean
    estEncrypte?: boolean
    entrepriseId?: boolean
    modifieLe?: boolean
  }

  export type CompanySettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cle" | "valeur" | "description" | "typeData" | "estEncrypte" | "entrepriseId" | "modifieLe", ExtArgs["result"]["companySetting"]>
  export type CompanySettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
  }

  export type $CompanySettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanySetting"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cle: string
      valeur: string
      description: string | null
      typeData: string
      estEncrypte: boolean
      entrepriseId: number
      modifieLe: Date
    }, ExtArgs["result"]["companySetting"]>
    composites: {}
  }

  type CompanySettingGetPayload<S extends boolean | null | undefined | CompanySettingDefaultArgs> = $Result.GetResult<Prisma.$CompanySettingPayload, S>

  type CompanySettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanySettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanySettingCountAggregateInputType | true
    }

  export interface CompanySettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanySetting'], meta: { name: 'CompanySetting' } }
    /**
     * Find zero or one CompanySetting that matches the filter.
     * @param {CompanySettingFindUniqueArgs} args - Arguments to find a CompanySetting
     * @example
     * // Get one CompanySetting
     * const companySetting = await prisma.companySetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanySettingFindUniqueArgs>(args: SelectSubset<T, CompanySettingFindUniqueArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanySetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanySettingFindUniqueOrThrowArgs} args - Arguments to find a CompanySetting
     * @example
     * // Get one CompanySetting
     * const companySetting = await prisma.companySetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanySettingFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanySettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingFindFirstArgs} args - Arguments to find a CompanySetting
     * @example
     * // Get one CompanySetting
     * const companySetting = await prisma.companySetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanySettingFindFirstArgs>(args?: SelectSubset<T, CompanySettingFindFirstArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingFindFirstOrThrowArgs} args - Arguments to find a CompanySetting
     * @example
     * // Get one CompanySetting
     * const companySetting = await prisma.companySetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanySettingFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanySettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanySettings
     * const companySettings = await prisma.companySetting.findMany()
     * 
     * // Get first 10 CompanySettings
     * const companySettings = await prisma.companySetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companySettingWithIdOnly = await prisma.companySetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanySettingFindManyArgs>(args?: SelectSubset<T, CompanySettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanySetting.
     * @param {CompanySettingCreateArgs} args - Arguments to create a CompanySetting.
     * @example
     * // Create one CompanySetting
     * const CompanySetting = await prisma.companySetting.create({
     *   data: {
     *     // ... data to create a CompanySetting
     *   }
     * })
     * 
     */
    create<T extends CompanySettingCreateArgs>(args: SelectSubset<T, CompanySettingCreateArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanySettings.
     * @param {CompanySettingCreateManyArgs} args - Arguments to create many CompanySettings.
     * @example
     * // Create many CompanySettings
     * const companySetting = await prisma.companySetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanySettingCreateManyArgs>(args?: SelectSubset<T, CompanySettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanySetting.
     * @param {CompanySettingDeleteArgs} args - Arguments to delete one CompanySetting.
     * @example
     * // Delete one CompanySetting
     * const CompanySetting = await prisma.companySetting.delete({
     *   where: {
     *     // ... filter to delete one CompanySetting
     *   }
     * })
     * 
     */
    delete<T extends CompanySettingDeleteArgs>(args: SelectSubset<T, CompanySettingDeleteArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanySetting.
     * @param {CompanySettingUpdateArgs} args - Arguments to update one CompanySetting.
     * @example
     * // Update one CompanySetting
     * const companySetting = await prisma.companySetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanySettingUpdateArgs>(args: SelectSubset<T, CompanySettingUpdateArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanySettings.
     * @param {CompanySettingDeleteManyArgs} args - Arguments to filter CompanySettings to delete.
     * @example
     * // Delete a few CompanySettings
     * const { count } = await prisma.companySetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanySettingDeleteManyArgs>(args?: SelectSubset<T, CompanySettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanySettings
     * const companySetting = await prisma.companySetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanySettingUpdateManyArgs>(args: SelectSubset<T, CompanySettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanySetting.
     * @param {CompanySettingUpsertArgs} args - Arguments to update or create a CompanySetting.
     * @example
     * // Update or create a CompanySetting
     * const companySetting = await prisma.companySetting.upsert({
     *   create: {
     *     // ... data to create a CompanySetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanySetting we want to update
     *   }
     * })
     */
    upsert<T extends CompanySettingUpsertArgs>(args: SelectSubset<T, CompanySettingUpsertArgs<ExtArgs>>): Prisma__CompanySettingClient<$Result.GetResult<Prisma.$CompanySettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingCountArgs} args - Arguments to filter CompanySettings to count.
     * @example
     * // Count the number of CompanySettings
     * const count = await prisma.companySetting.count({
     *   where: {
     *     // ... the filter for the CompanySettings we want to count
     *   }
     * })
    **/
    count<T extends CompanySettingCountArgs>(
      args?: Subset<T, CompanySettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanySettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanySetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanySettingAggregateArgs>(args: Subset<T, CompanySettingAggregateArgs>): Prisma.PrismaPromise<GetCompanySettingAggregateType<T>>

    /**
     * Group by CompanySetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanySettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanySettingGroupByArgs['orderBy'] }
        : { orderBy?: CompanySettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanySettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanySettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanySetting model
   */
  readonly fields: CompanySettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanySetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanySettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanySetting model
   */
  interface CompanySettingFieldRefs {
    readonly id: FieldRef<"CompanySetting", 'Int'>
    readonly cle: FieldRef<"CompanySetting", 'String'>
    readonly valeur: FieldRef<"CompanySetting", 'String'>
    readonly description: FieldRef<"CompanySetting", 'String'>
    readonly typeData: FieldRef<"CompanySetting", 'String'>
    readonly estEncrypte: FieldRef<"CompanySetting", 'Boolean'>
    readonly entrepriseId: FieldRef<"CompanySetting", 'Int'>
    readonly modifieLe: FieldRef<"CompanySetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanySetting findUnique
   */
  export type CompanySettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * Filter, which CompanySetting to fetch.
     */
    where: CompanySettingWhereUniqueInput
  }

  /**
   * CompanySetting findUniqueOrThrow
   */
  export type CompanySettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * Filter, which CompanySetting to fetch.
     */
    where: CompanySettingWhereUniqueInput
  }

  /**
   * CompanySetting findFirst
   */
  export type CompanySettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * Filter, which CompanySetting to fetch.
     */
    where?: CompanySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingOrderByWithRelationInput | CompanySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySettings.
     */
    cursor?: CompanySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySettings.
     */
    distinct?: CompanySettingScalarFieldEnum | CompanySettingScalarFieldEnum[]
  }

  /**
   * CompanySetting findFirstOrThrow
   */
  export type CompanySettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * Filter, which CompanySetting to fetch.
     */
    where?: CompanySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingOrderByWithRelationInput | CompanySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySettings.
     */
    cursor?: CompanySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySettings.
     */
    distinct?: CompanySettingScalarFieldEnum | CompanySettingScalarFieldEnum[]
  }

  /**
   * CompanySetting findMany
   */
  export type CompanySettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where?: CompanySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingOrderByWithRelationInput | CompanySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanySettings.
     */
    cursor?: CompanySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    distinct?: CompanySettingScalarFieldEnum | CompanySettingScalarFieldEnum[]
  }

  /**
   * CompanySetting create
   */
  export type CompanySettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanySetting.
     */
    data: XOR<CompanySettingCreateInput, CompanySettingUncheckedCreateInput>
  }

  /**
   * CompanySetting createMany
   */
  export type CompanySettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanySettings.
     */
    data: CompanySettingCreateManyInput | CompanySettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanySetting update
   */
  export type CompanySettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanySetting.
     */
    data: XOR<CompanySettingUpdateInput, CompanySettingUncheckedUpdateInput>
    /**
     * Choose, which CompanySetting to update.
     */
    where: CompanySettingWhereUniqueInput
  }

  /**
   * CompanySetting updateMany
   */
  export type CompanySettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanySettings.
     */
    data: XOR<CompanySettingUpdateManyMutationInput, CompanySettingUncheckedUpdateManyInput>
    /**
     * Filter which CompanySettings to update
     */
    where?: CompanySettingWhereInput
    /**
     * Limit how many CompanySettings to update.
     */
    limit?: number
  }

  /**
   * CompanySetting upsert
   */
  export type CompanySettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanySetting to update in case it exists.
     */
    where: CompanySettingWhereUniqueInput
    /**
     * In case the CompanySetting found by the `where` argument doesn't exist, create a new CompanySetting with this data.
     */
    create: XOR<CompanySettingCreateInput, CompanySettingUncheckedCreateInput>
    /**
     * In case the CompanySetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanySettingUpdateInput, CompanySettingUncheckedUpdateInput>
  }

  /**
   * CompanySetting delete
   */
  export type CompanySettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
    /**
     * Filter which CompanySetting to delete.
     */
    where: CompanySettingWhereUniqueInput
  }

  /**
   * CompanySetting deleteMany
   */
  export type CompanySettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySettings to delete
     */
    where?: CompanySettingWhereInput
    /**
     * Limit how many CompanySettings to delete.
     */
    limit?: number
  }

  /**
   * CompanySetting without action
   */
  export type CompanySettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySetting
     */
    select?: CompanySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySetting
     */
    omit?: CompanySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanySettingInclude<ExtArgs> | null
  }


  /**
   * Model CompanyDocument
   */

  export type AggregateCompanyDocument = {
    _count: CompanyDocumentCountAggregateOutputType | null
    _avg: CompanyDocumentAvgAggregateOutputType | null
    _sum: CompanyDocumentSumAggregateOutputType | null
    _min: CompanyDocumentMinAggregateOutputType | null
    _max: CompanyDocumentMaxAggregateOutputType | null
  }

  export type CompanyDocumentAvgAggregateOutputType = {
    id: number | null
    tailleFichier: number | null
    employeId: number | null
    uploadePar: number | null
  }

  export type CompanyDocumentSumAggregateOutputType = {
    id: number | null
    tailleFichier: number | null
    employeId: number | null
    uploadePar: number | null
  }

  export type CompanyDocumentMinAggregateOutputType = {
    id: number | null
    type: string | null
    titre: string | null
    description: string | null
    cheminFichier: string | null
    tailleFichier: number | null
    mimeType: string | null
    tags: string | null
    employeId: number | null
    uploadePar: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyDocumentMaxAggregateOutputType = {
    id: number | null
    type: string | null
    titre: string | null
    description: string | null
    cheminFichier: string | null
    tailleFichier: number | null
    mimeType: string | null
    tags: string | null
    employeId: number | null
    uploadePar: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyDocumentCountAggregateOutputType = {
    id: number
    type: number
    titre: number
    description: number
    cheminFichier: number
    tailleFichier: number
    mimeType: number
    metadata: number
    tags: number
    employeId: number
    uploadePar: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type CompanyDocumentAvgAggregateInputType = {
    id?: true
    tailleFichier?: true
    employeId?: true
    uploadePar?: true
  }

  export type CompanyDocumentSumAggregateInputType = {
    id?: true
    tailleFichier?: true
    employeId?: true
    uploadePar?: true
  }

  export type CompanyDocumentMinAggregateInputType = {
    id?: true
    type?: true
    titre?: true
    description?: true
    cheminFichier?: true
    tailleFichier?: true
    mimeType?: true
    tags?: true
    employeId?: true
    uploadePar?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyDocumentMaxAggregateInputType = {
    id?: true
    type?: true
    titre?: true
    description?: true
    cheminFichier?: true
    tailleFichier?: true
    mimeType?: true
    tags?: true
    employeId?: true
    uploadePar?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyDocumentCountAggregateInputType = {
    id?: true
    type?: true
    titre?: true
    description?: true
    cheminFichier?: true
    tailleFichier?: true
    mimeType?: true
    metadata?: true
    tags?: true
    employeId?: true
    uploadePar?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyDocument to aggregate.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyDocuments
    **/
    _count?: true | CompanyDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyDocumentMaxAggregateInputType
  }

  export type GetCompanyDocumentAggregateType<T extends CompanyDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyDocument[P]>
      : GetScalarType<T[P], AggregateCompanyDocument[P]>
  }




  export type CompanyDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyDocumentWhereInput
    orderBy?: CompanyDocumentOrderByWithAggregationInput | CompanyDocumentOrderByWithAggregationInput[]
    by: CompanyDocumentScalarFieldEnum[] | CompanyDocumentScalarFieldEnum
    having?: CompanyDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyDocumentCountAggregateInputType | true
    _avg?: CompanyDocumentAvgAggregateInputType
    _sum?: CompanyDocumentSumAggregateInputType
    _min?: CompanyDocumentMinAggregateInputType
    _max?: CompanyDocumentMaxAggregateInputType
  }

  export type CompanyDocumentGroupByOutputType = {
    id: number
    type: string
    titre: string
    description: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata: JsonValue | null
    tags: string
    employeId: number
    uploadePar: number
    creeLe: Date
    modifieLe: Date
    _count: CompanyDocumentCountAggregateOutputType | null
    _avg: CompanyDocumentAvgAggregateOutputType | null
    _sum: CompanyDocumentSumAggregateOutputType | null
    _min: CompanyDocumentMinAggregateOutputType | null
    _max: CompanyDocumentMaxAggregateOutputType | null
  }

  type GetCompanyDocumentGroupByPayload<T extends CompanyDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyDocumentGroupByOutputType[P]>
        }
      >
    >


  export type CompanyDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    titre?: boolean
    description?: boolean
    cheminFichier?: boolean
    tailleFichier?: boolean
    mimeType?: boolean
    metadata?: boolean
    tags?: boolean
    employeId?: boolean
    uploadePar?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyDocument"]>



  export type CompanyDocumentSelectScalar = {
    id?: boolean
    type?: boolean
    titre?: boolean
    description?: boolean
    cheminFichier?: boolean
    tailleFichier?: boolean
    mimeType?: boolean
    metadata?: boolean
    tags?: boolean
    employeId?: boolean
    uploadePar?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type CompanyDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "titre" | "description" | "cheminFichier" | "tailleFichier" | "mimeType" | "metadata" | "tags" | "employeId" | "uploadePar" | "creeLe" | "modifieLe", ExtArgs["result"]["companyDocument"]>
  export type CompanyDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyDocument"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      titre: string
      description: string | null
      cheminFichier: string
      tailleFichier: number
      mimeType: string
      metadata: Prisma.JsonValue | null
      tags: string
      employeId: number
      uploadePar: number
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["companyDocument"]>
    composites: {}
  }

  type CompanyDocumentGetPayload<S extends boolean | null | undefined | CompanyDocumentDefaultArgs> = $Result.GetResult<Prisma.$CompanyDocumentPayload, S>

  type CompanyDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyDocumentCountAggregateInputType | true
    }

  export interface CompanyDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyDocument'], meta: { name: 'CompanyDocument' } }
    /**
     * Find zero or one CompanyDocument that matches the filter.
     * @param {CompanyDocumentFindUniqueArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyDocumentFindUniqueArgs>(args: SelectSubset<T, CompanyDocumentFindUniqueArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyDocumentFindUniqueOrThrowArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindFirstArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyDocumentFindFirstArgs>(args?: SelectSubset<T, CompanyDocumentFindFirstArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindFirstOrThrowArgs} args - Arguments to find a CompanyDocument
     * @example
     * // Get one CompanyDocument
     * const companyDocument = await prisma.companyDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyDocuments
     * const companyDocuments = await prisma.companyDocument.findMany()
     * 
     * // Get first 10 CompanyDocuments
     * const companyDocuments = await prisma.companyDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyDocumentWithIdOnly = await prisma.companyDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyDocumentFindManyArgs>(args?: SelectSubset<T, CompanyDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyDocument.
     * @param {CompanyDocumentCreateArgs} args - Arguments to create a CompanyDocument.
     * @example
     * // Create one CompanyDocument
     * const CompanyDocument = await prisma.companyDocument.create({
     *   data: {
     *     // ... data to create a CompanyDocument
     *   }
     * })
     * 
     */
    create<T extends CompanyDocumentCreateArgs>(args: SelectSubset<T, CompanyDocumentCreateArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyDocuments.
     * @param {CompanyDocumentCreateManyArgs} args - Arguments to create many CompanyDocuments.
     * @example
     * // Create many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyDocumentCreateManyArgs>(args?: SelectSubset<T, CompanyDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyDocument.
     * @param {CompanyDocumentDeleteArgs} args - Arguments to delete one CompanyDocument.
     * @example
     * // Delete one CompanyDocument
     * const CompanyDocument = await prisma.companyDocument.delete({
     *   where: {
     *     // ... filter to delete one CompanyDocument
     *   }
     * })
     * 
     */
    delete<T extends CompanyDocumentDeleteArgs>(args: SelectSubset<T, CompanyDocumentDeleteArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyDocument.
     * @param {CompanyDocumentUpdateArgs} args - Arguments to update one CompanyDocument.
     * @example
     * // Update one CompanyDocument
     * const companyDocument = await prisma.companyDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyDocumentUpdateArgs>(args: SelectSubset<T, CompanyDocumentUpdateArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyDocuments.
     * @param {CompanyDocumentDeleteManyArgs} args - Arguments to filter CompanyDocuments to delete.
     * @example
     * // Delete a few CompanyDocuments
     * const { count } = await prisma.companyDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDocumentDeleteManyArgs>(args?: SelectSubset<T, CompanyDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyDocuments
     * const companyDocument = await prisma.companyDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyDocumentUpdateManyArgs>(args: SelectSubset<T, CompanyDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyDocument.
     * @param {CompanyDocumentUpsertArgs} args - Arguments to update or create a CompanyDocument.
     * @example
     * // Update or create a CompanyDocument
     * const companyDocument = await prisma.companyDocument.upsert({
     *   create: {
     *     // ... data to create a CompanyDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyDocument we want to update
     *   }
     * })
     */
    upsert<T extends CompanyDocumentUpsertArgs>(args: SelectSubset<T, CompanyDocumentUpsertArgs<ExtArgs>>): Prisma__CompanyDocumentClient<$Result.GetResult<Prisma.$CompanyDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentCountArgs} args - Arguments to filter CompanyDocuments to count.
     * @example
     * // Count the number of CompanyDocuments
     * const count = await prisma.companyDocument.count({
     *   where: {
     *     // ... the filter for the CompanyDocuments we want to count
     *   }
     * })
    **/
    count<T extends CompanyDocumentCountArgs>(
      args?: Subset<T, CompanyDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyDocumentAggregateArgs>(args: Subset<T, CompanyDocumentAggregateArgs>): Prisma.PrismaPromise<GetCompanyDocumentAggregateType<T>>

    /**
     * Group by CompanyDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CompanyDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyDocument model
   */
  readonly fields: CompanyDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyDocument model
   */
  interface CompanyDocumentFieldRefs {
    readonly id: FieldRef<"CompanyDocument", 'Int'>
    readonly type: FieldRef<"CompanyDocument", 'String'>
    readonly titre: FieldRef<"CompanyDocument", 'String'>
    readonly description: FieldRef<"CompanyDocument", 'String'>
    readonly cheminFichier: FieldRef<"CompanyDocument", 'String'>
    readonly tailleFichier: FieldRef<"CompanyDocument", 'Int'>
    readonly mimeType: FieldRef<"CompanyDocument", 'String'>
    readonly metadata: FieldRef<"CompanyDocument", 'Json'>
    readonly tags: FieldRef<"CompanyDocument", 'String'>
    readonly employeId: FieldRef<"CompanyDocument", 'Int'>
    readonly uploadePar: FieldRef<"CompanyDocument", 'Int'>
    readonly creeLe: FieldRef<"CompanyDocument", 'DateTime'>
    readonly modifieLe: FieldRef<"CompanyDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyDocument findUnique
   */
  export type CompanyDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument findUniqueOrThrow
   */
  export type CompanyDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument findFirst
   */
  export type CompanyDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDocuments.
     */
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument findFirstOrThrow
   */
  export type CompanyDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocument to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDocuments.
     */
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument findMany
   */
  export type CompanyDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyDocuments to fetch.
     */
    where?: CompanyDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDocuments to fetch.
     */
    orderBy?: CompanyDocumentOrderByWithRelationInput | CompanyDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyDocuments.
     */
    cursor?: CompanyDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDocuments.
     */
    skip?: number
    distinct?: CompanyDocumentScalarFieldEnum | CompanyDocumentScalarFieldEnum[]
  }

  /**
   * CompanyDocument create
   */
  export type CompanyDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyDocument.
     */
    data: XOR<CompanyDocumentCreateInput, CompanyDocumentUncheckedCreateInput>
  }

  /**
   * CompanyDocument createMany
   */
  export type CompanyDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyDocuments.
     */
    data: CompanyDocumentCreateManyInput | CompanyDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyDocument update
   */
  export type CompanyDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyDocument.
     */
    data: XOR<CompanyDocumentUpdateInput, CompanyDocumentUncheckedUpdateInput>
    /**
     * Choose, which CompanyDocument to update.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument updateMany
   */
  export type CompanyDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyDocuments.
     */
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CompanyDocuments to update
     */
    where?: CompanyDocumentWhereInput
    /**
     * Limit how many CompanyDocuments to update.
     */
    limit?: number
  }

  /**
   * CompanyDocument upsert
   */
  export type CompanyDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyDocument to update in case it exists.
     */
    where: CompanyDocumentWhereUniqueInput
    /**
     * In case the CompanyDocument found by the `where` argument doesn't exist, create a new CompanyDocument with this data.
     */
    create: XOR<CompanyDocumentCreateInput, CompanyDocumentUncheckedCreateInput>
    /**
     * In case the CompanyDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyDocumentUpdateInput, CompanyDocumentUncheckedUpdateInput>
  }

  /**
   * CompanyDocument delete
   */
  export type CompanyDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
    /**
     * Filter which CompanyDocument to delete.
     */
    where: CompanyDocumentWhereUniqueInput
  }

  /**
   * CompanyDocument deleteMany
   */
  export type CompanyDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyDocuments to delete
     */
    where?: CompanyDocumentWhereInput
    /**
     * Limit how many CompanyDocuments to delete.
     */
    limit?: number
  }

  /**
   * CompanyDocument without action
   */
  export type CompanyDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyDocument
     */
    select?: CompanyDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyDocument
     */
    omit?: CompanyDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyDocumentInclude<ExtArgs> | null
  }


  /**
   * Model CompanyModeleDocument
   */

  export type AggregateCompanyModeleDocument = {
    _count: CompanyModeleDocumentCountAggregateOutputType | null
    _avg: CompanyModeleDocumentAvgAggregateOutputType | null
    _sum: CompanyModeleDocumentSumAggregateOutputType | null
    _min: CompanyModeleDocumentMinAggregateOutputType | null
    _max: CompanyModeleDocumentMaxAggregateOutputType | null
  }

  export type CompanyModeleDocumentAvgAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    version: number | null
    creePar: number | null
  }

  export type CompanyModeleDocumentSumAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    version: number | null
    creePar: number | null
  }

  export type CompanyModeleDocumentMinAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    type: string | null
    contenu: string | null
    estActif: boolean | null
    entrepriseId: number | null
    version: number | null
    creePar: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyModeleDocumentMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    type: string | null
    contenu: string | null
    estActif: boolean | null
    entrepriseId: number | null
    version: number | null
    creePar: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyModeleDocumentCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    type: number
    contenu: number
    variables: number
    estActif: number
    entrepriseId: number
    version: number
    creePar: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type CompanyModeleDocumentAvgAggregateInputType = {
    id?: true
    entrepriseId?: true
    version?: true
    creePar?: true
  }

  export type CompanyModeleDocumentSumAggregateInputType = {
    id?: true
    entrepriseId?: true
    version?: true
    creePar?: true
  }

  export type CompanyModeleDocumentMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    type?: true
    contenu?: true
    estActif?: true
    entrepriseId?: true
    version?: true
    creePar?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyModeleDocumentMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    type?: true
    contenu?: true
    estActif?: true
    entrepriseId?: true
    version?: true
    creePar?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyModeleDocumentCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    type?: true
    contenu?: true
    variables?: true
    estActif?: true
    entrepriseId?: true
    version?: true
    creePar?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyModeleDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyModeleDocument to aggregate.
     */
    where?: CompanyModeleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyModeleDocuments to fetch.
     */
    orderBy?: CompanyModeleDocumentOrderByWithRelationInput | CompanyModeleDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyModeleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyModeleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyModeleDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyModeleDocuments
    **/
    _count?: true | CompanyModeleDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyModeleDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyModeleDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyModeleDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyModeleDocumentMaxAggregateInputType
  }

  export type GetCompanyModeleDocumentAggregateType<T extends CompanyModeleDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyModeleDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyModeleDocument[P]>
      : GetScalarType<T[P], AggregateCompanyModeleDocument[P]>
  }




  export type CompanyModeleDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyModeleDocumentWhereInput
    orderBy?: CompanyModeleDocumentOrderByWithAggregationInput | CompanyModeleDocumentOrderByWithAggregationInput[]
    by: CompanyModeleDocumentScalarFieldEnum[] | CompanyModeleDocumentScalarFieldEnum
    having?: CompanyModeleDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyModeleDocumentCountAggregateInputType | true
    _avg?: CompanyModeleDocumentAvgAggregateInputType
    _sum?: CompanyModeleDocumentSumAggregateInputType
    _min?: CompanyModeleDocumentMinAggregateInputType
    _max?: CompanyModeleDocumentMaxAggregateInputType
  }

  export type CompanyModeleDocumentGroupByOutputType = {
    id: number
    nom: string
    description: string | null
    type: string
    contenu: string
    variables: JsonValue
    estActif: boolean
    entrepriseId: number
    version: number
    creePar: number
    creeLe: Date
    modifieLe: Date
    _count: CompanyModeleDocumentCountAggregateOutputType | null
    _avg: CompanyModeleDocumentAvgAggregateOutputType | null
    _sum: CompanyModeleDocumentSumAggregateOutputType | null
    _min: CompanyModeleDocumentMinAggregateOutputType | null
    _max: CompanyModeleDocumentMaxAggregateOutputType | null
  }

  type GetCompanyModeleDocumentGroupByPayload<T extends CompanyModeleDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyModeleDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyModeleDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyModeleDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyModeleDocumentGroupByOutputType[P]>
        }
      >
    >


  export type CompanyModeleDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    type?: boolean
    contenu?: boolean
    variables?: boolean
    estActif?: boolean
    entrepriseId?: boolean
    version?: boolean
    creePar?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyModeleDocument"]>



  export type CompanyModeleDocumentSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    type?: boolean
    contenu?: boolean
    variables?: boolean
    estActif?: boolean
    entrepriseId?: boolean
    version?: boolean
    creePar?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type CompanyModeleDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "description" | "type" | "contenu" | "variables" | "estActif" | "entrepriseId" | "version" | "creePar" | "creeLe" | "modifieLe", ExtArgs["result"]["companyModeleDocument"]>
  export type CompanyModeleDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyModeleDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyModeleDocument"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      description: string | null
      type: string
      contenu: string
      variables: Prisma.JsonValue
      estActif: boolean
      entrepriseId: number
      version: number
      creePar: number
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["companyModeleDocument"]>
    composites: {}
  }

  type CompanyModeleDocumentGetPayload<S extends boolean | null | undefined | CompanyModeleDocumentDefaultArgs> = $Result.GetResult<Prisma.$CompanyModeleDocumentPayload, S>

  type CompanyModeleDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyModeleDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyModeleDocumentCountAggregateInputType | true
    }

  export interface CompanyModeleDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyModeleDocument'], meta: { name: 'CompanyModeleDocument' } }
    /**
     * Find zero or one CompanyModeleDocument that matches the filter.
     * @param {CompanyModeleDocumentFindUniqueArgs} args - Arguments to find a CompanyModeleDocument
     * @example
     * // Get one CompanyModeleDocument
     * const companyModeleDocument = await prisma.companyModeleDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyModeleDocumentFindUniqueArgs>(args: SelectSubset<T, CompanyModeleDocumentFindUniqueArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyModeleDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyModeleDocumentFindUniqueOrThrowArgs} args - Arguments to find a CompanyModeleDocument
     * @example
     * // Get one CompanyModeleDocument
     * const companyModeleDocument = await prisma.companyModeleDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyModeleDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyModeleDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyModeleDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyModeleDocumentFindFirstArgs} args - Arguments to find a CompanyModeleDocument
     * @example
     * // Get one CompanyModeleDocument
     * const companyModeleDocument = await prisma.companyModeleDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyModeleDocumentFindFirstArgs>(args?: SelectSubset<T, CompanyModeleDocumentFindFirstArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyModeleDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyModeleDocumentFindFirstOrThrowArgs} args - Arguments to find a CompanyModeleDocument
     * @example
     * // Get one CompanyModeleDocument
     * const companyModeleDocument = await prisma.companyModeleDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyModeleDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyModeleDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyModeleDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyModeleDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyModeleDocuments
     * const companyModeleDocuments = await prisma.companyModeleDocument.findMany()
     * 
     * // Get first 10 CompanyModeleDocuments
     * const companyModeleDocuments = await prisma.companyModeleDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyModeleDocumentWithIdOnly = await prisma.companyModeleDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyModeleDocumentFindManyArgs>(args?: SelectSubset<T, CompanyModeleDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyModeleDocument.
     * @param {CompanyModeleDocumentCreateArgs} args - Arguments to create a CompanyModeleDocument.
     * @example
     * // Create one CompanyModeleDocument
     * const CompanyModeleDocument = await prisma.companyModeleDocument.create({
     *   data: {
     *     // ... data to create a CompanyModeleDocument
     *   }
     * })
     * 
     */
    create<T extends CompanyModeleDocumentCreateArgs>(args: SelectSubset<T, CompanyModeleDocumentCreateArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyModeleDocuments.
     * @param {CompanyModeleDocumentCreateManyArgs} args - Arguments to create many CompanyModeleDocuments.
     * @example
     * // Create many CompanyModeleDocuments
     * const companyModeleDocument = await prisma.companyModeleDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyModeleDocumentCreateManyArgs>(args?: SelectSubset<T, CompanyModeleDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyModeleDocument.
     * @param {CompanyModeleDocumentDeleteArgs} args - Arguments to delete one CompanyModeleDocument.
     * @example
     * // Delete one CompanyModeleDocument
     * const CompanyModeleDocument = await prisma.companyModeleDocument.delete({
     *   where: {
     *     // ... filter to delete one CompanyModeleDocument
     *   }
     * })
     * 
     */
    delete<T extends CompanyModeleDocumentDeleteArgs>(args: SelectSubset<T, CompanyModeleDocumentDeleteArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyModeleDocument.
     * @param {CompanyModeleDocumentUpdateArgs} args - Arguments to update one CompanyModeleDocument.
     * @example
     * // Update one CompanyModeleDocument
     * const companyModeleDocument = await prisma.companyModeleDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyModeleDocumentUpdateArgs>(args: SelectSubset<T, CompanyModeleDocumentUpdateArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyModeleDocuments.
     * @param {CompanyModeleDocumentDeleteManyArgs} args - Arguments to filter CompanyModeleDocuments to delete.
     * @example
     * // Delete a few CompanyModeleDocuments
     * const { count } = await prisma.companyModeleDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyModeleDocumentDeleteManyArgs>(args?: SelectSubset<T, CompanyModeleDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyModeleDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyModeleDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyModeleDocuments
     * const companyModeleDocument = await prisma.companyModeleDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyModeleDocumentUpdateManyArgs>(args: SelectSubset<T, CompanyModeleDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyModeleDocument.
     * @param {CompanyModeleDocumentUpsertArgs} args - Arguments to update or create a CompanyModeleDocument.
     * @example
     * // Update or create a CompanyModeleDocument
     * const companyModeleDocument = await prisma.companyModeleDocument.upsert({
     *   create: {
     *     // ... data to create a CompanyModeleDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyModeleDocument we want to update
     *   }
     * })
     */
    upsert<T extends CompanyModeleDocumentUpsertArgs>(args: SelectSubset<T, CompanyModeleDocumentUpsertArgs<ExtArgs>>): Prisma__CompanyModeleDocumentClient<$Result.GetResult<Prisma.$CompanyModeleDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyModeleDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyModeleDocumentCountArgs} args - Arguments to filter CompanyModeleDocuments to count.
     * @example
     * // Count the number of CompanyModeleDocuments
     * const count = await prisma.companyModeleDocument.count({
     *   where: {
     *     // ... the filter for the CompanyModeleDocuments we want to count
     *   }
     * })
    **/
    count<T extends CompanyModeleDocumentCountArgs>(
      args?: Subset<T, CompanyModeleDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyModeleDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyModeleDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyModeleDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyModeleDocumentAggregateArgs>(args: Subset<T, CompanyModeleDocumentAggregateArgs>): Prisma.PrismaPromise<GetCompanyModeleDocumentAggregateType<T>>

    /**
     * Group by CompanyModeleDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyModeleDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyModeleDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyModeleDocumentGroupByArgs['orderBy'] }
        : { orderBy?: CompanyModeleDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyModeleDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyModeleDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyModeleDocument model
   */
  readonly fields: CompanyModeleDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyModeleDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyModeleDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyModeleDocument model
   */
  interface CompanyModeleDocumentFieldRefs {
    readonly id: FieldRef<"CompanyModeleDocument", 'Int'>
    readonly nom: FieldRef<"CompanyModeleDocument", 'String'>
    readonly description: FieldRef<"CompanyModeleDocument", 'String'>
    readonly type: FieldRef<"CompanyModeleDocument", 'String'>
    readonly contenu: FieldRef<"CompanyModeleDocument", 'String'>
    readonly variables: FieldRef<"CompanyModeleDocument", 'Json'>
    readonly estActif: FieldRef<"CompanyModeleDocument", 'Boolean'>
    readonly entrepriseId: FieldRef<"CompanyModeleDocument", 'Int'>
    readonly version: FieldRef<"CompanyModeleDocument", 'Int'>
    readonly creePar: FieldRef<"CompanyModeleDocument", 'Int'>
    readonly creeLe: FieldRef<"CompanyModeleDocument", 'DateTime'>
    readonly modifieLe: FieldRef<"CompanyModeleDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyModeleDocument findUnique
   */
  export type CompanyModeleDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyModeleDocument to fetch.
     */
    where: CompanyModeleDocumentWhereUniqueInput
  }

  /**
   * CompanyModeleDocument findUniqueOrThrow
   */
  export type CompanyModeleDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyModeleDocument to fetch.
     */
    where: CompanyModeleDocumentWhereUniqueInput
  }

  /**
   * CompanyModeleDocument findFirst
   */
  export type CompanyModeleDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyModeleDocument to fetch.
     */
    where?: CompanyModeleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyModeleDocuments to fetch.
     */
    orderBy?: CompanyModeleDocumentOrderByWithRelationInput | CompanyModeleDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyModeleDocuments.
     */
    cursor?: CompanyModeleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyModeleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyModeleDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyModeleDocuments.
     */
    distinct?: CompanyModeleDocumentScalarFieldEnum | CompanyModeleDocumentScalarFieldEnum[]
  }

  /**
   * CompanyModeleDocument findFirstOrThrow
   */
  export type CompanyModeleDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyModeleDocument to fetch.
     */
    where?: CompanyModeleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyModeleDocuments to fetch.
     */
    orderBy?: CompanyModeleDocumentOrderByWithRelationInput | CompanyModeleDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyModeleDocuments.
     */
    cursor?: CompanyModeleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyModeleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyModeleDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyModeleDocuments.
     */
    distinct?: CompanyModeleDocumentScalarFieldEnum | CompanyModeleDocumentScalarFieldEnum[]
  }

  /**
   * CompanyModeleDocument findMany
   */
  export type CompanyModeleDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * Filter, which CompanyModeleDocuments to fetch.
     */
    where?: CompanyModeleDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyModeleDocuments to fetch.
     */
    orderBy?: CompanyModeleDocumentOrderByWithRelationInput | CompanyModeleDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyModeleDocuments.
     */
    cursor?: CompanyModeleDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyModeleDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyModeleDocuments.
     */
    skip?: number
    distinct?: CompanyModeleDocumentScalarFieldEnum | CompanyModeleDocumentScalarFieldEnum[]
  }

  /**
   * CompanyModeleDocument create
   */
  export type CompanyModeleDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyModeleDocument.
     */
    data: XOR<CompanyModeleDocumentCreateInput, CompanyModeleDocumentUncheckedCreateInput>
  }

  /**
   * CompanyModeleDocument createMany
   */
  export type CompanyModeleDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyModeleDocuments.
     */
    data: CompanyModeleDocumentCreateManyInput | CompanyModeleDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyModeleDocument update
   */
  export type CompanyModeleDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyModeleDocument.
     */
    data: XOR<CompanyModeleDocumentUpdateInput, CompanyModeleDocumentUncheckedUpdateInput>
    /**
     * Choose, which CompanyModeleDocument to update.
     */
    where: CompanyModeleDocumentWhereUniqueInput
  }

  /**
   * CompanyModeleDocument updateMany
   */
  export type CompanyModeleDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyModeleDocuments.
     */
    data: XOR<CompanyModeleDocumentUpdateManyMutationInput, CompanyModeleDocumentUncheckedUpdateManyInput>
    /**
     * Filter which CompanyModeleDocuments to update
     */
    where?: CompanyModeleDocumentWhereInput
    /**
     * Limit how many CompanyModeleDocuments to update.
     */
    limit?: number
  }

  /**
   * CompanyModeleDocument upsert
   */
  export type CompanyModeleDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyModeleDocument to update in case it exists.
     */
    where: CompanyModeleDocumentWhereUniqueInput
    /**
     * In case the CompanyModeleDocument found by the `where` argument doesn't exist, create a new CompanyModeleDocument with this data.
     */
    create: XOR<CompanyModeleDocumentCreateInput, CompanyModeleDocumentUncheckedCreateInput>
    /**
     * In case the CompanyModeleDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyModeleDocumentUpdateInput, CompanyModeleDocumentUncheckedUpdateInput>
  }

  /**
   * CompanyModeleDocument delete
   */
  export type CompanyModeleDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
    /**
     * Filter which CompanyModeleDocument to delete.
     */
    where: CompanyModeleDocumentWhereUniqueInput
  }

  /**
   * CompanyModeleDocument deleteMany
   */
  export type CompanyModeleDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyModeleDocuments to delete
     */
    where?: CompanyModeleDocumentWhereInput
    /**
     * Limit how many CompanyModeleDocuments to delete.
     */
    limit?: number
  }

  /**
   * CompanyModeleDocument without action
   */
  export type CompanyModeleDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyModeleDocument
     */
    select?: CompanyModeleDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyModeleDocument
     */
    omit?: CompanyModeleDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyModeleDocumentInclude<ExtArgs> | null
  }


  /**
   * Model CompanyPeriodePaie
   */

  export type AggregateCompanyPeriodePaie = {
    _count: CompanyPeriodePaieCountAggregateOutputType | null
    _avg: CompanyPeriodePaieAvgAggregateOutputType | null
    _sum: CompanyPeriodePaieSumAggregateOutputType | null
    _min: CompanyPeriodePaieMinAggregateOutputType | null
    _max: CompanyPeriodePaieMaxAggregateOutputType | null
  }

  export type CompanyPeriodePaieAvgAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
  }

  export type CompanyPeriodePaieSumAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
  }

  export type CompanyPeriodePaieMinAggregateOutputType = {
    id: number | null
    nom: string | null
    dateDebut: Date | null
    dateFin: Date | null
    estCloturee: boolean | null
    dateReglement: Date | null
    notes: string | null
    entrepriseId: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyPeriodePaieMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    dateDebut: Date | null
    dateFin: Date | null
    estCloturee: boolean | null
    dateReglement: Date | null
    notes: string | null
    entrepriseId: number | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyPeriodePaieCountAggregateOutputType = {
    id: number
    nom: number
    dateDebut: number
    dateFin: number
    estCloturee: number
    dateReglement: number
    notes: number
    metadata: number
    entrepriseId: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type CompanyPeriodePaieAvgAggregateInputType = {
    id?: true
    entrepriseId?: true
  }

  export type CompanyPeriodePaieSumAggregateInputType = {
    id?: true
    entrepriseId?: true
  }

  export type CompanyPeriodePaieMinAggregateInputType = {
    id?: true
    nom?: true
    dateDebut?: true
    dateFin?: true
    estCloturee?: true
    dateReglement?: true
    notes?: true
    entrepriseId?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyPeriodePaieMaxAggregateInputType = {
    id?: true
    nom?: true
    dateDebut?: true
    dateFin?: true
    estCloturee?: true
    dateReglement?: true
    notes?: true
    entrepriseId?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyPeriodePaieCountAggregateInputType = {
    id?: true
    nom?: true
    dateDebut?: true
    dateFin?: true
    estCloturee?: true
    dateReglement?: true
    notes?: true
    metadata?: true
    entrepriseId?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyPeriodePaieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPeriodePaie to aggregate.
     */
    where?: CompanyPeriodePaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPeriodePaies to fetch.
     */
    orderBy?: CompanyPeriodePaieOrderByWithRelationInput | CompanyPeriodePaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyPeriodePaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPeriodePaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPeriodePaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyPeriodePaies
    **/
    _count?: true | CompanyPeriodePaieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyPeriodePaieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyPeriodePaieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyPeriodePaieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyPeriodePaieMaxAggregateInputType
  }

  export type GetCompanyPeriodePaieAggregateType<T extends CompanyPeriodePaieAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyPeriodePaie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyPeriodePaie[P]>
      : GetScalarType<T[P], AggregateCompanyPeriodePaie[P]>
  }




  export type CompanyPeriodePaieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyPeriodePaieWhereInput
    orderBy?: CompanyPeriodePaieOrderByWithAggregationInput | CompanyPeriodePaieOrderByWithAggregationInput[]
    by: CompanyPeriodePaieScalarFieldEnum[] | CompanyPeriodePaieScalarFieldEnum
    having?: CompanyPeriodePaieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyPeriodePaieCountAggregateInputType | true
    _avg?: CompanyPeriodePaieAvgAggregateInputType
    _sum?: CompanyPeriodePaieSumAggregateInputType
    _min?: CompanyPeriodePaieMinAggregateInputType
    _max?: CompanyPeriodePaieMaxAggregateInputType
  }

  export type CompanyPeriodePaieGroupByOutputType = {
    id: number
    nom: string
    dateDebut: Date
    dateFin: Date
    estCloturee: boolean
    dateReglement: Date | null
    notes: string | null
    metadata: JsonValue | null
    entrepriseId: number
    creeLe: Date
    modifieLe: Date
    _count: CompanyPeriodePaieCountAggregateOutputType | null
    _avg: CompanyPeriodePaieAvgAggregateOutputType | null
    _sum: CompanyPeriodePaieSumAggregateOutputType | null
    _min: CompanyPeriodePaieMinAggregateOutputType | null
    _max: CompanyPeriodePaieMaxAggregateOutputType | null
  }

  type GetCompanyPeriodePaieGroupByPayload<T extends CompanyPeriodePaieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyPeriodePaieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyPeriodePaieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyPeriodePaieGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyPeriodePaieGroupByOutputType[P]>
        }
      >
    >


  export type CompanyPeriodePaieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    estCloturee?: boolean
    dateReglement?: boolean
    notes?: boolean
    metadata?: boolean
    entrepriseId?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    payRuns?: boolean | CompanyPeriodePaie$payRunsArgs<ExtArgs>
    _count?: boolean | CompanyPeriodePaieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyPeriodePaie"]>



  export type CompanyPeriodePaieSelectScalar = {
    id?: boolean
    nom?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    estCloturee?: boolean
    dateReglement?: boolean
    notes?: boolean
    metadata?: boolean
    entrepriseId?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type CompanyPeriodePaieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "dateDebut" | "dateFin" | "estCloturee" | "dateReglement" | "notes" | "metadata" | "entrepriseId" | "creeLe" | "modifieLe", ExtArgs["result"]["companyPeriodePaie"]>
  export type CompanyPeriodePaieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    payRuns?: boolean | CompanyPeriodePaie$payRunsArgs<ExtArgs>
    _count?: boolean | CompanyPeriodePaieCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyPeriodePaiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyPeriodePaie"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
      payRuns: Prisma.$CompanyPayRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      dateDebut: Date
      dateFin: Date
      estCloturee: boolean
      dateReglement: Date | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      entrepriseId: number
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["companyPeriodePaie"]>
    composites: {}
  }

  type CompanyPeriodePaieGetPayload<S extends boolean | null | undefined | CompanyPeriodePaieDefaultArgs> = $Result.GetResult<Prisma.$CompanyPeriodePaiePayload, S>

  type CompanyPeriodePaieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyPeriodePaieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyPeriodePaieCountAggregateInputType | true
    }

  export interface CompanyPeriodePaieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyPeriodePaie'], meta: { name: 'CompanyPeriodePaie' } }
    /**
     * Find zero or one CompanyPeriodePaie that matches the filter.
     * @param {CompanyPeriodePaieFindUniqueArgs} args - Arguments to find a CompanyPeriodePaie
     * @example
     * // Get one CompanyPeriodePaie
     * const companyPeriodePaie = await prisma.companyPeriodePaie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyPeriodePaieFindUniqueArgs>(args: SelectSubset<T, CompanyPeriodePaieFindUniqueArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyPeriodePaie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyPeriodePaieFindUniqueOrThrowArgs} args - Arguments to find a CompanyPeriodePaie
     * @example
     * // Get one CompanyPeriodePaie
     * const companyPeriodePaie = await prisma.companyPeriodePaie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyPeriodePaieFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyPeriodePaieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyPeriodePaie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPeriodePaieFindFirstArgs} args - Arguments to find a CompanyPeriodePaie
     * @example
     * // Get one CompanyPeriodePaie
     * const companyPeriodePaie = await prisma.companyPeriodePaie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyPeriodePaieFindFirstArgs>(args?: SelectSubset<T, CompanyPeriodePaieFindFirstArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyPeriodePaie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPeriodePaieFindFirstOrThrowArgs} args - Arguments to find a CompanyPeriodePaie
     * @example
     * // Get one CompanyPeriodePaie
     * const companyPeriodePaie = await prisma.companyPeriodePaie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyPeriodePaieFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyPeriodePaieFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyPeriodePaies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPeriodePaieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyPeriodePaies
     * const companyPeriodePaies = await prisma.companyPeriodePaie.findMany()
     * 
     * // Get first 10 CompanyPeriodePaies
     * const companyPeriodePaies = await prisma.companyPeriodePaie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyPeriodePaieWithIdOnly = await prisma.companyPeriodePaie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyPeriodePaieFindManyArgs>(args?: SelectSubset<T, CompanyPeriodePaieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyPeriodePaie.
     * @param {CompanyPeriodePaieCreateArgs} args - Arguments to create a CompanyPeriodePaie.
     * @example
     * // Create one CompanyPeriodePaie
     * const CompanyPeriodePaie = await prisma.companyPeriodePaie.create({
     *   data: {
     *     // ... data to create a CompanyPeriodePaie
     *   }
     * })
     * 
     */
    create<T extends CompanyPeriodePaieCreateArgs>(args: SelectSubset<T, CompanyPeriodePaieCreateArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyPeriodePaies.
     * @param {CompanyPeriodePaieCreateManyArgs} args - Arguments to create many CompanyPeriodePaies.
     * @example
     * // Create many CompanyPeriodePaies
     * const companyPeriodePaie = await prisma.companyPeriodePaie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyPeriodePaieCreateManyArgs>(args?: SelectSubset<T, CompanyPeriodePaieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyPeriodePaie.
     * @param {CompanyPeriodePaieDeleteArgs} args - Arguments to delete one CompanyPeriodePaie.
     * @example
     * // Delete one CompanyPeriodePaie
     * const CompanyPeriodePaie = await prisma.companyPeriodePaie.delete({
     *   where: {
     *     // ... filter to delete one CompanyPeriodePaie
     *   }
     * })
     * 
     */
    delete<T extends CompanyPeriodePaieDeleteArgs>(args: SelectSubset<T, CompanyPeriodePaieDeleteArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyPeriodePaie.
     * @param {CompanyPeriodePaieUpdateArgs} args - Arguments to update one CompanyPeriodePaie.
     * @example
     * // Update one CompanyPeriodePaie
     * const companyPeriodePaie = await prisma.companyPeriodePaie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyPeriodePaieUpdateArgs>(args: SelectSubset<T, CompanyPeriodePaieUpdateArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyPeriodePaies.
     * @param {CompanyPeriodePaieDeleteManyArgs} args - Arguments to filter CompanyPeriodePaies to delete.
     * @example
     * // Delete a few CompanyPeriodePaies
     * const { count } = await prisma.companyPeriodePaie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyPeriodePaieDeleteManyArgs>(args?: SelectSubset<T, CompanyPeriodePaieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyPeriodePaies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPeriodePaieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyPeriodePaies
     * const companyPeriodePaie = await prisma.companyPeriodePaie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyPeriodePaieUpdateManyArgs>(args: SelectSubset<T, CompanyPeriodePaieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyPeriodePaie.
     * @param {CompanyPeriodePaieUpsertArgs} args - Arguments to update or create a CompanyPeriodePaie.
     * @example
     * // Update or create a CompanyPeriodePaie
     * const companyPeriodePaie = await prisma.companyPeriodePaie.upsert({
     *   create: {
     *     // ... data to create a CompanyPeriodePaie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyPeriodePaie we want to update
     *   }
     * })
     */
    upsert<T extends CompanyPeriodePaieUpsertArgs>(args: SelectSubset<T, CompanyPeriodePaieUpsertArgs<ExtArgs>>): Prisma__CompanyPeriodePaieClient<$Result.GetResult<Prisma.$CompanyPeriodePaiePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyPeriodePaies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPeriodePaieCountArgs} args - Arguments to filter CompanyPeriodePaies to count.
     * @example
     * // Count the number of CompanyPeriodePaies
     * const count = await prisma.companyPeriodePaie.count({
     *   where: {
     *     // ... the filter for the CompanyPeriodePaies we want to count
     *   }
     * })
    **/
    count<T extends CompanyPeriodePaieCountArgs>(
      args?: Subset<T, CompanyPeriodePaieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyPeriodePaieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyPeriodePaie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPeriodePaieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyPeriodePaieAggregateArgs>(args: Subset<T, CompanyPeriodePaieAggregateArgs>): Prisma.PrismaPromise<GetCompanyPeriodePaieAggregateType<T>>

    /**
     * Group by CompanyPeriodePaie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyPeriodePaieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyPeriodePaieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyPeriodePaieGroupByArgs['orderBy'] }
        : { orderBy?: CompanyPeriodePaieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyPeriodePaieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyPeriodePaieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyPeriodePaie model
   */
  readonly fields: CompanyPeriodePaieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyPeriodePaie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyPeriodePaieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payRuns<T extends CompanyPeriodePaie$payRunsArgs<ExtArgs> = {}>(args?: Subset<T, CompanyPeriodePaie$payRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyPeriodePaie model
   */
  interface CompanyPeriodePaieFieldRefs {
    readonly id: FieldRef<"CompanyPeriodePaie", 'Int'>
    readonly nom: FieldRef<"CompanyPeriodePaie", 'String'>
    readonly dateDebut: FieldRef<"CompanyPeriodePaie", 'DateTime'>
    readonly dateFin: FieldRef<"CompanyPeriodePaie", 'DateTime'>
    readonly estCloturee: FieldRef<"CompanyPeriodePaie", 'Boolean'>
    readonly dateReglement: FieldRef<"CompanyPeriodePaie", 'DateTime'>
    readonly notes: FieldRef<"CompanyPeriodePaie", 'String'>
    readonly metadata: FieldRef<"CompanyPeriodePaie", 'Json'>
    readonly entrepriseId: FieldRef<"CompanyPeriodePaie", 'Int'>
    readonly creeLe: FieldRef<"CompanyPeriodePaie", 'DateTime'>
    readonly modifieLe: FieldRef<"CompanyPeriodePaie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyPeriodePaie findUnique
   */
  export type CompanyPeriodePaieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPeriodePaie to fetch.
     */
    where: CompanyPeriodePaieWhereUniqueInput
  }

  /**
   * CompanyPeriodePaie findUniqueOrThrow
   */
  export type CompanyPeriodePaieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPeriodePaie to fetch.
     */
    where: CompanyPeriodePaieWhereUniqueInput
  }

  /**
   * CompanyPeriodePaie findFirst
   */
  export type CompanyPeriodePaieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPeriodePaie to fetch.
     */
    where?: CompanyPeriodePaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPeriodePaies to fetch.
     */
    orderBy?: CompanyPeriodePaieOrderByWithRelationInput | CompanyPeriodePaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPeriodePaies.
     */
    cursor?: CompanyPeriodePaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPeriodePaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPeriodePaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPeriodePaies.
     */
    distinct?: CompanyPeriodePaieScalarFieldEnum | CompanyPeriodePaieScalarFieldEnum[]
  }

  /**
   * CompanyPeriodePaie findFirstOrThrow
   */
  export type CompanyPeriodePaieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPeriodePaie to fetch.
     */
    where?: CompanyPeriodePaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPeriodePaies to fetch.
     */
    orderBy?: CompanyPeriodePaieOrderByWithRelationInput | CompanyPeriodePaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyPeriodePaies.
     */
    cursor?: CompanyPeriodePaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPeriodePaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPeriodePaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyPeriodePaies.
     */
    distinct?: CompanyPeriodePaieScalarFieldEnum | CompanyPeriodePaieScalarFieldEnum[]
  }

  /**
   * CompanyPeriodePaie findMany
   */
  export type CompanyPeriodePaieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyPeriodePaies to fetch.
     */
    where?: CompanyPeriodePaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyPeriodePaies to fetch.
     */
    orderBy?: CompanyPeriodePaieOrderByWithRelationInput | CompanyPeriodePaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyPeriodePaies.
     */
    cursor?: CompanyPeriodePaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyPeriodePaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyPeriodePaies.
     */
    skip?: number
    distinct?: CompanyPeriodePaieScalarFieldEnum | CompanyPeriodePaieScalarFieldEnum[]
  }

  /**
   * CompanyPeriodePaie create
   */
  export type CompanyPeriodePaieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyPeriodePaie.
     */
    data: XOR<CompanyPeriodePaieCreateInput, CompanyPeriodePaieUncheckedCreateInput>
  }

  /**
   * CompanyPeriodePaie createMany
   */
  export type CompanyPeriodePaieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyPeriodePaies.
     */
    data: CompanyPeriodePaieCreateManyInput | CompanyPeriodePaieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyPeriodePaie update
   */
  export type CompanyPeriodePaieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyPeriodePaie.
     */
    data: XOR<CompanyPeriodePaieUpdateInput, CompanyPeriodePaieUncheckedUpdateInput>
    /**
     * Choose, which CompanyPeriodePaie to update.
     */
    where: CompanyPeriodePaieWhereUniqueInput
  }

  /**
   * CompanyPeriodePaie updateMany
   */
  export type CompanyPeriodePaieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyPeriodePaies.
     */
    data: XOR<CompanyPeriodePaieUpdateManyMutationInput, CompanyPeriodePaieUncheckedUpdateManyInput>
    /**
     * Filter which CompanyPeriodePaies to update
     */
    where?: CompanyPeriodePaieWhereInput
    /**
     * Limit how many CompanyPeriodePaies to update.
     */
    limit?: number
  }

  /**
   * CompanyPeriodePaie upsert
   */
  export type CompanyPeriodePaieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyPeriodePaie to update in case it exists.
     */
    where: CompanyPeriodePaieWhereUniqueInput
    /**
     * In case the CompanyPeriodePaie found by the `where` argument doesn't exist, create a new CompanyPeriodePaie with this data.
     */
    create: XOR<CompanyPeriodePaieCreateInput, CompanyPeriodePaieUncheckedCreateInput>
    /**
     * In case the CompanyPeriodePaie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyPeriodePaieUpdateInput, CompanyPeriodePaieUncheckedUpdateInput>
  }

  /**
   * CompanyPeriodePaie delete
   */
  export type CompanyPeriodePaieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
    /**
     * Filter which CompanyPeriodePaie to delete.
     */
    where: CompanyPeriodePaieWhereUniqueInput
  }

  /**
   * CompanyPeriodePaie deleteMany
   */
  export type CompanyPeriodePaieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyPeriodePaies to delete
     */
    where?: CompanyPeriodePaieWhereInput
    /**
     * Limit how many CompanyPeriodePaies to delete.
     */
    limit?: number
  }

  /**
   * CompanyPeriodePaie.payRuns
   */
  export type CompanyPeriodePaie$payRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPayRun
     */
    select?: CompanyPayRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPayRun
     */
    omit?: CompanyPayRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPayRunInclude<ExtArgs> | null
    where?: CompanyPayRunWhereInput
    orderBy?: CompanyPayRunOrderByWithRelationInput | CompanyPayRunOrderByWithRelationInput[]
    cursor?: CompanyPayRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyPayRunScalarFieldEnum | CompanyPayRunScalarFieldEnum[]
  }

  /**
   * CompanyPeriodePaie without action
   */
  export type CompanyPeriodePaieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyPeriodePaie
     */
    select?: CompanyPeriodePaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyPeriodePaie
     */
    omit?: CompanyPeriodePaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyPeriodePaieInclude<ExtArgs> | null
  }


  /**
   * Model CompanyConfigurationPaie
   */

  export type AggregateCompanyConfigurationPaie = {
    _count: CompanyConfigurationPaieCountAggregateOutputType | null
    _avg: CompanyConfigurationPaieAvgAggregateOutputType | null
    _sum: CompanyConfigurationPaieSumAggregateOutputType | null
    _min: CompanyConfigurationPaieMinAggregateOutputType | null
    _max: CompanyConfigurationPaieMaxAggregateOutputType | null
  }

  export type CompanyConfigurationPaieAvgAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    jourPaie: number | null
    tauxChange: Decimal | null
  }

  export type CompanyConfigurationPaieSumAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    jourPaie: number | null
    tauxChange: Decimal | null
  }

  export type CompanyConfigurationPaieMinAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    jourPaie: number | null
    periodeCalcul: string | null
    regleArrondi: string | null
    deviseSecondaire: string | null
    tauxChange: Decimal | null
    modifieLe: Date | null
  }

  export type CompanyConfigurationPaieMaxAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    jourPaie: number | null
    periodeCalcul: string | null
    regleArrondi: string | null
    deviseSecondaire: string | null
    tauxChange: Decimal | null
    modifieLe: Date | null
  }

  export type CompanyConfigurationPaieCountAggregateOutputType = {
    id: number
    entrepriseId: number
    jourPaie: number
    periodeCalcul: number
    regleArrondi: number
    deviseSecondaire: number
    tauxChange: number
    formatNumeration: number
    regleValidation: number
    parametresCalcul: number
    modifieLe: number
    _all: number
  }


  export type CompanyConfigurationPaieAvgAggregateInputType = {
    id?: true
    entrepriseId?: true
    jourPaie?: true
    tauxChange?: true
  }

  export type CompanyConfigurationPaieSumAggregateInputType = {
    id?: true
    entrepriseId?: true
    jourPaie?: true
    tauxChange?: true
  }

  export type CompanyConfigurationPaieMinAggregateInputType = {
    id?: true
    entrepriseId?: true
    jourPaie?: true
    periodeCalcul?: true
    regleArrondi?: true
    deviseSecondaire?: true
    tauxChange?: true
    modifieLe?: true
  }

  export type CompanyConfigurationPaieMaxAggregateInputType = {
    id?: true
    entrepriseId?: true
    jourPaie?: true
    periodeCalcul?: true
    regleArrondi?: true
    deviseSecondaire?: true
    tauxChange?: true
    modifieLe?: true
  }

  export type CompanyConfigurationPaieCountAggregateInputType = {
    id?: true
    entrepriseId?: true
    jourPaie?: true
    periodeCalcul?: true
    regleArrondi?: true
    deviseSecondaire?: true
    tauxChange?: true
    formatNumeration?: true
    regleValidation?: true
    parametresCalcul?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyConfigurationPaieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyConfigurationPaie to aggregate.
     */
    where?: CompanyConfigurationPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyConfigurationPaies to fetch.
     */
    orderBy?: CompanyConfigurationPaieOrderByWithRelationInput | CompanyConfigurationPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyConfigurationPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyConfigurationPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyConfigurationPaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyConfigurationPaies
    **/
    _count?: true | CompanyConfigurationPaieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyConfigurationPaieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyConfigurationPaieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyConfigurationPaieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyConfigurationPaieMaxAggregateInputType
  }

  export type GetCompanyConfigurationPaieAggregateType<T extends CompanyConfigurationPaieAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyConfigurationPaie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyConfigurationPaie[P]>
      : GetScalarType<T[P], AggregateCompanyConfigurationPaie[P]>
  }




  export type CompanyConfigurationPaieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyConfigurationPaieWhereInput
    orderBy?: CompanyConfigurationPaieOrderByWithAggregationInput | CompanyConfigurationPaieOrderByWithAggregationInput[]
    by: CompanyConfigurationPaieScalarFieldEnum[] | CompanyConfigurationPaieScalarFieldEnum
    having?: CompanyConfigurationPaieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyConfigurationPaieCountAggregateInputType | true
    _avg?: CompanyConfigurationPaieAvgAggregateInputType
    _sum?: CompanyConfigurationPaieSumAggregateInputType
    _min?: CompanyConfigurationPaieMinAggregateInputType
    _max?: CompanyConfigurationPaieMaxAggregateInputType
  }

  export type CompanyConfigurationPaieGroupByOutputType = {
    id: number
    entrepriseId: number
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire: string | null
    tauxChange: Decimal | null
    formatNumeration: JsonValue
    regleValidation: JsonValue
    parametresCalcul: JsonValue
    modifieLe: Date
    _count: CompanyConfigurationPaieCountAggregateOutputType | null
    _avg: CompanyConfigurationPaieAvgAggregateOutputType | null
    _sum: CompanyConfigurationPaieSumAggregateOutputType | null
    _min: CompanyConfigurationPaieMinAggregateOutputType | null
    _max: CompanyConfigurationPaieMaxAggregateOutputType | null
  }

  type GetCompanyConfigurationPaieGroupByPayload<T extends CompanyConfigurationPaieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyConfigurationPaieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyConfigurationPaieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyConfigurationPaieGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyConfigurationPaieGroupByOutputType[P]>
        }
      >
    >


  export type CompanyConfigurationPaieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entrepriseId?: boolean
    jourPaie?: boolean
    periodeCalcul?: boolean
    regleArrondi?: boolean
    deviseSecondaire?: boolean
    tauxChange?: boolean
    formatNumeration?: boolean
    regleValidation?: boolean
    parametresCalcul?: boolean
    modifieLe?: boolean
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    reglesDeduction?: boolean | CompanyConfigurationPaie$reglesDeductionArgs<ExtArgs>
    _count?: boolean | CompanyConfigurationPaieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyConfigurationPaie"]>



  export type CompanyConfigurationPaieSelectScalar = {
    id?: boolean
    entrepriseId?: boolean
    jourPaie?: boolean
    periodeCalcul?: boolean
    regleArrondi?: boolean
    deviseSecondaire?: boolean
    tauxChange?: boolean
    formatNumeration?: boolean
    regleValidation?: boolean
    parametresCalcul?: boolean
    modifieLe?: boolean
  }

  export type CompanyConfigurationPaieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entrepriseId" | "jourPaie" | "periodeCalcul" | "regleArrondi" | "deviseSecondaire" | "tauxChange" | "formatNumeration" | "regleValidation" | "parametresCalcul" | "modifieLe", ExtArgs["result"]["companyConfigurationPaie"]>
  export type CompanyConfigurationPaieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
    reglesDeduction?: boolean | CompanyConfigurationPaie$reglesDeductionArgs<ExtArgs>
    _count?: boolean | CompanyConfigurationPaieCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CompanyConfigurationPaiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyConfigurationPaie"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
      reglesDeduction: Prisma.$CompanyRegleDeductionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entrepriseId: number
      jourPaie: number
      periodeCalcul: string
      regleArrondi: string
      deviseSecondaire: string | null
      tauxChange: Prisma.Decimal | null
      formatNumeration: Prisma.JsonValue
      regleValidation: Prisma.JsonValue
      parametresCalcul: Prisma.JsonValue
      modifieLe: Date
    }, ExtArgs["result"]["companyConfigurationPaie"]>
    composites: {}
  }

  type CompanyConfigurationPaieGetPayload<S extends boolean | null | undefined | CompanyConfigurationPaieDefaultArgs> = $Result.GetResult<Prisma.$CompanyConfigurationPaiePayload, S>

  type CompanyConfigurationPaieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyConfigurationPaieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyConfigurationPaieCountAggregateInputType | true
    }

  export interface CompanyConfigurationPaieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyConfigurationPaie'], meta: { name: 'CompanyConfigurationPaie' } }
    /**
     * Find zero or one CompanyConfigurationPaie that matches the filter.
     * @param {CompanyConfigurationPaieFindUniqueArgs} args - Arguments to find a CompanyConfigurationPaie
     * @example
     * // Get one CompanyConfigurationPaie
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyConfigurationPaieFindUniqueArgs>(args: SelectSubset<T, CompanyConfigurationPaieFindUniqueArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyConfigurationPaie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyConfigurationPaieFindUniqueOrThrowArgs} args - Arguments to find a CompanyConfigurationPaie
     * @example
     * // Get one CompanyConfigurationPaie
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyConfigurationPaieFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyConfigurationPaieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyConfigurationPaie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyConfigurationPaieFindFirstArgs} args - Arguments to find a CompanyConfigurationPaie
     * @example
     * // Get one CompanyConfigurationPaie
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyConfigurationPaieFindFirstArgs>(args?: SelectSubset<T, CompanyConfigurationPaieFindFirstArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyConfigurationPaie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyConfigurationPaieFindFirstOrThrowArgs} args - Arguments to find a CompanyConfigurationPaie
     * @example
     * // Get one CompanyConfigurationPaie
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyConfigurationPaieFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyConfigurationPaieFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyConfigurationPaies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyConfigurationPaieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyConfigurationPaies
     * const companyConfigurationPaies = await prisma.companyConfigurationPaie.findMany()
     * 
     * // Get first 10 CompanyConfigurationPaies
     * const companyConfigurationPaies = await prisma.companyConfigurationPaie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyConfigurationPaieWithIdOnly = await prisma.companyConfigurationPaie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyConfigurationPaieFindManyArgs>(args?: SelectSubset<T, CompanyConfigurationPaieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyConfigurationPaie.
     * @param {CompanyConfigurationPaieCreateArgs} args - Arguments to create a CompanyConfigurationPaie.
     * @example
     * // Create one CompanyConfigurationPaie
     * const CompanyConfigurationPaie = await prisma.companyConfigurationPaie.create({
     *   data: {
     *     // ... data to create a CompanyConfigurationPaie
     *   }
     * })
     * 
     */
    create<T extends CompanyConfigurationPaieCreateArgs>(args: SelectSubset<T, CompanyConfigurationPaieCreateArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyConfigurationPaies.
     * @param {CompanyConfigurationPaieCreateManyArgs} args - Arguments to create many CompanyConfigurationPaies.
     * @example
     * // Create many CompanyConfigurationPaies
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyConfigurationPaieCreateManyArgs>(args?: SelectSubset<T, CompanyConfigurationPaieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyConfigurationPaie.
     * @param {CompanyConfigurationPaieDeleteArgs} args - Arguments to delete one CompanyConfigurationPaie.
     * @example
     * // Delete one CompanyConfigurationPaie
     * const CompanyConfigurationPaie = await prisma.companyConfigurationPaie.delete({
     *   where: {
     *     // ... filter to delete one CompanyConfigurationPaie
     *   }
     * })
     * 
     */
    delete<T extends CompanyConfigurationPaieDeleteArgs>(args: SelectSubset<T, CompanyConfigurationPaieDeleteArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyConfigurationPaie.
     * @param {CompanyConfigurationPaieUpdateArgs} args - Arguments to update one CompanyConfigurationPaie.
     * @example
     * // Update one CompanyConfigurationPaie
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyConfigurationPaieUpdateArgs>(args: SelectSubset<T, CompanyConfigurationPaieUpdateArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyConfigurationPaies.
     * @param {CompanyConfigurationPaieDeleteManyArgs} args - Arguments to filter CompanyConfigurationPaies to delete.
     * @example
     * // Delete a few CompanyConfigurationPaies
     * const { count } = await prisma.companyConfigurationPaie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyConfigurationPaieDeleteManyArgs>(args?: SelectSubset<T, CompanyConfigurationPaieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyConfigurationPaies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyConfigurationPaieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyConfigurationPaies
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyConfigurationPaieUpdateManyArgs>(args: SelectSubset<T, CompanyConfigurationPaieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyConfigurationPaie.
     * @param {CompanyConfigurationPaieUpsertArgs} args - Arguments to update or create a CompanyConfigurationPaie.
     * @example
     * // Update or create a CompanyConfigurationPaie
     * const companyConfigurationPaie = await prisma.companyConfigurationPaie.upsert({
     *   create: {
     *     // ... data to create a CompanyConfigurationPaie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyConfigurationPaie we want to update
     *   }
     * })
     */
    upsert<T extends CompanyConfigurationPaieUpsertArgs>(args: SelectSubset<T, CompanyConfigurationPaieUpsertArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyConfigurationPaies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyConfigurationPaieCountArgs} args - Arguments to filter CompanyConfigurationPaies to count.
     * @example
     * // Count the number of CompanyConfigurationPaies
     * const count = await prisma.companyConfigurationPaie.count({
     *   where: {
     *     // ... the filter for the CompanyConfigurationPaies we want to count
     *   }
     * })
    **/
    count<T extends CompanyConfigurationPaieCountArgs>(
      args?: Subset<T, CompanyConfigurationPaieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyConfigurationPaieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyConfigurationPaie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyConfigurationPaieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyConfigurationPaieAggregateArgs>(args: Subset<T, CompanyConfigurationPaieAggregateArgs>): Prisma.PrismaPromise<GetCompanyConfigurationPaieAggregateType<T>>

    /**
     * Group by CompanyConfigurationPaie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyConfigurationPaieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyConfigurationPaieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyConfigurationPaieGroupByArgs['orderBy'] }
        : { orderBy?: CompanyConfigurationPaieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyConfigurationPaieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyConfigurationPaieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyConfigurationPaie model
   */
  readonly fields: CompanyConfigurationPaieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyConfigurationPaie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyConfigurationPaieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reglesDeduction<T extends CompanyConfigurationPaie$reglesDeductionArgs<ExtArgs> = {}>(args?: Subset<T, CompanyConfigurationPaie$reglesDeductionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyConfigurationPaie model
   */
  interface CompanyConfigurationPaieFieldRefs {
    readonly id: FieldRef<"CompanyConfigurationPaie", 'Int'>
    readonly entrepriseId: FieldRef<"CompanyConfigurationPaie", 'Int'>
    readonly jourPaie: FieldRef<"CompanyConfigurationPaie", 'Int'>
    readonly periodeCalcul: FieldRef<"CompanyConfigurationPaie", 'String'>
    readonly regleArrondi: FieldRef<"CompanyConfigurationPaie", 'String'>
    readonly deviseSecondaire: FieldRef<"CompanyConfigurationPaie", 'String'>
    readonly tauxChange: FieldRef<"CompanyConfigurationPaie", 'Decimal'>
    readonly formatNumeration: FieldRef<"CompanyConfigurationPaie", 'Json'>
    readonly regleValidation: FieldRef<"CompanyConfigurationPaie", 'Json'>
    readonly parametresCalcul: FieldRef<"CompanyConfigurationPaie", 'Json'>
    readonly modifieLe: FieldRef<"CompanyConfigurationPaie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyConfigurationPaie findUnique
   */
  export type CompanyConfigurationPaieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyConfigurationPaie to fetch.
     */
    where: CompanyConfigurationPaieWhereUniqueInput
  }

  /**
   * CompanyConfigurationPaie findUniqueOrThrow
   */
  export type CompanyConfigurationPaieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyConfigurationPaie to fetch.
     */
    where: CompanyConfigurationPaieWhereUniqueInput
  }

  /**
   * CompanyConfigurationPaie findFirst
   */
  export type CompanyConfigurationPaieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyConfigurationPaie to fetch.
     */
    where?: CompanyConfigurationPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyConfigurationPaies to fetch.
     */
    orderBy?: CompanyConfigurationPaieOrderByWithRelationInput | CompanyConfigurationPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyConfigurationPaies.
     */
    cursor?: CompanyConfigurationPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyConfigurationPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyConfigurationPaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyConfigurationPaies.
     */
    distinct?: CompanyConfigurationPaieScalarFieldEnum | CompanyConfigurationPaieScalarFieldEnum[]
  }

  /**
   * CompanyConfigurationPaie findFirstOrThrow
   */
  export type CompanyConfigurationPaieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyConfigurationPaie to fetch.
     */
    where?: CompanyConfigurationPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyConfigurationPaies to fetch.
     */
    orderBy?: CompanyConfigurationPaieOrderByWithRelationInput | CompanyConfigurationPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyConfigurationPaies.
     */
    cursor?: CompanyConfigurationPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyConfigurationPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyConfigurationPaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyConfigurationPaies.
     */
    distinct?: CompanyConfigurationPaieScalarFieldEnum | CompanyConfigurationPaieScalarFieldEnum[]
  }

  /**
   * CompanyConfigurationPaie findMany
   */
  export type CompanyConfigurationPaieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * Filter, which CompanyConfigurationPaies to fetch.
     */
    where?: CompanyConfigurationPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyConfigurationPaies to fetch.
     */
    orderBy?: CompanyConfigurationPaieOrderByWithRelationInput | CompanyConfigurationPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyConfigurationPaies.
     */
    cursor?: CompanyConfigurationPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyConfigurationPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyConfigurationPaies.
     */
    skip?: number
    distinct?: CompanyConfigurationPaieScalarFieldEnum | CompanyConfigurationPaieScalarFieldEnum[]
  }

  /**
   * CompanyConfigurationPaie create
   */
  export type CompanyConfigurationPaieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyConfigurationPaie.
     */
    data: XOR<CompanyConfigurationPaieCreateInput, CompanyConfigurationPaieUncheckedCreateInput>
  }

  /**
   * CompanyConfigurationPaie createMany
   */
  export type CompanyConfigurationPaieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyConfigurationPaies.
     */
    data: CompanyConfigurationPaieCreateManyInput | CompanyConfigurationPaieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyConfigurationPaie update
   */
  export type CompanyConfigurationPaieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyConfigurationPaie.
     */
    data: XOR<CompanyConfigurationPaieUpdateInput, CompanyConfigurationPaieUncheckedUpdateInput>
    /**
     * Choose, which CompanyConfigurationPaie to update.
     */
    where: CompanyConfigurationPaieWhereUniqueInput
  }

  /**
   * CompanyConfigurationPaie updateMany
   */
  export type CompanyConfigurationPaieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyConfigurationPaies.
     */
    data: XOR<CompanyConfigurationPaieUpdateManyMutationInput, CompanyConfigurationPaieUncheckedUpdateManyInput>
    /**
     * Filter which CompanyConfigurationPaies to update
     */
    where?: CompanyConfigurationPaieWhereInput
    /**
     * Limit how many CompanyConfigurationPaies to update.
     */
    limit?: number
  }

  /**
   * CompanyConfigurationPaie upsert
   */
  export type CompanyConfigurationPaieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyConfigurationPaie to update in case it exists.
     */
    where: CompanyConfigurationPaieWhereUniqueInput
    /**
     * In case the CompanyConfigurationPaie found by the `where` argument doesn't exist, create a new CompanyConfigurationPaie with this data.
     */
    create: XOR<CompanyConfigurationPaieCreateInput, CompanyConfigurationPaieUncheckedCreateInput>
    /**
     * In case the CompanyConfigurationPaie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyConfigurationPaieUpdateInput, CompanyConfigurationPaieUncheckedUpdateInput>
  }

  /**
   * CompanyConfigurationPaie delete
   */
  export type CompanyConfigurationPaieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
    /**
     * Filter which CompanyConfigurationPaie to delete.
     */
    where: CompanyConfigurationPaieWhereUniqueInput
  }

  /**
   * CompanyConfigurationPaie deleteMany
   */
  export type CompanyConfigurationPaieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyConfigurationPaies to delete
     */
    where?: CompanyConfigurationPaieWhereInput
    /**
     * Limit how many CompanyConfigurationPaies to delete.
     */
    limit?: number
  }

  /**
   * CompanyConfigurationPaie.reglesDeduction
   */
  export type CompanyConfigurationPaie$reglesDeductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    where?: CompanyRegleDeductionWhereInput
    orderBy?: CompanyRegleDeductionOrderByWithRelationInput | CompanyRegleDeductionOrderByWithRelationInput[]
    cursor?: CompanyRegleDeductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyRegleDeductionScalarFieldEnum | CompanyRegleDeductionScalarFieldEnum[]
  }

  /**
   * CompanyConfigurationPaie without action
   */
  export type CompanyConfigurationPaieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyConfigurationPaie
     */
    select?: CompanyConfigurationPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyConfigurationPaie
     */
    omit?: CompanyConfigurationPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyConfigurationPaieInclude<ExtArgs> | null
  }


  /**
   * Model CompanyHistoriqueSalaire
   */

  export type AggregateCompanyHistoriqueSalaire = {
    _count: CompanyHistoriqueSalaireCountAggregateOutputType | null
    _avg: CompanyHistoriqueSalaireAvgAggregateOutputType | null
    _sum: CompanyHistoriqueSalaireSumAggregateOutputType | null
    _min: CompanyHistoriqueSalaireMinAggregateOutputType | null
    _max: CompanyHistoriqueSalaireMaxAggregateOutputType | null
  }

  export type CompanyHistoriqueSalaireAvgAggregateOutputType = {
    id: number | null
    employeId: number | null
    ancienSalaire: Decimal | null
    nouveauSalaire: Decimal | null
    modifiePar: number | null
  }

  export type CompanyHistoriqueSalaireSumAggregateOutputType = {
    id: number | null
    employeId: number | null
    ancienSalaire: Decimal | null
    nouveauSalaire: Decimal | null
    modifiePar: number | null
  }

  export type CompanyHistoriqueSalaireMinAggregateOutputType = {
    id: number | null
    employeId: number | null
    ancienSalaire: Decimal | null
    nouveauSalaire: Decimal | null
    dateEffet: Date | null
    motif: string | null
    notes: string | null
    modifiePar: number | null
    creeLe: Date | null
  }

  export type CompanyHistoriqueSalaireMaxAggregateOutputType = {
    id: number | null
    employeId: number | null
    ancienSalaire: Decimal | null
    nouveauSalaire: Decimal | null
    dateEffet: Date | null
    motif: string | null
    notes: string | null
    modifiePar: number | null
    creeLe: Date | null
  }

  export type CompanyHistoriqueSalaireCountAggregateOutputType = {
    id: number
    employeId: number
    ancienSalaire: number
    nouveauSalaire: number
    dateEffet: number
    motif: number
    notes: number
    documents: number
    modifiePar: number
    creeLe: number
    _all: number
  }


  export type CompanyHistoriqueSalaireAvgAggregateInputType = {
    id?: true
    employeId?: true
    ancienSalaire?: true
    nouveauSalaire?: true
    modifiePar?: true
  }

  export type CompanyHistoriqueSalaireSumAggregateInputType = {
    id?: true
    employeId?: true
    ancienSalaire?: true
    nouveauSalaire?: true
    modifiePar?: true
  }

  export type CompanyHistoriqueSalaireMinAggregateInputType = {
    id?: true
    employeId?: true
    ancienSalaire?: true
    nouveauSalaire?: true
    dateEffet?: true
    motif?: true
    notes?: true
    modifiePar?: true
    creeLe?: true
  }

  export type CompanyHistoriqueSalaireMaxAggregateInputType = {
    id?: true
    employeId?: true
    ancienSalaire?: true
    nouveauSalaire?: true
    dateEffet?: true
    motif?: true
    notes?: true
    modifiePar?: true
    creeLe?: true
  }

  export type CompanyHistoriqueSalaireCountAggregateInputType = {
    id?: true
    employeId?: true
    ancienSalaire?: true
    nouveauSalaire?: true
    dateEffet?: true
    motif?: true
    notes?: true
    documents?: true
    modifiePar?: true
    creeLe?: true
    _all?: true
  }

  export type CompanyHistoriqueSalaireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyHistoriqueSalaire to aggregate.
     */
    where?: CompanyHistoriqueSalaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHistoriqueSalaires to fetch.
     */
    orderBy?: CompanyHistoriqueSalaireOrderByWithRelationInput | CompanyHistoriqueSalaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyHistoriqueSalaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHistoriqueSalaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHistoriqueSalaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyHistoriqueSalaires
    **/
    _count?: true | CompanyHistoriqueSalaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyHistoriqueSalaireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyHistoriqueSalaireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyHistoriqueSalaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyHistoriqueSalaireMaxAggregateInputType
  }

  export type GetCompanyHistoriqueSalaireAggregateType<T extends CompanyHistoriqueSalaireAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyHistoriqueSalaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyHistoriqueSalaire[P]>
      : GetScalarType<T[P], AggregateCompanyHistoriqueSalaire[P]>
  }




  export type CompanyHistoriqueSalaireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyHistoriqueSalaireWhereInput
    orderBy?: CompanyHistoriqueSalaireOrderByWithAggregationInput | CompanyHistoriqueSalaireOrderByWithAggregationInput[]
    by: CompanyHistoriqueSalaireScalarFieldEnum[] | CompanyHistoriqueSalaireScalarFieldEnum
    having?: CompanyHistoriqueSalaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyHistoriqueSalaireCountAggregateInputType | true
    _avg?: CompanyHistoriqueSalaireAvgAggregateInputType
    _sum?: CompanyHistoriqueSalaireSumAggregateInputType
    _min?: CompanyHistoriqueSalaireMinAggregateInputType
    _max?: CompanyHistoriqueSalaireMaxAggregateInputType
  }

  export type CompanyHistoriqueSalaireGroupByOutputType = {
    id: number
    employeId: number
    ancienSalaire: Decimal
    nouveauSalaire: Decimal
    dateEffet: Date
    motif: string
    notes: string | null
    documents: JsonValue | null
    modifiePar: number
    creeLe: Date
    _count: CompanyHistoriqueSalaireCountAggregateOutputType | null
    _avg: CompanyHistoriqueSalaireAvgAggregateOutputType | null
    _sum: CompanyHistoriqueSalaireSumAggregateOutputType | null
    _min: CompanyHistoriqueSalaireMinAggregateOutputType | null
    _max: CompanyHistoriqueSalaireMaxAggregateOutputType | null
  }

  type GetCompanyHistoriqueSalaireGroupByPayload<T extends CompanyHistoriqueSalaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyHistoriqueSalaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyHistoriqueSalaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyHistoriqueSalaireGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyHistoriqueSalaireGroupByOutputType[P]>
        }
      >
    >


  export type CompanyHistoriqueSalaireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    ancienSalaire?: boolean
    nouveauSalaire?: boolean
    dateEffet?: boolean
    motif?: boolean
    notes?: boolean
    documents?: boolean
    modifiePar?: boolean
    creeLe?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    modifier?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyHistoriqueSalaire"]>



  export type CompanyHistoriqueSalaireSelectScalar = {
    id?: boolean
    employeId?: boolean
    ancienSalaire?: boolean
    nouveauSalaire?: boolean
    dateEffet?: boolean
    motif?: boolean
    notes?: boolean
    documents?: boolean
    modifiePar?: boolean
    creeLe?: boolean
  }

  export type CompanyHistoriqueSalaireOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeId" | "ancienSalaire" | "nouveauSalaire" | "dateEffet" | "motif" | "notes" | "documents" | "modifiePar" | "creeLe", ExtArgs["result"]["companyHistoriqueSalaire"]>
  export type CompanyHistoriqueSalaireInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    modifier?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyHistoriqueSalairePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyHistoriqueSalaire"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      modifier: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeId: number
      ancienSalaire: Prisma.Decimal
      nouveauSalaire: Prisma.Decimal
      dateEffet: Date
      motif: string
      notes: string | null
      documents: Prisma.JsonValue | null
      modifiePar: number
      creeLe: Date
    }, ExtArgs["result"]["companyHistoriqueSalaire"]>
    composites: {}
  }

  type CompanyHistoriqueSalaireGetPayload<S extends boolean | null | undefined | CompanyHistoriqueSalaireDefaultArgs> = $Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload, S>

  type CompanyHistoriqueSalaireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyHistoriqueSalaireFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyHistoriqueSalaireCountAggregateInputType | true
    }

  export interface CompanyHistoriqueSalaireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyHistoriqueSalaire'], meta: { name: 'CompanyHistoriqueSalaire' } }
    /**
     * Find zero or one CompanyHistoriqueSalaire that matches the filter.
     * @param {CompanyHistoriqueSalaireFindUniqueArgs} args - Arguments to find a CompanyHistoriqueSalaire
     * @example
     * // Get one CompanyHistoriqueSalaire
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyHistoriqueSalaireFindUniqueArgs>(args: SelectSubset<T, CompanyHistoriqueSalaireFindUniqueArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyHistoriqueSalaire that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyHistoriqueSalaireFindUniqueOrThrowArgs} args - Arguments to find a CompanyHistoriqueSalaire
     * @example
     * // Get one CompanyHistoriqueSalaire
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyHistoriqueSalaireFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyHistoriqueSalaireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyHistoriqueSalaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHistoriqueSalaireFindFirstArgs} args - Arguments to find a CompanyHistoriqueSalaire
     * @example
     * // Get one CompanyHistoriqueSalaire
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyHistoriqueSalaireFindFirstArgs>(args?: SelectSubset<T, CompanyHistoriqueSalaireFindFirstArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyHistoriqueSalaire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHistoriqueSalaireFindFirstOrThrowArgs} args - Arguments to find a CompanyHistoriqueSalaire
     * @example
     * // Get one CompanyHistoriqueSalaire
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyHistoriqueSalaireFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyHistoriqueSalaireFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyHistoriqueSalaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHistoriqueSalaireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyHistoriqueSalaires
     * const companyHistoriqueSalaires = await prisma.companyHistoriqueSalaire.findMany()
     * 
     * // Get first 10 CompanyHistoriqueSalaires
     * const companyHistoriqueSalaires = await prisma.companyHistoriqueSalaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyHistoriqueSalaireWithIdOnly = await prisma.companyHistoriqueSalaire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyHistoriqueSalaireFindManyArgs>(args?: SelectSubset<T, CompanyHistoriqueSalaireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyHistoriqueSalaire.
     * @param {CompanyHistoriqueSalaireCreateArgs} args - Arguments to create a CompanyHistoriqueSalaire.
     * @example
     * // Create one CompanyHistoriqueSalaire
     * const CompanyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.create({
     *   data: {
     *     // ... data to create a CompanyHistoriqueSalaire
     *   }
     * })
     * 
     */
    create<T extends CompanyHistoriqueSalaireCreateArgs>(args: SelectSubset<T, CompanyHistoriqueSalaireCreateArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyHistoriqueSalaires.
     * @param {CompanyHistoriqueSalaireCreateManyArgs} args - Arguments to create many CompanyHistoriqueSalaires.
     * @example
     * // Create many CompanyHistoriqueSalaires
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyHistoriqueSalaireCreateManyArgs>(args?: SelectSubset<T, CompanyHistoriqueSalaireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyHistoriqueSalaire.
     * @param {CompanyHistoriqueSalaireDeleteArgs} args - Arguments to delete one CompanyHistoriqueSalaire.
     * @example
     * // Delete one CompanyHistoriqueSalaire
     * const CompanyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.delete({
     *   where: {
     *     // ... filter to delete one CompanyHistoriqueSalaire
     *   }
     * })
     * 
     */
    delete<T extends CompanyHistoriqueSalaireDeleteArgs>(args: SelectSubset<T, CompanyHistoriqueSalaireDeleteArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyHistoriqueSalaire.
     * @param {CompanyHistoriqueSalaireUpdateArgs} args - Arguments to update one CompanyHistoriqueSalaire.
     * @example
     * // Update one CompanyHistoriqueSalaire
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyHistoriqueSalaireUpdateArgs>(args: SelectSubset<T, CompanyHistoriqueSalaireUpdateArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyHistoriqueSalaires.
     * @param {CompanyHistoriqueSalaireDeleteManyArgs} args - Arguments to filter CompanyHistoriqueSalaires to delete.
     * @example
     * // Delete a few CompanyHistoriqueSalaires
     * const { count } = await prisma.companyHistoriqueSalaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyHistoriqueSalaireDeleteManyArgs>(args?: SelectSubset<T, CompanyHistoriqueSalaireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyHistoriqueSalaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHistoriqueSalaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyHistoriqueSalaires
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyHistoriqueSalaireUpdateManyArgs>(args: SelectSubset<T, CompanyHistoriqueSalaireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyHistoriqueSalaire.
     * @param {CompanyHistoriqueSalaireUpsertArgs} args - Arguments to update or create a CompanyHistoriqueSalaire.
     * @example
     * // Update or create a CompanyHistoriqueSalaire
     * const companyHistoriqueSalaire = await prisma.companyHistoriqueSalaire.upsert({
     *   create: {
     *     // ... data to create a CompanyHistoriqueSalaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyHistoriqueSalaire we want to update
     *   }
     * })
     */
    upsert<T extends CompanyHistoriqueSalaireUpsertArgs>(args: SelectSubset<T, CompanyHistoriqueSalaireUpsertArgs<ExtArgs>>): Prisma__CompanyHistoriqueSalaireClient<$Result.GetResult<Prisma.$CompanyHistoriqueSalairePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyHistoriqueSalaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHistoriqueSalaireCountArgs} args - Arguments to filter CompanyHistoriqueSalaires to count.
     * @example
     * // Count the number of CompanyHistoriqueSalaires
     * const count = await prisma.companyHistoriqueSalaire.count({
     *   where: {
     *     // ... the filter for the CompanyHistoriqueSalaires we want to count
     *   }
     * })
    **/
    count<T extends CompanyHistoriqueSalaireCountArgs>(
      args?: Subset<T, CompanyHistoriqueSalaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyHistoriqueSalaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyHistoriqueSalaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHistoriqueSalaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyHistoriqueSalaireAggregateArgs>(args: Subset<T, CompanyHistoriqueSalaireAggregateArgs>): Prisma.PrismaPromise<GetCompanyHistoriqueSalaireAggregateType<T>>

    /**
     * Group by CompanyHistoriqueSalaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyHistoriqueSalaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyHistoriqueSalaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyHistoriqueSalaireGroupByArgs['orderBy'] }
        : { orderBy?: CompanyHistoriqueSalaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyHistoriqueSalaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyHistoriqueSalaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyHistoriqueSalaire model
   */
  readonly fields: CompanyHistoriqueSalaireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyHistoriqueSalaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyHistoriqueSalaireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modifier<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyHistoriqueSalaire model
   */
  interface CompanyHistoriqueSalaireFieldRefs {
    readonly id: FieldRef<"CompanyHistoriqueSalaire", 'Int'>
    readonly employeId: FieldRef<"CompanyHistoriqueSalaire", 'Int'>
    readonly ancienSalaire: FieldRef<"CompanyHistoriqueSalaire", 'Decimal'>
    readonly nouveauSalaire: FieldRef<"CompanyHistoriqueSalaire", 'Decimal'>
    readonly dateEffet: FieldRef<"CompanyHistoriqueSalaire", 'DateTime'>
    readonly motif: FieldRef<"CompanyHistoriqueSalaire", 'String'>
    readonly notes: FieldRef<"CompanyHistoriqueSalaire", 'String'>
    readonly documents: FieldRef<"CompanyHistoriqueSalaire", 'Json'>
    readonly modifiePar: FieldRef<"CompanyHistoriqueSalaire", 'Int'>
    readonly creeLe: FieldRef<"CompanyHistoriqueSalaire", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyHistoriqueSalaire findUnique
   */
  export type CompanyHistoriqueSalaireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * Filter, which CompanyHistoriqueSalaire to fetch.
     */
    where: CompanyHistoriqueSalaireWhereUniqueInput
  }

  /**
   * CompanyHistoriqueSalaire findUniqueOrThrow
   */
  export type CompanyHistoriqueSalaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * Filter, which CompanyHistoriqueSalaire to fetch.
     */
    where: CompanyHistoriqueSalaireWhereUniqueInput
  }

  /**
   * CompanyHistoriqueSalaire findFirst
   */
  export type CompanyHistoriqueSalaireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * Filter, which CompanyHistoriqueSalaire to fetch.
     */
    where?: CompanyHistoriqueSalaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHistoriqueSalaires to fetch.
     */
    orderBy?: CompanyHistoriqueSalaireOrderByWithRelationInput | CompanyHistoriqueSalaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyHistoriqueSalaires.
     */
    cursor?: CompanyHistoriqueSalaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHistoriqueSalaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHistoriqueSalaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyHistoriqueSalaires.
     */
    distinct?: CompanyHistoriqueSalaireScalarFieldEnum | CompanyHistoriqueSalaireScalarFieldEnum[]
  }

  /**
   * CompanyHistoriqueSalaire findFirstOrThrow
   */
  export type CompanyHistoriqueSalaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * Filter, which CompanyHistoriqueSalaire to fetch.
     */
    where?: CompanyHistoriqueSalaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHistoriqueSalaires to fetch.
     */
    orderBy?: CompanyHistoriqueSalaireOrderByWithRelationInput | CompanyHistoriqueSalaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyHistoriqueSalaires.
     */
    cursor?: CompanyHistoriqueSalaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHistoriqueSalaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHistoriqueSalaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyHistoriqueSalaires.
     */
    distinct?: CompanyHistoriqueSalaireScalarFieldEnum | CompanyHistoriqueSalaireScalarFieldEnum[]
  }

  /**
   * CompanyHistoriqueSalaire findMany
   */
  export type CompanyHistoriqueSalaireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * Filter, which CompanyHistoriqueSalaires to fetch.
     */
    where?: CompanyHistoriqueSalaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyHistoriqueSalaires to fetch.
     */
    orderBy?: CompanyHistoriqueSalaireOrderByWithRelationInput | CompanyHistoriqueSalaireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyHistoriqueSalaires.
     */
    cursor?: CompanyHistoriqueSalaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyHistoriqueSalaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyHistoriqueSalaires.
     */
    skip?: number
    distinct?: CompanyHistoriqueSalaireScalarFieldEnum | CompanyHistoriqueSalaireScalarFieldEnum[]
  }

  /**
   * CompanyHistoriqueSalaire create
   */
  export type CompanyHistoriqueSalaireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyHistoriqueSalaire.
     */
    data: XOR<CompanyHistoriqueSalaireCreateInput, CompanyHistoriqueSalaireUncheckedCreateInput>
  }

  /**
   * CompanyHistoriqueSalaire createMany
   */
  export type CompanyHistoriqueSalaireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyHistoriqueSalaires.
     */
    data: CompanyHistoriqueSalaireCreateManyInput | CompanyHistoriqueSalaireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyHistoriqueSalaire update
   */
  export type CompanyHistoriqueSalaireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyHistoriqueSalaire.
     */
    data: XOR<CompanyHistoriqueSalaireUpdateInput, CompanyHistoriqueSalaireUncheckedUpdateInput>
    /**
     * Choose, which CompanyHistoriqueSalaire to update.
     */
    where: CompanyHistoriqueSalaireWhereUniqueInput
  }

  /**
   * CompanyHistoriqueSalaire updateMany
   */
  export type CompanyHistoriqueSalaireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyHistoriqueSalaires.
     */
    data: XOR<CompanyHistoriqueSalaireUpdateManyMutationInput, CompanyHistoriqueSalaireUncheckedUpdateManyInput>
    /**
     * Filter which CompanyHistoriqueSalaires to update
     */
    where?: CompanyHistoriqueSalaireWhereInput
    /**
     * Limit how many CompanyHistoriqueSalaires to update.
     */
    limit?: number
  }

  /**
   * CompanyHistoriqueSalaire upsert
   */
  export type CompanyHistoriqueSalaireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyHistoriqueSalaire to update in case it exists.
     */
    where: CompanyHistoriqueSalaireWhereUniqueInput
    /**
     * In case the CompanyHistoriqueSalaire found by the `where` argument doesn't exist, create a new CompanyHistoriqueSalaire with this data.
     */
    create: XOR<CompanyHistoriqueSalaireCreateInput, CompanyHistoriqueSalaireUncheckedCreateInput>
    /**
     * In case the CompanyHistoriqueSalaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyHistoriqueSalaireUpdateInput, CompanyHistoriqueSalaireUncheckedUpdateInput>
  }

  /**
   * CompanyHistoriqueSalaire delete
   */
  export type CompanyHistoriqueSalaireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
    /**
     * Filter which CompanyHistoriqueSalaire to delete.
     */
    where: CompanyHistoriqueSalaireWhereUniqueInput
  }

  /**
   * CompanyHistoriqueSalaire deleteMany
   */
  export type CompanyHistoriqueSalaireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyHistoriqueSalaires to delete
     */
    where?: CompanyHistoriqueSalaireWhereInput
    /**
     * Limit how many CompanyHistoriqueSalaires to delete.
     */
    limit?: number
  }

  /**
   * CompanyHistoriqueSalaire without action
   */
  export type CompanyHistoriqueSalaireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyHistoriqueSalaire
     */
    select?: CompanyHistoriqueSalaireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyHistoriqueSalaire
     */
    omit?: CompanyHistoriqueSalaireOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyHistoriqueSalaireInclude<ExtArgs> | null
  }


  /**
   * Model CompanyRegleDeduction
   */

  export type AggregateCompanyRegleDeduction = {
    _count: CompanyRegleDeductionCountAggregateOutputType | null
    _avg: CompanyRegleDeductionAvgAggregateOutputType | null
    _sum: CompanyRegleDeductionSumAggregateOutputType | null
    _min: CompanyRegleDeductionMinAggregateOutputType | null
    _max: CompanyRegleDeductionMaxAggregateOutputType | null
  }

  export type CompanyRegleDeductionAvgAggregateOutputType = {
    id: number | null
    ordre: number | null
    configurationId: number | null
  }

  export type CompanyRegleDeductionSumAggregateOutputType = {
    id: number | null
    ordre: number | null
    configurationId: number | null
  }

  export type CompanyRegleDeductionMinAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    type: string | null
    formule: string | null
    estObligatoire: boolean | null
    ordre: number | null
    configurationId: number | null
    estActif: boolean | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyRegleDeductionMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    type: string | null
    formule: string | null
    estObligatoire: boolean | null
    ordre: number | null
    configurationId: number | null
    estActif: boolean | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type CompanyRegleDeductionCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    type: number
    formule: number
    conditionsApplication: number
    estObligatoire: number
    ordre: number
    configurationId: number
    estActif: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type CompanyRegleDeductionAvgAggregateInputType = {
    id?: true
    ordre?: true
    configurationId?: true
  }

  export type CompanyRegleDeductionSumAggregateInputType = {
    id?: true
    ordre?: true
    configurationId?: true
  }

  export type CompanyRegleDeductionMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    type?: true
    formule?: true
    estObligatoire?: true
    ordre?: true
    configurationId?: true
    estActif?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyRegleDeductionMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    type?: true
    formule?: true
    estObligatoire?: true
    ordre?: true
    configurationId?: true
    estActif?: true
    creeLe?: true
    modifieLe?: true
  }

  export type CompanyRegleDeductionCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    type?: true
    formule?: true
    conditionsApplication?: true
    estObligatoire?: true
    ordre?: true
    configurationId?: true
    estActif?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type CompanyRegleDeductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyRegleDeduction to aggregate.
     */
    where?: CompanyRegleDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRegleDeductions to fetch.
     */
    orderBy?: CompanyRegleDeductionOrderByWithRelationInput | CompanyRegleDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyRegleDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRegleDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRegleDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyRegleDeductions
    **/
    _count?: true | CompanyRegleDeductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyRegleDeductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyRegleDeductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyRegleDeductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyRegleDeductionMaxAggregateInputType
  }

  export type GetCompanyRegleDeductionAggregateType<T extends CompanyRegleDeductionAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyRegleDeduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyRegleDeduction[P]>
      : GetScalarType<T[P], AggregateCompanyRegleDeduction[P]>
  }




  export type CompanyRegleDeductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyRegleDeductionWhereInput
    orderBy?: CompanyRegleDeductionOrderByWithAggregationInput | CompanyRegleDeductionOrderByWithAggregationInput[]
    by: CompanyRegleDeductionScalarFieldEnum[] | CompanyRegleDeductionScalarFieldEnum
    having?: CompanyRegleDeductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyRegleDeductionCountAggregateInputType | true
    _avg?: CompanyRegleDeductionAvgAggregateInputType
    _sum?: CompanyRegleDeductionSumAggregateInputType
    _min?: CompanyRegleDeductionMinAggregateInputType
    _max?: CompanyRegleDeductionMaxAggregateInputType
  }

  export type CompanyRegleDeductionGroupByOutputType = {
    id: number
    nom: string
    description: string | null
    type: string
    formule: string
    conditionsApplication: JsonValue
    estObligatoire: boolean
    ordre: number
    configurationId: number
    estActif: boolean
    creeLe: Date
    modifieLe: Date
    _count: CompanyRegleDeductionCountAggregateOutputType | null
    _avg: CompanyRegleDeductionAvgAggregateOutputType | null
    _sum: CompanyRegleDeductionSumAggregateOutputType | null
    _min: CompanyRegleDeductionMinAggregateOutputType | null
    _max: CompanyRegleDeductionMaxAggregateOutputType | null
  }

  type GetCompanyRegleDeductionGroupByPayload<T extends CompanyRegleDeductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyRegleDeductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyRegleDeductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyRegleDeductionGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyRegleDeductionGroupByOutputType[P]>
        }
      >
    >


  export type CompanyRegleDeductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    type?: boolean
    formule?: boolean
    conditionsApplication?: boolean
    estObligatoire?: boolean
    ordre?: boolean
    configurationId?: boolean
    estActif?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    configuration?: boolean | CompanyConfigurationPaieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyRegleDeduction"]>



  export type CompanyRegleDeductionSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    type?: boolean
    formule?: boolean
    conditionsApplication?: boolean
    estObligatoire?: boolean
    ordre?: boolean
    configurationId?: boolean
    estActif?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type CompanyRegleDeductionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "description" | "type" | "formule" | "conditionsApplication" | "estObligatoire" | "ordre" | "configurationId" | "estActif" | "creeLe" | "modifieLe", ExtArgs["result"]["companyRegleDeduction"]>
  export type CompanyRegleDeductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    configuration?: boolean | CompanyConfigurationPaieDefaultArgs<ExtArgs>
  }

  export type $CompanyRegleDeductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyRegleDeduction"
    objects: {
      configuration: Prisma.$CompanyConfigurationPaiePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      description: string | null
      type: string
      formule: string
      conditionsApplication: Prisma.JsonValue
      estObligatoire: boolean
      ordre: number
      configurationId: number
      estActif: boolean
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["companyRegleDeduction"]>
    composites: {}
  }

  type CompanyRegleDeductionGetPayload<S extends boolean | null | undefined | CompanyRegleDeductionDefaultArgs> = $Result.GetResult<Prisma.$CompanyRegleDeductionPayload, S>

  type CompanyRegleDeductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyRegleDeductionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyRegleDeductionCountAggregateInputType | true
    }

  export interface CompanyRegleDeductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyRegleDeduction'], meta: { name: 'CompanyRegleDeduction' } }
    /**
     * Find zero or one CompanyRegleDeduction that matches the filter.
     * @param {CompanyRegleDeductionFindUniqueArgs} args - Arguments to find a CompanyRegleDeduction
     * @example
     * // Get one CompanyRegleDeduction
     * const companyRegleDeduction = await prisma.companyRegleDeduction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyRegleDeductionFindUniqueArgs>(args: SelectSubset<T, CompanyRegleDeductionFindUniqueArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyRegleDeduction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyRegleDeductionFindUniqueOrThrowArgs} args - Arguments to find a CompanyRegleDeduction
     * @example
     * // Get one CompanyRegleDeduction
     * const companyRegleDeduction = await prisma.companyRegleDeduction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyRegleDeductionFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyRegleDeductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyRegleDeduction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRegleDeductionFindFirstArgs} args - Arguments to find a CompanyRegleDeduction
     * @example
     * // Get one CompanyRegleDeduction
     * const companyRegleDeduction = await prisma.companyRegleDeduction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyRegleDeductionFindFirstArgs>(args?: SelectSubset<T, CompanyRegleDeductionFindFirstArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyRegleDeduction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRegleDeductionFindFirstOrThrowArgs} args - Arguments to find a CompanyRegleDeduction
     * @example
     * // Get one CompanyRegleDeduction
     * const companyRegleDeduction = await prisma.companyRegleDeduction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyRegleDeductionFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyRegleDeductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyRegleDeductions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRegleDeductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyRegleDeductions
     * const companyRegleDeductions = await prisma.companyRegleDeduction.findMany()
     * 
     * // Get first 10 CompanyRegleDeductions
     * const companyRegleDeductions = await prisma.companyRegleDeduction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyRegleDeductionWithIdOnly = await prisma.companyRegleDeduction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyRegleDeductionFindManyArgs>(args?: SelectSubset<T, CompanyRegleDeductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyRegleDeduction.
     * @param {CompanyRegleDeductionCreateArgs} args - Arguments to create a CompanyRegleDeduction.
     * @example
     * // Create one CompanyRegleDeduction
     * const CompanyRegleDeduction = await prisma.companyRegleDeduction.create({
     *   data: {
     *     // ... data to create a CompanyRegleDeduction
     *   }
     * })
     * 
     */
    create<T extends CompanyRegleDeductionCreateArgs>(args: SelectSubset<T, CompanyRegleDeductionCreateArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyRegleDeductions.
     * @param {CompanyRegleDeductionCreateManyArgs} args - Arguments to create many CompanyRegleDeductions.
     * @example
     * // Create many CompanyRegleDeductions
     * const companyRegleDeduction = await prisma.companyRegleDeduction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyRegleDeductionCreateManyArgs>(args?: SelectSubset<T, CompanyRegleDeductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyRegleDeduction.
     * @param {CompanyRegleDeductionDeleteArgs} args - Arguments to delete one CompanyRegleDeduction.
     * @example
     * // Delete one CompanyRegleDeduction
     * const CompanyRegleDeduction = await prisma.companyRegleDeduction.delete({
     *   where: {
     *     // ... filter to delete one CompanyRegleDeduction
     *   }
     * })
     * 
     */
    delete<T extends CompanyRegleDeductionDeleteArgs>(args: SelectSubset<T, CompanyRegleDeductionDeleteArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyRegleDeduction.
     * @param {CompanyRegleDeductionUpdateArgs} args - Arguments to update one CompanyRegleDeduction.
     * @example
     * // Update one CompanyRegleDeduction
     * const companyRegleDeduction = await prisma.companyRegleDeduction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyRegleDeductionUpdateArgs>(args: SelectSubset<T, CompanyRegleDeductionUpdateArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyRegleDeductions.
     * @param {CompanyRegleDeductionDeleteManyArgs} args - Arguments to filter CompanyRegleDeductions to delete.
     * @example
     * // Delete a few CompanyRegleDeductions
     * const { count } = await prisma.companyRegleDeduction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyRegleDeductionDeleteManyArgs>(args?: SelectSubset<T, CompanyRegleDeductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyRegleDeductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRegleDeductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyRegleDeductions
     * const companyRegleDeduction = await prisma.companyRegleDeduction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyRegleDeductionUpdateManyArgs>(args: SelectSubset<T, CompanyRegleDeductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyRegleDeduction.
     * @param {CompanyRegleDeductionUpsertArgs} args - Arguments to update or create a CompanyRegleDeduction.
     * @example
     * // Update or create a CompanyRegleDeduction
     * const companyRegleDeduction = await prisma.companyRegleDeduction.upsert({
     *   create: {
     *     // ... data to create a CompanyRegleDeduction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyRegleDeduction we want to update
     *   }
     * })
     */
    upsert<T extends CompanyRegleDeductionUpsertArgs>(args: SelectSubset<T, CompanyRegleDeductionUpsertArgs<ExtArgs>>): Prisma__CompanyRegleDeductionClient<$Result.GetResult<Prisma.$CompanyRegleDeductionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyRegleDeductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRegleDeductionCountArgs} args - Arguments to filter CompanyRegleDeductions to count.
     * @example
     * // Count the number of CompanyRegleDeductions
     * const count = await prisma.companyRegleDeduction.count({
     *   where: {
     *     // ... the filter for the CompanyRegleDeductions we want to count
     *   }
     * })
    **/
    count<T extends CompanyRegleDeductionCountArgs>(
      args?: Subset<T, CompanyRegleDeductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyRegleDeductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyRegleDeduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRegleDeductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyRegleDeductionAggregateArgs>(args: Subset<T, CompanyRegleDeductionAggregateArgs>): Prisma.PrismaPromise<GetCompanyRegleDeductionAggregateType<T>>

    /**
     * Group by CompanyRegleDeduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyRegleDeductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyRegleDeductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyRegleDeductionGroupByArgs['orderBy'] }
        : { orderBy?: CompanyRegleDeductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyRegleDeductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyRegleDeductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyRegleDeduction model
   */
  readonly fields: CompanyRegleDeductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyRegleDeduction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyRegleDeductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    configuration<T extends CompanyConfigurationPaieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyConfigurationPaieDefaultArgs<ExtArgs>>): Prisma__CompanyConfigurationPaieClient<$Result.GetResult<Prisma.$CompanyConfigurationPaiePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyRegleDeduction model
   */
  interface CompanyRegleDeductionFieldRefs {
    readonly id: FieldRef<"CompanyRegleDeduction", 'Int'>
    readonly nom: FieldRef<"CompanyRegleDeduction", 'String'>
    readonly description: FieldRef<"CompanyRegleDeduction", 'String'>
    readonly type: FieldRef<"CompanyRegleDeduction", 'String'>
    readonly formule: FieldRef<"CompanyRegleDeduction", 'String'>
    readonly conditionsApplication: FieldRef<"CompanyRegleDeduction", 'Json'>
    readonly estObligatoire: FieldRef<"CompanyRegleDeduction", 'Boolean'>
    readonly ordre: FieldRef<"CompanyRegleDeduction", 'Int'>
    readonly configurationId: FieldRef<"CompanyRegleDeduction", 'Int'>
    readonly estActif: FieldRef<"CompanyRegleDeduction", 'Boolean'>
    readonly creeLe: FieldRef<"CompanyRegleDeduction", 'DateTime'>
    readonly modifieLe: FieldRef<"CompanyRegleDeduction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyRegleDeduction findUnique
   */
  export type CompanyRegleDeductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRegleDeduction to fetch.
     */
    where: CompanyRegleDeductionWhereUniqueInput
  }

  /**
   * CompanyRegleDeduction findUniqueOrThrow
   */
  export type CompanyRegleDeductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRegleDeduction to fetch.
     */
    where: CompanyRegleDeductionWhereUniqueInput
  }

  /**
   * CompanyRegleDeduction findFirst
   */
  export type CompanyRegleDeductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRegleDeduction to fetch.
     */
    where?: CompanyRegleDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRegleDeductions to fetch.
     */
    orderBy?: CompanyRegleDeductionOrderByWithRelationInput | CompanyRegleDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyRegleDeductions.
     */
    cursor?: CompanyRegleDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRegleDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRegleDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyRegleDeductions.
     */
    distinct?: CompanyRegleDeductionScalarFieldEnum | CompanyRegleDeductionScalarFieldEnum[]
  }

  /**
   * CompanyRegleDeduction findFirstOrThrow
   */
  export type CompanyRegleDeductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRegleDeduction to fetch.
     */
    where?: CompanyRegleDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRegleDeductions to fetch.
     */
    orderBy?: CompanyRegleDeductionOrderByWithRelationInput | CompanyRegleDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyRegleDeductions.
     */
    cursor?: CompanyRegleDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRegleDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRegleDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyRegleDeductions.
     */
    distinct?: CompanyRegleDeductionScalarFieldEnum | CompanyRegleDeductionScalarFieldEnum[]
  }

  /**
   * CompanyRegleDeduction findMany
   */
  export type CompanyRegleDeductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * Filter, which CompanyRegleDeductions to fetch.
     */
    where?: CompanyRegleDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyRegleDeductions to fetch.
     */
    orderBy?: CompanyRegleDeductionOrderByWithRelationInput | CompanyRegleDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyRegleDeductions.
     */
    cursor?: CompanyRegleDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyRegleDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyRegleDeductions.
     */
    skip?: number
    distinct?: CompanyRegleDeductionScalarFieldEnum | CompanyRegleDeductionScalarFieldEnum[]
  }

  /**
   * CompanyRegleDeduction create
   */
  export type CompanyRegleDeductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyRegleDeduction.
     */
    data: XOR<CompanyRegleDeductionCreateInput, CompanyRegleDeductionUncheckedCreateInput>
  }

  /**
   * CompanyRegleDeduction createMany
   */
  export type CompanyRegleDeductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyRegleDeductions.
     */
    data: CompanyRegleDeductionCreateManyInput | CompanyRegleDeductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyRegleDeduction update
   */
  export type CompanyRegleDeductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyRegleDeduction.
     */
    data: XOR<CompanyRegleDeductionUpdateInput, CompanyRegleDeductionUncheckedUpdateInput>
    /**
     * Choose, which CompanyRegleDeduction to update.
     */
    where: CompanyRegleDeductionWhereUniqueInput
  }

  /**
   * CompanyRegleDeduction updateMany
   */
  export type CompanyRegleDeductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyRegleDeductions.
     */
    data: XOR<CompanyRegleDeductionUpdateManyMutationInput, CompanyRegleDeductionUncheckedUpdateManyInput>
    /**
     * Filter which CompanyRegleDeductions to update
     */
    where?: CompanyRegleDeductionWhereInput
    /**
     * Limit how many CompanyRegleDeductions to update.
     */
    limit?: number
  }

  /**
   * CompanyRegleDeduction upsert
   */
  export type CompanyRegleDeductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyRegleDeduction to update in case it exists.
     */
    where: CompanyRegleDeductionWhereUniqueInput
    /**
     * In case the CompanyRegleDeduction found by the `where` argument doesn't exist, create a new CompanyRegleDeduction with this data.
     */
    create: XOR<CompanyRegleDeductionCreateInput, CompanyRegleDeductionUncheckedCreateInput>
    /**
     * In case the CompanyRegleDeduction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyRegleDeductionUpdateInput, CompanyRegleDeductionUncheckedUpdateInput>
  }

  /**
   * CompanyRegleDeduction delete
   */
  export type CompanyRegleDeductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
    /**
     * Filter which CompanyRegleDeduction to delete.
     */
    where: CompanyRegleDeductionWhereUniqueInput
  }

  /**
   * CompanyRegleDeduction deleteMany
   */
  export type CompanyRegleDeductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyRegleDeductions to delete
     */
    where?: CompanyRegleDeductionWhereInput
    /**
     * Limit how many CompanyRegleDeductions to delete.
     */
    limit?: number
  }

  /**
   * CompanyRegleDeduction without action
   */
  export type CompanyRegleDeductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyRegleDeduction
     */
    select?: CompanyRegleDeductionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyRegleDeduction
     */
    omit?: CompanyRegleDeductionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyRegleDeductionInclude<ExtArgs> | null
  }


  /**
   * Model Pointage
   */

  export type AggregatePointage = {
    _count: PointageCountAggregateOutputType | null
    _avg: PointageAvgAggregateOutputType | null
    _sum: PointageSumAggregateOutputType | null
    _min: PointageMinAggregateOutputType | null
    _max: PointageMaxAggregateOutputType | null
  }

  export type PointageAvgAggregateOutputType = {
    id: number | null
    employeId: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    validePar: number | null
  }

  export type PointageSumAggregateOutputType = {
    id: number | null
    employeId: number | null
    latitude: Decimal | null
    longitude: Decimal | null
    validePar: number | null
  }

  export type PointageMinAggregateOutputType = {
    id: number | null
    employeId: number | null
    date: Date | null
    heureArrivee: Date | null
    heureDepart: Date | null
    statut: $Enums.StatutPointage | null
    typePointage: $Enums.TypePointage | null
    commentaire: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    ipAddress: string | null
    deviceInfo: string | null
    validePar: number | null
    dateValidation: Date | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type PointageMaxAggregateOutputType = {
    id: number | null
    employeId: number | null
    date: Date | null
    heureArrivee: Date | null
    heureDepart: Date | null
    statut: $Enums.StatutPointage | null
    typePointage: $Enums.TypePointage | null
    commentaire: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    ipAddress: string | null
    deviceInfo: string | null
    validePar: number | null
    dateValidation: Date | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type PointageCountAggregateOutputType = {
    id: number
    employeId: number
    date: number
    heureArrivee: number
    heureDepart: number
    statut: number
    typePointage: number
    commentaire: number
    latitude: number
    longitude: number
    ipAddress: number
    deviceInfo: number
    validePar: number
    dateValidation: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type PointageAvgAggregateInputType = {
    id?: true
    employeId?: true
    latitude?: true
    longitude?: true
    validePar?: true
  }

  export type PointageSumAggregateInputType = {
    id?: true
    employeId?: true
    latitude?: true
    longitude?: true
    validePar?: true
  }

  export type PointageMinAggregateInputType = {
    id?: true
    employeId?: true
    date?: true
    heureArrivee?: true
    heureDepart?: true
    statut?: true
    typePointage?: true
    commentaire?: true
    latitude?: true
    longitude?: true
    ipAddress?: true
    deviceInfo?: true
    validePar?: true
    dateValidation?: true
    creeLe?: true
    modifieLe?: true
  }

  export type PointageMaxAggregateInputType = {
    id?: true
    employeId?: true
    date?: true
    heureArrivee?: true
    heureDepart?: true
    statut?: true
    typePointage?: true
    commentaire?: true
    latitude?: true
    longitude?: true
    ipAddress?: true
    deviceInfo?: true
    validePar?: true
    dateValidation?: true
    creeLe?: true
    modifieLe?: true
  }

  export type PointageCountAggregateInputType = {
    id?: true
    employeId?: true
    date?: true
    heureArrivee?: true
    heureDepart?: true
    statut?: true
    typePointage?: true
    commentaire?: true
    latitude?: true
    longitude?: true
    ipAddress?: true
    deviceInfo?: true
    validePar?: true
    dateValidation?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type PointageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pointage to aggregate.
     */
    where?: PointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pointages to fetch.
     */
    orderBy?: PointageOrderByWithRelationInput | PointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pointages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pointages
    **/
    _count?: true | PointageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointageMaxAggregateInputType
  }

  export type GetPointageAggregateType<T extends PointageAggregateArgs> = {
        [P in keyof T & keyof AggregatePointage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointage[P]>
      : GetScalarType<T[P], AggregatePointage[P]>
  }




  export type PointageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointageWhereInput
    orderBy?: PointageOrderByWithAggregationInput | PointageOrderByWithAggregationInput[]
    by: PointageScalarFieldEnum[] | PointageScalarFieldEnum
    having?: PointageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointageCountAggregateInputType | true
    _avg?: PointageAvgAggregateInputType
    _sum?: PointageSumAggregateInputType
    _min?: PointageMinAggregateInputType
    _max?: PointageMaxAggregateInputType
  }

  export type PointageGroupByOutputType = {
    id: number
    employeId: number
    date: Date
    heureArrivee: Date | null
    heureDepart: Date | null
    statut: $Enums.StatutPointage
    typePointage: $Enums.TypePointage
    commentaire: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    ipAddress: string | null
    deviceInfo: string | null
    validePar: number | null
    dateValidation: Date | null
    creeLe: Date
    modifieLe: Date
    _count: PointageCountAggregateOutputType | null
    _avg: PointageAvgAggregateOutputType | null
    _sum: PointageSumAggregateOutputType | null
    _min: PointageMinAggregateOutputType | null
    _max: PointageMaxAggregateOutputType | null
  }

  type GetPointageGroupByPayload<T extends PointageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointageGroupByOutputType[P]>
            : GetScalarType<T[P], PointageGroupByOutputType[P]>
        }
      >
    >


  export type PointageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    date?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    statut?: boolean
    typePointage?: boolean
    commentaire?: boolean
    latitude?: boolean
    longitude?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    validePar?: boolean
    dateValidation?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    employe?: boolean | EmployeeDefaultArgs<ExtArgs>
    validateur?: boolean | Pointage$validateurArgs<ExtArgs>
  }, ExtArgs["result"]["pointage"]>



  export type PointageSelectScalar = {
    id?: boolean
    employeId?: boolean
    date?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    statut?: boolean
    typePointage?: boolean
    commentaire?: boolean
    latitude?: boolean
    longitude?: boolean
    ipAddress?: boolean
    deviceInfo?: boolean
    validePar?: boolean
    dateValidation?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type PointageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeId" | "date" | "heureArrivee" | "heureDepart" | "statut" | "typePointage" | "commentaire" | "latitude" | "longitude" | "ipAddress" | "deviceInfo" | "validePar" | "dateValidation" | "creeLe" | "modifieLe", ExtArgs["result"]["pointage"]>
  export type PointageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeeDefaultArgs<ExtArgs>
    validateur?: boolean | Pointage$validateurArgs<ExtArgs>
  }

  export type $PointagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pointage"
    objects: {
      employe: Prisma.$EmployeePayload<ExtArgs>
      validateur: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeId: number
      date: Date
      heureArrivee: Date | null
      heureDepart: Date | null
      statut: $Enums.StatutPointage
      typePointage: $Enums.TypePointage
      commentaire: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      ipAddress: string | null
      deviceInfo: string | null
      validePar: number | null
      dateValidation: Date | null
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["pointage"]>
    composites: {}
  }

  type PointageGetPayload<S extends boolean | null | undefined | PointageDefaultArgs> = $Result.GetResult<Prisma.$PointagePayload, S>

  type PointageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointageCountAggregateInputType | true
    }

  export interface PointageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pointage'], meta: { name: 'Pointage' } }
    /**
     * Find zero or one Pointage that matches the filter.
     * @param {PointageFindUniqueArgs} args - Arguments to find a Pointage
     * @example
     * // Get one Pointage
     * const pointage = await prisma.pointage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointageFindUniqueArgs>(args: SelectSubset<T, PointageFindUniqueArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pointage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointageFindUniqueOrThrowArgs} args - Arguments to find a Pointage
     * @example
     * // Get one Pointage
     * const pointage = await prisma.pointage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointageFindUniqueOrThrowArgs>(args: SelectSubset<T, PointageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pointage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointageFindFirstArgs} args - Arguments to find a Pointage
     * @example
     * // Get one Pointage
     * const pointage = await prisma.pointage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointageFindFirstArgs>(args?: SelectSubset<T, PointageFindFirstArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pointage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointageFindFirstOrThrowArgs} args - Arguments to find a Pointage
     * @example
     * // Get one Pointage
     * const pointage = await prisma.pointage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointageFindFirstOrThrowArgs>(args?: SelectSubset<T, PointageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pointages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pointages
     * const pointages = await prisma.pointage.findMany()
     * 
     * // Get first 10 Pointages
     * const pointages = await prisma.pointage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointageWithIdOnly = await prisma.pointage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointageFindManyArgs>(args?: SelectSubset<T, PointageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pointage.
     * @param {PointageCreateArgs} args - Arguments to create a Pointage.
     * @example
     * // Create one Pointage
     * const Pointage = await prisma.pointage.create({
     *   data: {
     *     // ... data to create a Pointage
     *   }
     * })
     * 
     */
    create<T extends PointageCreateArgs>(args: SelectSubset<T, PointageCreateArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pointages.
     * @param {PointageCreateManyArgs} args - Arguments to create many Pointages.
     * @example
     * // Create many Pointages
     * const pointage = await prisma.pointage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointageCreateManyArgs>(args?: SelectSubset<T, PointageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pointage.
     * @param {PointageDeleteArgs} args - Arguments to delete one Pointage.
     * @example
     * // Delete one Pointage
     * const Pointage = await prisma.pointage.delete({
     *   where: {
     *     // ... filter to delete one Pointage
     *   }
     * })
     * 
     */
    delete<T extends PointageDeleteArgs>(args: SelectSubset<T, PointageDeleteArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pointage.
     * @param {PointageUpdateArgs} args - Arguments to update one Pointage.
     * @example
     * // Update one Pointage
     * const pointage = await prisma.pointage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointageUpdateArgs>(args: SelectSubset<T, PointageUpdateArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pointages.
     * @param {PointageDeleteManyArgs} args - Arguments to filter Pointages to delete.
     * @example
     * // Delete a few Pointages
     * const { count } = await prisma.pointage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointageDeleteManyArgs>(args?: SelectSubset<T, PointageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pointages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pointages
     * const pointage = await prisma.pointage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointageUpdateManyArgs>(args: SelectSubset<T, PointageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pointage.
     * @param {PointageUpsertArgs} args - Arguments to update or create a Pointage.
     * @example
     * // Update or create a Pointage
     * const pointage = await prisma.pointage.upsert({
     *   create: {
     *     // ... data to create a Pointage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pointage we want to update
     *   }
     * })
     */
    upsert<T extends PointageUpsertArgs>(args: SelectSubset<T, PointageUpsertArgs<ExtArgs>>): Prisma__PointageClient<$Result.GetResult<Prisma.$PointagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pointages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointageCountArgs} args - Arguments to filter Pointages to count.
     * @example
     * // Count the number of Pointages
     * const count = await prisma.pointage.count({
     *   where: {
     *     // ... the filter for the Pointages we want to count
     *   }
     * })
    **/
    count<T extends PointageCountArgs>(
      args?: Subset<T, PointageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pointage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointageAggregateArgs>(args: Subset<T, PointageAggregateArgs>): Prisma.PrismaPromise<GetPointageAggregateType<T>>

    /**
     * Group by Pointage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointageGroupByArgs['orderBy'] }
        : { orderBy?: PointageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pointage model
   */
  readonly fields: PointageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pointage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employe<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    validateur<T extends Pointage$validateurArgs<ExtArgs> = {}>(args?: Subset<T, Pointage$validateurArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pointage model
   */
  interface PointageFieldRefs {
    readonly id: FieldRef<"Pointage", 'Int'>
    readonly employeId: FieldRef<"Pointage", 'Int'>
    readonly date: FieldRef<"Pointage", 'DateTime'>
    readonly heureArrivee: FieldRef<"Pointage", 'DateTime'>
    readonly heureDepart: FieldRef<"Pointage", 'DateTime'>
    readonly statut: FieldRef<"Pointage", 'StatutPointage'>
    readonly typePointage: FieldRef<"Pointage", 'TypePointage'>
    readonly commentaire: FieldRef<"Pointage", 'String'>
    readonly latitude: FieldRef<"Pointage", 'Decimal'>
    readonly longitude: FieldRef<"Pointage", 'Decimal'>
    readonly ipAddress: FieldRef<"Pointage", 'String'>
    readonly deviceInfo: FieldRef<"Pointage", 'String'>
    readonly validePar: FieldRef<"Pointage", 'Int'>
    readonly dateValidation: FieldRef<"Pointage", 'DateTime'>
    readonly creeLe: FieldRef<"Pointage", 'DateTime'>
    readonly modifieLe: FieldRef<"Pointage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pointage findUnique
   */
  export type PointageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * Filter, which Pointage to fetch.
     */
    where: PointageWhereUniqueInput
  }

  /**
   * Pointage findUniqueOrThrow
   */
  export type PointageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * Filter, which Pointage to fetch.
     */
    where: PointageWhereUniqueInput
  }

  /**
   * Pointage findFirst
   */
  export type PointageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * Filter, which Pointage to fetch.
     */
    where?: PointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pointages to fetch.
     */
    orderBy?: PointageOrderByWithRelationInput | PointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pointages.
     */
    cursor?: PointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pointages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pointages.
     */
    distinct?: PointageScalarFieldEnum | PointageScalarFieldEnum[]
  }

  /**
   * Pointage findFirstOrThrow
   */
  export type PointageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * Filter, which Pointage to fetch.
     */
    where?: PointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pointages to fetch.
     */
    orderBy?: PointageOrderByWithRelationInput | PointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pointages.
     */
    cursor?: PointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pointages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pointages.
     */
    distinct?: PointageScalarFieldEnum | PointageScalarFieldEnum[]
  }

  /**
   * Pointage findMany
   */
  export type PointageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * Filter, which Pointages to fetch.
     */
    where?: PointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pointages to fetch.
     */
    orderBy?: PointageOrderByWithRelationInput | PointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pointages.
     */
    cursor?: PointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pointages.
     */
    skip?: number
    distinct?: PointageScalarFieldEnum | PointageScalarFieldEnum[]
  }

  /**
   * Pointage create
   */
  export type PointageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * The data needed to create a Pointage.
     */
    data: XOR<PointageCreateInput, PointageUncheckedCreateInput>
  }

  /**
   * Pointage createMany
   */
  export type PointageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pointages.
     */
    data: PointageCreateManyInput | PointageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pointage update
   */
  export type PointageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * The data needed to update a Pointage.
     */
    data: XOR<PointageUpdateInput, PointageUncheckedUpdateInput>
    /**
     * Choose, which Pointage to update.
     */
    where: PointageWhereUniqueInput
  }

  /**
   * Pointage updateMany
   */
  export type PointageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pointages.
     */
    data: XOR<PointageUpdateManyMutationInput, PointageUncheckedUpdateManyInput>
    /**
     * Filter which Pointages to update
     */
    where?: PointageWhereInput
    /**
     * Limit how many Pointages to update.
     */
    limit?: number
  }

  /**
   * Pointage upsert
   */
  export type PointageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * The filter to search for the Pointage to update in case it exists.
     */
    where: PointageWhereUniqueInput
    /**
     * In case the Pointage found by the `where` argument doesn't exist, create a new Pointage with this data.
     */
    create: XOR<PointageCreateInput, PointageUncheckedCreateInput>
    /**
     * In case the Pointage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointageUpdateInput, PointageUncheckedUpdateInput>
  }

  /**
   * Pointage delete
   */
  export type PointageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
    /**
     * Filter which Pointage to delete.
     */
    where: PointageWhereUniqueInput
  }

  /**
   * Pointage deleteMany
   */
  export type PointageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pointages to delete
     */
    where?: PointageWhereInput
    /**
     * Limit how many Pointages to delete.
     */
    limit?: number
  }

  /**
   * Pointage.validateur
   */
  export type Pointage$validateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Pointage without action
   */
  export type PointageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pointage
     */
    select?: PointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pointage
     */
    omit?: PointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointageInclude<ExtArgs> | null
  }


  /**
   * Model ReglePointage
   */

  export type AggregateReglePointage = {
    _count: ReglePointageCountAggregateOutputType | null
    _avg: ReglePointageAvgAggregateOutputType | null
    _sum: ReglePointageSumAggregateOutputType | null
    _min: ReglePointageMinAggregateOutputType | null
    _max: ReglePointageMaxAggregateOutputType | null
  }

  export type ReglePointageAvgAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    toleranceRetard: number | null
    toleranceDepart: number | null
    heuresParJour: number | null
    seuilHeuresSup: number | null
    pauseDejeuner: number | null
  }

  export type ReglePointageSumAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    toleranceRetard: number | null
    toleranceDepart: number | null
    heuresParJour: number | null
    seuilHeuresSup: number | null
    pauseDejeuner: number | null
  }

  export type ReglePointageMinAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    heureDebut: string | null
    heureFin: string | null
    toleranceRetard: number | null
    toleranceDepart: number | null
    heuresParJour: number | null
    heuresSupAutorise: boolean | null
    seuilHeuresSup: number | null
    pauseDejeuner: number | null
    estFlexible: boolean | null
    plageHoraireMin: string | null
    plageHoraireMax: string | null
    modifieLe: Date | null
  }

  export type ReglePointageMaxAggregateOutputType = {
    id: number | null
    entrepriseId: number | null
    heureDebut: string | null
    heureFin: string | null
    toleranceRetard: number | null
    toleranceDepart: number | null
    heuresParJour: number | null
    heuresSupAutorise: boolean | null
    seuilHeuresSup: number | null
    pauseDejeuner: number | null
    estFlexible: boolean | null
    plageHoraireMin: string | null
    plageHoraireMax: string | null
    modifieLe: Date | null
  }

  export type ReglePointageCountAggregateOutputType = {
    id: number
    entrepriseId: number
    heureDebut: number
    heureFin: number
    toleranceRetard: number
    toleranceDepart: number
    joursTravail: number
    heuresParJour: number
    heuresSupAutorise: number
    seuilHeuresSup: number
    pauseDejeuner: number
    estFlexible: number
    plageHoraireMin: number
    plageHoraireMax: number
    joursFeries: number
    modifieLe: number
    _all: number
  }


  export type ReglePointageAvgAggregateInputType = {
    id?: true
    entrepriseId?: true
    toleranceRetard?: true
    toleranceDepart?: true
    heuresParJour?: true
    seuilHeuresSup?: true
    pauseDejeuner?: true
  }

  export type ReglePointageSumAggregateInputType = {
    id?: true
    entrepriseId?: true
    toleranceRetard?: true
    toleranceDepart?: true
    heuresParJour?: true
    seuilHeuresSup?: true
    pauseDejeuner?: true
  }

  export type ReglePointageMinAggregateInputType = {
    id?: true
    entrepriseId?: true
    heureDebut?: true
    heureFin?: true
    toleranceRetard?: true
    toleranceDepart?: true
    heuresParJour?: true
    heuresSupAutorise?: true
    seuilHeuresSup?: true
    pauseDejeuner?: true
    estFlexible?: true
    plageHoraireMin?: true
    plageHoraireMax?: true
    modifieLe?: true
  }

  export type ReglePointageMaxAggregateInputType = {
    id?: true
    entrepriseId?: true
    heureDebut?: true
    heureFin?: true
    toleranceRetard?: true
    toleranceDepart?: true
    heuresParJour?: true
    heuresSupAutorise?: true
    seuilHeuresSup?: true
    pauseDejeuner?: true
    estFlexible?: true
    plageHoraireMin?: true
    plageHoraireMax?: true
    modifieLe?: true
  }

  export type ReglePointageCountAggregateInputType = {
    id?: true
    entrepriseId?: true
    heureDebut?: true
    heureFin?: true
    toleranceRetard?: true
    toleranceDepart?: true
    joursTravail?: true
    heuresParJour?: true
    heuresSupAutorise?: true
    seuilHeuresSup?: true
    pauseDejeuner?: true
    estFlexible?: true
    plageHoraireMin?: true
    plageHoraireMax?: true
    joursFeries?: true
    modifieLe?: true
    _all?: true
  }

  export type ReglePointageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReglePointage to aggregate.
     */
    where?: ReglePointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReglePointages to fetch.
     */
    orderBy?: ReglePointageOrderByWithRelationInput | ReglePointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReglePointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReglePointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReglePointages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReglePointages
    **/
    _count?: true | ReglePointageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReglePointageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReglePointageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReglePointageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReglePointageMaxAggregateInputType
  }

  export type GetReglePointageAggregateType<T extends ReglePointageAggregateArgs> = {
        [P in keyof T & keyof AggregateReglePointage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReglePointage[P]>
      : GetScalarType<T[P], AggregateReglePointage[P]>
  }




  export type ReglePointageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReglePointageWhereInput
    orderBy?: ReglePointageOrderByWithAggregationInput | ReglePointageOrderByWithAggregationInput[]
    by: ReglePointageScalarFieldEnum[] | ReglePointageScalarFieldEnum
    having?: ReglePointageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReglePointageCountAggregateInputType | true
    _avg?: ReglePointageAvgAggregateInputType
    _sum?: ReglePointageSumAggregateInputType
    _min?: ReglePointageMinAggregateInputType
    _max?: ReglePointageMaxAggregateInputType
  }

  export type ReglePointageGroupByOutputType = {
    id: number
    entrepriseId: number
    heureDebut: string
    heureFin: string
    toleranceRetard: number
    toleranceDepart: number
    joursTravail: JsonValue
    heuresParJour: number
    heuresSupAutorise: boolean
    seuilHeuresSup: number
    pauseDejeuner: number
    estFlexible: boolean
    plageHoraireMin: string | null
    plageHoraireMax: string | null
    joursFeries: JsonValue | null
    modifieLe: Date
    _count: ReglePointageCountAggregateOutputType | null
    _avg: ReglePointageAvgAggregateOutputType | null
    _sum: ReglePointageSumAggregateOutputType | null
    _min: ReglePointageMinAggregateOutputType | null
    _max: ReglePointageMaxAggregateOutputType | null
  }

  type GetReglePointageGroupByPayload<T extends ReglePointageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReglePointageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReglePointageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReglePointageGroupByOutputType[P]>
            : GetScalarType<T[P], ReglePointageGroupByOutputType[P]>
        }
      >
    >


  export type ReglePointageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entrepriseId?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    toleranceRetard?: boolean
    toleranceDepart?: boolean
    joursTravail?: boolean
    heuresParJour?: boolean
    heuresSupAutorise?: boolean
    seuilHeuresSup?: boolean
    pauseDejeuner?: boolean
    estFlexible?: boolean
    plageHoraireMin?: boolean
    plageHoraireMax?: boolean
    joursFeries?: boolean
    modifieLe?: boolean
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reglePointage"]>



  export type ReglePointageSelectScalar = {
    id?: boolean
    entrepriseId?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    toleranceRetard?: boolean
    toleranceDepart?: boolean
    joursTravail?: boolean
    heuresParJour?: boolean
    heuresSupAutorise?: boolean
    seuilHeuresSup?: boolean
    pauseDejeuner?: boolean
    estFlexible?: boolean
    plageHoraireMin?: boolean
    plageHoraireMax?: boolean
    joursFeries?: boolean
    modifieLe?: boolean
  }

  export type ReglePointageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entrepriseId" | "heureDebut" | "heureFin" | "toleranceRetard" | "toleranceDepart" | "joursTravail" | "heuresParJour" | "heuresSupAutorise" | "seuilHeuresSup" | "pauseDejeuner" | "estFlexible" | "plageHoraireMin" | "plageHoraireMax" | "joursFeries" | "modifieLe", ExtArgs["result"]["reglePointage"]>
  export type ReglePointageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | EntrepriseDefaultArgs<ExtArgs>
  }

  export type $ReglePointagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReglePointage"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entrepriseId: number
      heureDebut: string
      heureFin: string
      toleranceRetard: number
      toleranceDepart: number
      joursTravail: Prisma.JsonValue
      heuresParJour: number
      heuresSupAutorise: boolean
      seuilHeuresSup: number
      pauseDejeuner: number
      estFlexible: boolean
      plageHoraireMin: string | null
      plageHoraireMax: string | null
      joursFeries: Prisma.JsonValue | null
      modifieLe: Date
    }, ExtArgs["result"]["reglePointage"]>
    composites: {}
  }

  type ReglePointageGetPayload<S extends boolean | null | undefined | ReglePointageDefaultArgs> = $Result.GetResult<Prisma.$ReglePointagePayload, S>

  type ReglePointageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReglePointageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReglePointageCountAggregateInputType | true
    }

  export interface ReglePointageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReglePointage'], meta: { name: 'ReglePointage' } }
    /**
     * Find zero or one ReglePointage that matches the filter.
     * @param {ReglePointageFindUniqueArgs} args - Arguments to find a ReglePointage
     * @example
     * // Get one ReglePointage
     * const reglePointage = await prisma.reglePointage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReglePointageFindUniqueArgs>(args: SelectSubset<T, ReglePointageFindUniqueArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReglePointage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReglePointageFindUniqueOrThrowArgs} args - Arguments to find a ReglePointage
     * @example
     * // Get one ReglePointage
     * const reglePointage = await prisma.reglePointage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReglePointageFindUniqueOrThrowArgs>(args: SelectSubset<T, ReglePointageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReglePointage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReglePointageFindFirstArgs} args - Arguments to find a ReglePointage
     * @example
     * // Get one ReglePointage
     * const reglePointage = await prisma.reglePointage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReglePointageFindFirstArgs>(args?: SelectSubset<T, ReglePointageFindFirstArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReglePointage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReglePointageFindFirstOrThrowArgs} args - Arguments to find a ReglePointage
     * @example
     * // Get one ReglePointage
     * const reglePointage = await prisma.reglePointage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReglePointageFindFirstOrThrowArgs>(args?: SelectSubset<T, ReglePointageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReglePointages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReglePointageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReglePointages
     * const reglePointages = await prisma.reglePointage.findMany()
     * 
     * // Get first 10 ReglePointages
     * const reglePointages = await prisma.reglePointage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reglePointageWithIdOnly = await prisma.reglePointage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReglePointageFindManyArgs>(args?: SelectSubset<T, ReglePointageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReglePointage.
     * @param {ReglePointageCreateArgs} args - Arguments to create a ReglePointage.
     * @example
     * // Create one ReglePointage
     * const ReglePointage = await prisma.reglePointage.create({
     *   data: {
     *     // ... data to create a ReglePointage
     *   }
     * })
     * 
     */
    create<T extends ReglePointageCreateArgs>(args: SelectSubset<T, ReglePointageCreateArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReglePointages.
     * @param {ReglePointageCreateManyArgs} args - Arguments to create many ReglePointages.
     * @example
     * // Create many ReglePointages
     * const reglePointage = await prisma.reglePointage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReglePointageCreateManyArgs>(args?: SelectSubset<T, ReglePointageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReglePointage.
     * @param {ReglePointageDeleteArgs} args - Arguments to delete one ReglePointage.
     * @example
     * // Delete one ReglePointage
     * const ReglePointage = await prisma.reglePointage.delete({
     *   where: {
     *     // ... filter to delete one ReglePointage
     *   }
     * })
     * 
     */
    delete<T extends ReglePointageDeleteArgs>(args: SelectSubset<T, ReglePointageDeleteArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReglePointage.
     * @param {ReglePointageUpdateArgs} args - Arguments to update one ReglePointage.
     * @example
     * // Update one ReglePointage
     * const reglePointage = await prisma.reglePointage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReglePointageUpdateArgs>(args: SelectSubset<T, ReglePointageUpdateArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReglePointages.
     * @param {ReglePointageDeleteManyArgs} args - Arguments to filter ReglePointages to delete.
     * @example
     * // Delete a few ReglePointages
     * const { count } = await prisma.reglePointage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReglePointageDeleteManyArgs>(args?: SelectSubset<T, ReglePointageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReglePointages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReglePointageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReglePointages
     * const reglePointage = await prisma.reglePointage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReglePointageUpdateManyArgs>(args: SelectSubset<T, ReglePointageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReglePointage.
     * @param {ReglePointageUpsertArgs} args - Arguments to update or create a ReglePointage.
     * @example
     * // Update or create a ReglePointage
     * const reglePointage = await prisma.reglePointage.upsert({
     *   create: {
     *     // ... data to create a ReglePointage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReglePointage we want to update
     *   }
     * })
     */
    upsert<T extends ReglePointageUpsertArgs>(args: SelectSubset<T, ReglePointageUpsertArgs<ExtArgs>>): Prisma__ReglePointageClient<$Result.GetResult<Prisma.$ReglePointagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReglePointages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReglePointageCountArgs} args - Arguments to filter ReglePointages to count.
     * @example
     * // Count the number of ReglePointages
     * const count = await prisma.reglePointage.count({
     *   where: {
     *     // ... the filter for the ReglePointages we want to count
     *   }
     * })
    **/
    count<T extends ReglePointageCountArgs>(
      args?: Subset<T, ReglePointageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReglePointageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReglePointage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReglePointageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReglePointageAggregateArgs>(args: Subset<T, ReglePointageAggregateArgs>): Prisma.PrismaPromise<GetReglePointageAggregateType<T>>

    /**
     * Group by ReglePointage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReglePointageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReglePointageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReglePointageGroupByArgs['orderBy'] }
        : { orderBy?: ReglePointageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReglePointageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReglePointageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReglePointage model
   */
  readonly fields: ReglePointageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReglePointage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReglePointageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends EntrepriseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntrepriseDefaultArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReglePointage model
   */
  interface ReglePointageFieldRefs {
    readonly id: FieldRef<"ReglePointage", 'Int'>
    readonly entrepriseId: FieldRef<"ReglePointage", 'Int'>
    readonly heureDebut: FieldRef<"ReglePointage", 'String'>
    readonly heureFin: FieldRef<"ReglePointage", 'String'>
    readonly toleranceRetard: FieldRef<"ReglePointage", 'Int'>
    readonly toleranceDepart: FieldRef<"ReglePointage", 'Int'>
    readonly joursTravail: FieldRef<"ReglePointage", 'Json'>
    readonly heuresParJour: FieldRef<"ReglePointage", 'Int'>
    readonly heuresSupAutorise: FieldRef<"ReglePointage", 'Boolean'>
    readonly seuilHeuresSup: FieldRef<"ReglePointage", 'Int'>
    readonly pauseDejeuner: FieldRef<"ReglePointage", 'Int'>
    readonly estFlexible: FieldRef<"ReglePointage", 'Boolean'>
    readonly plageHoraireMin: FieldRef<"ReglePointage", 'String'>
    readonly plageHoraireMax: FieldRef<"ReglePointage", 'String'>
    readonly joursFeries: FieldRef<"ReglePointage", 'Json'>
    readonly modifieLe: FieldRef<"ReglePointage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReglePointage findUnique
   */
  export type ReglePointageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * Filter, which ReglePointage to fetch.
     */
    where: ReglePointageWhereUniqueInput
  }

  /**
   * ReglePointage findUniqueOrThrow
   */
  export type ReglePointageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * Filter, which ReglePointage to fetch.
     */
    where: ReglePointageWhereUniqueInput
  }

  /**
   * ReglePointage findFirst
   */
  export type ReglePointageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * Filter, which ReglePointage to fetch.
     */
    where?: ReglePointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReglePointages to fetch.
     */
    orderBy?: ReglePointageOrderByWithRelationInput | ReglePointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReglePointages.
     */
    cursor?: ReglePointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReglePointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReglePointages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReglePointages.
     */
    distinct?: ReglePointageScalarFieldEnum | ReglePointageScalarFieldEnum[]
  }

  /**
   * ReglePointage findFirstOrThrow
   */
  export type ReglePointageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * Filter, which ReglePointage to fetch.
     */
    where?: ReglePointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReglePointages to fetch.
     */
    orderBy?: ReglePointageOrderByWithRelationInput | ReglePointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReglePointages.
     */
    cursor?: ReglePointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReglePointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReglePointages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReglePointages.
     */
    distinct?: ReglePointageScalarFieldEnum | ReglePointageScalarFieldEnum[]
  }

  /**
   * ReglePointage findMany
   */
  export type ReglePointageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * Filter, which ReglePointages to fetch.
     */
    where?: ReglePointageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReglePointages to fetch.
     */
    orderBy?: ReglePointageOrderByWithRelationInput | ReglePointageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReglePointages.
     */
    cursor?: ReglePointageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReglePointages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReglePointages.
     */
    skip?: number
    distinct?: ReglePointageScalarFieldEnum | ReglePointageScalarFieldEnum[]
  }

  /**
   * ReglePointage create
   */
  export type ReglePointageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * The data needed to create a ReglePointage.
     */
    data: XOR<ReglePointageCreateInput, ReglePointageUncheckedCreateInput>
  }

  /**
   * ReglePointage createMany
   */
  export type ReglePointageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReglePointages.
     */
    data: ReglePointageCreateManyInput | ReglePointageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReglePointage update
   */
  export type ReglePointageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * The data needed to update a ReglePointage.
     */
    data: XOR<ReglePointageUpdateInput, ReglePointageUncheckedUpdateInput>
    /**
     * Choose, which ReglePointage to update.
     */
    where: ReglePointageWhereUniqueInput
  }

  /**
   * ReglePointage updateMany
   */
  export type ReglePointageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReglePointages.
     */
    data: XOR<ReglePointageUpdateManyMutationInput, ReglePointageUncheckedUpdateManyInput>
    /**
     * Filter which ReglePointages to update
     */
    where?: ReglePointageWhereInput
    /**
     * Limit how many ReglePointages to update.
     */
    limit?: number
  }

  /**
   * ReglePointage upsert
   */
  export type ReglePointageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * The filter to search for the ReglePointage to update in case it exists.
     */
    where: ReglePointageWhereUniqueInput
    /**
     * In case the ReglePointage found by the `where` argument doesn't exist, create a new ReglePointage with this data.
     */
    create: XOR<ReglePointageCreateInput, ReglePointageUncheckedCreateInput>
    /**
     * In case the ReglePointage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReglePointageUpdateInput, ReglePointageUncheckedUpdateInput>
  }

  /**
   * ReglePointage delete
   */
  export type ReglePointageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
    /**
     * Filter which ReglePointage to delete.
     */
    where: ReglePointageWhereUniqueInput
  }

  /**
   * ReglePointage deleteMany
   */
  export type ReglePointageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReglePointages to delete
     */
    where?: ReglePointageWhereInput
    /**
     * Limit how many ReglePointages to delete.
     */
    limit?: number
  }

  /**
   * ReglePointage without action
   */
  export type ReglePointageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReglePointage
     */
    select?: ReglePointageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReglePointage
     */
    omit?: ReglePointageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReglePointageInclude<ExtArgs> | null
  }


  /**
   * Model Absence
   */

  export type AggregateAbsence = {
    _count: AbsenceCountAggregateOutputType | null
    _avg: AbsenceAvgAggregateOutputType | null
    _sum: AbsenceSumAggregateOutputType | null
    _min: AbsenceMinAggregateOutputType | null
    _max: AbsenceMaxAggregateOutputType | null
  }

  export type AbsenceAvgAggregateOutputType = {
    id: number | null
    employeId: number | null
    joursOuvres: number | null
    heuresAbsence: Decimal | null
    approuvePar: number | null
  }

  export type AbsenceSumAggregateOutputType = {
    id: number | null
    employeId: number | null
    joursOuvres: number | null
    heuresAbsence: Decimal | null
    approuvePar: number | null
  }

  export type AbsenceMinAggregateOutputType = {
    id: number | null
    employeId: number | null
    typeAbsence: $Enums.TypeAbsence | null
    dateDebut: Date | null
    dateFin: Date | null
    motif: string | null
    statut: $Enums.StatutAbsence | null
    joursOuvres: number | null
    heuresAbsence: Decimal | null
    commentaire: string | null
    pieceJointe: string | null
    approuvePar: number | null
    dateApprobation: Date | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type AbsenceMaxAggregateOutputType = {
    id: number | null
    employeId: number | null
    typeAbsence: $Enums.TypeAbsence | null
    dateDebut: Date | null
    dateFin: Date | null
    motif: string | null
    statut: $Enums.StatutAbsence | null
    joursOuvres: number | null
    heuresAbsence: Decimal | null
    commentaire: string | null
    pieceJointe: string | null
    approuvePar: number | null
    dateApprobation: Date | null
    creeLe: Date | null
    modifieLe: Date | null
  }

  export type AbsenceCountAggregateOutputType = {
    id: number
    employeId: number
    typeAbsence: number
    dateDebut: number
    dateFin: number
    motif: number
    statut: number
    joursOuvres: number
    heuresAbsence: number
    commentaire: number
    pieceJointe: number
    approuvePar: number
    dateApprobation: number
    creeLe: number
    modifieLe: number
    _all: number
  }


  export type AbsenceAvgAggregateInputType = {
    id?: true
    employeId?: true
    joursOuvres?: true
    heuresAbsence?: true
    approuvePar?: true
  }

  export type AbsenceSumAggregateInputType = {
    id?: true
    employeId?: true
    joursOuvres?: true
    heuresAbsence?: true
    approuvePar?: true
  }

  export type AbsenceMinAggregateInputType = {
    id?: true
    employeId?: true
    typeAbsence?: true
    dateDebut?: true
    dateFin?: true
    motif?: true
    statut?: true
    joursOuvres?: true
    heuresAbsence?: true
    commentaire?: true
    pieceJointe?: true
    approuvePar?: true
    dateApprobation?: true
    creeLe?: true
    modifieLe?: true
  }

  export type AbsenceMaxAggregateInputType = {
    id?: true
    employeId?: true
    typeAbsence?: true
    dateDebut?: true
    dateFin?: true
    motif?: true
    statut?: true
    joursOuvres?: true
    heuresAbsence?: true
    commentaire?: true
    pieceJointe?: true
    approuvePar?: true
    dateApprobation?: true
    creeLe?: true
    modifieLe?: true
  }

  export type AbsenceCountAggregateInputType = {
    id?: true
    employeId?: true
    typeAbsence?: true
    dateDebut?: true
    dateFin?: true
    motif?: true
    statut?: true
    joursOuvres?: true
    heuresAbsence?: true
    commentaire?: true
    pieceJointe?: true
    approuvePar?: true
    dateApprobation?: true
    creeLe?: true
    modifieLe?: true
    _all?: true
  }

  export type AbsenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Absence to aggregate.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Absences
    **/
    _count?: true | AbsenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbsenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbsenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbsenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbsenceMaxAggregateInputType
  }

  export type GetAbsenceAggregateType<T extends AbsenceAggregateArgs> = {
        [P in keyof T & keyof AggregateAbsence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbsence[P]>
      : GetScalarType<T[P], AggregateAbsence[P]>
  }




  export type AbsenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbsenceWhereInput
    orderBy?: AbsenceOrderByWithAggregationInput | AbsenceOrderByWithAggregationInput[]
    by: AbsenceScalarFieldEnum[] | AbsenceScalarFieldEnum
    having?: AbsenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbsenceCountAggregateInputType | true
    _avg?: AbsenceAvgAggregateInputType
    _sum?: AbsenceSumAggregateInputType
    _min?: AbsenceMinAggregateInputType
    _max?: AbsenceMaxAggregateInputType
  }

  export type AbsenceGroupByOutputType = {
    id: number
    employeId: number
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date
    dateFin: Date
    motif: string | null
    statut: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal
    commentaire: string | null
    pieceJointe: string | null
    approuvePar: number | null
    dateApprobation: Date | null
    creeLe: Date
    modifieLe: Date
    _count: AbsenceCountAggregateOutputType | null
    _avg: AbsenceAvgAggregateOutputType | null
    _sum: AbsenceSumAggregateOutputType | null
    _min: AbsenceMinAggregateOutputType | null
    _max: AbsenceMaxAggregateOutputType | null
  }

  type GetAbsenceGroupByPayload<T extends AbsenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbsenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbsenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbsenceGroupByOutputType[P]>
            : GetScalarType<T[P], AbsenceGroupByOutputType[P]>
        }
      >
    >


  export type AbsenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    typeAbsence?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    motif?: boolean
    statut?: boolean
    joursOuvres?: boolean
    heuresAbsence?: boolean
    commentaire?: boolean
    pieceJointe?: boolean
    approuvePar?: boolean
    dateApprobation?: boolean
    creeLe?: boolean
    modifieLe?: boolean
    employe?: boolean | EmployeeDefaultArgs<ExtArgs>
    approbateur?: boolean | Absence$approbateurArgs<ExtArgs>
  }, ExtArgs["result"]["absence"]>



  export type AbsenceSelectScalar = {
    id?: boolean
    employeId?: boolean
    typeAbsence?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    motif?: boolean
    statut?: boolean
    joursOuvres?: boolean
    heuresAbsence?: boolean
    commentaire?: boolean
    pieceJointe?: boolean
    approuvePar?: boolean
    dateApprobation?: boolean
    creeLe?: boolean
    modifieLe?: boolean
  }

  export type AbsenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeId" | "typeAbsence" | "dateDebut" | "dateFin" | "motif" | "statut" | "joursOuvres" | "heuresAbsence" | "commentaire" | "pieceJointe" | "approuvePar" | "dateApprobation" | "creeLe" | "modifieLe", ExtArgs["result"]["absence"]>
  export type AbsenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeeDefaultArgs<ExtArgs>
    approbateur?: boolean | Absence$approbateurArgs<ExtArgs>
  }

  export type $AbsencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Absence"
    objects: {
      employe: Prisma.$EmployeePayload<ExtArgs>
      approbateur: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeId: number
      typeAbsence: $Enums.TypeAbsence
      dateDebut: Date
      dateFin: Date
      motif: string | null
      statut: $Enums.StatutAbsence
      joursOuvres: number
      heuresAbsence: Prisma.Decimal
      commentaire: string | null
      pieceJointe: string | null
      approuvePar: number | null
      dateApprobation: Date | null
      creeLe: Date
      modifieLe: Date
    }, ExtArgs["result"]["absence"]>
    composites: {}
  }

  type AbsenceGetPayload<S extends boolean | null | undefined | AbsenceDefaultArgs> = $Result.GetResult<Prisma.$AbsencePayload, S>

  type AbsenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbsenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbsenceCountAggregateInputType | true
    }

  export interface AbsenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Absence'], meta: { name: 'Absence' } }
    /**
     * Find zero or one Absence that matches the filter.
     * @param {AbsenceFindUniqueArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbsenceFindUniqueArgs>(args: SelectSubset<T, AbsenceFindUniqueArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Absence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbsenceFindUniqueOrThrowArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbsenceFindUniqueOrThrowArgs>(args: SelectSubset<T, AbsenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Absence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceFindFirstArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbsenceFindFirstArgs>(args?: SelectSubset<T, AbsenceFindFirstArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Absence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceFindFirstOrThrowArgs} args - Arguments to find a Absence
     * @example
     * // Get one Absence
     * const absence = await prisma.absence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbsenceFindFirstOrThrowArgs>(args?: SelectSubset<T, AbsenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Absences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Absences
     * const absences = await prisma.absence.findMany()
     * 
     * // Get first 10 Absences
     * const absences = await prisma.absence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const absenceWithIdOnly = await prisma.absence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbsenceFindManyArgs>(args?: SelectSubset<T, AbsenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Absence.
     * @param {AbsenceCreateArgs} args - Arguments to create a Absence.
     * @example
     * // Create one Absence
     * const Absence = await prisma.absence.create({
     *   data: {
     *     // ... data to create a Absence
     *   }
     * })
     * 
     */
    create<T extends AbsenceCreateArgs>(args: SelectSubset<T, AbsenceCreateArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Absences.
     * @param {AbsenceCreateManyArgs} args - Arguments to create many Absences.
     * @example
     * // Create many Absences
     * const absence = await prisma.absence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbsenceCreateManyArgs>(args?: SelectSubset<T, AbsenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Absence.
     * @param {AbsenceDeleteArgs} args - Arguments to delete one Absence.
     * @example
     * // Delete one Absence
     * const Absence = await prisma.absence.delete({
     *   where: {
     *     // ... filter to delete one Absence
     *   }
     * })
     * 
     */
    delete<T extends AbsenceDeleteArgs>(args: SelectSubset<T, AbsenceDeleteArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Absence.
     * @param {AbsenceUpdateArgs} args - Arguments to update one Absence.
     * @example
     * // Update one Absence
     * const absence = await prisma.absence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbsenceUpdateArgs>(args: SelectSubset<T, AbsenceUpdateArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Absences.
     * @param {AbsenceDeleteManyArgs} args - Arguments to filter Absences to delete.
     * @example
     * // Delete a few Absences
     * const { count } = await prisma.absence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbsenceDeleteManyArgs>(args?: SelectSubset<T, AbsenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Absences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Absences
     * const absence = await prisma.absence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbsenceUpdateManyArgs>(args: SelectSubset<T, AbsenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Absence.
     * @param {AbsenceUpsertArgs} args - Arguments to update or create a Absence.
     * @example
     * // Update or create a Absence
     * const absence = await prisma.absence.upsert({
     *   create: {
     *     // ... data to create a Absence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Absence we want to update
     *   }
     * })
     */
    upsert<T extends AbsenceUpsertArgs>(args: SelectSubset<T, AbsenceUpsertArgs<ExtArgs>>): Prisma__AbsenceClient<$Result.GetResult<Prisma.$AbsencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Absences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceCountArgs} args - Arguments to filter Absences to count.
     * @example
     * // Count the number of Absences
     * const count = await prisma.absence.count({
     *   where: {
     *     // ... the filter for the Absences we want to count
     *   }
     * })
    **/
    count<T extends AbsenceCountArgs>(
      args?: Subset<T, AbsenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbsenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Absence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbsenceAggregateArgs>(args: Subset<T, AbsenceAggregateArgs>): Prisma.PrismaPromise<GetAbsenceAggregateType<T>>

    /**
     * Group by Absence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbsenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbsenceGroupByArgs['orderBy'] }
        : { orderBy?: AbsenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbsenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbsenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Absence model
   */
  readonly fields: AbsenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Absence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbsenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employe<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approbateur<T extends Absence$approbateurArgs<ExtArgs> = {}>(args?: Subset<T, Absence$approbateurArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Absence model
   */
  interface AbsenceFieldRefs {
    readonly id: FieldRef<"Absence", 'Int'>
    readonly employeId: FieldRef<"Absence", 'Int'>
    readonly typeAbsence: FieldRef<"Absence", 'TypeAbsence'>
    readonly dateDebut: FieldRef<"Absence", 'DateTime'>
    readonly dateFin: FieldRef<"Absence", 'DateTime'>
    readonly motif: FieldRef<"Absence", 'String'>
    readonly statut: FieldRef<"Absence", 'StatutAbsence'>
    readonly joursOuvres: FieldRef<"Absence", 'Int'>
    readonly heuresAbsence: FieldRef<"Absence", 'Decimal'>
    readonly commentaire: FieldRef<"Absence", 'String'>
    readonly pieceJointe: FieldRef<"Absence", 'String'>
    readonly approuvePar: FieldRef<"Absence", 'Int'>
    readonly dateApprobation: FieldRef<"Absence", 'DateTime'>
    readonly creeLe: FieldRef<"Absence", 'DateTime'>
    readonly modifieLe: FieldRef<"Absence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Absence findUnique
   */
  export type AbsenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence findUniqueOrThrow
   */
  export type AbsenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence findFirst
   */
  export type AbsenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Absences.
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Absences.
     */
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Absence findFirstOrThrow
   */
  export type AbsenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absence to fetch.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Absences.
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Absences.
     */
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Absence findMany
   */
  export type AbsenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter, which Absences to fetch.
     */
    where?: AbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Absences to fetch.
     */
    orderBy?: AbsenceOrderByWithRelationInput | AbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Absences.
     */
    cursor?: AbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Absences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Absences.
     */
    skip?: number
    distinct?: AbsenceScalarFieldEnum | AbsenceScalarFieldEnum[]
  }

  /**
   * Absence create
   */
  export type AbsenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Absence.
     */
    data: XOR<AbsenceCreateInput, AbsenceUncheckedCreateInput>
  }

  /**
   * Absence createMany
   */
  export type AbsenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Absences.
     */
    data: AbsenceCreateManyInput | AbsenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Absence update
   */
  export type AbsenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Absence.
     */
    data: XOR<AbsenceUpdateInput, AbsenceUncheckedUpdateInput>
    /**
     * Choose, which Absence to update.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence updateMany
   */
  export type AbsenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Absences.
     */
    data: XOR<AbsenceUpdateManyMutationInput, AbsenceUncheckedUpdateManyInput>
    /**
     * Filter which Absences to update
     */
    where?: AbsenceWhereInput
    /**
     * Limit how many Absences to update.
     */
    limit?: number
  }

  /**
   * Absence upsert
   */
  export type AbsenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Absence to update in case it exists.
     */
    where: AbsenceWhereUniqueInput
    /**
     * In case the Absence found by the `where` argument doesn't exist, create a new Absence with this data.
     */
    create: XOR<AbsenceCreateInput, AbsenceUncheckedCreateInput>
    /**
     * In case the Absence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbsenceUpdateInput, AbsenceUncheckedUpdateInput>
  }

  /**
   * Absence delete
   */
  export type AbsenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
    /**
     * Filter which Absence to delete.
     */
    where: AbsenceWhereUniqueInput
  }

  /**
   * Absence deleteMany
   */
  export type AbsenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Absences to delete
     */
    where?: AbsenceWhereInput
    /**
     * Limit how many Absences to delete.
     */
    limit?: number
  }

  /**
   * Absence.approbateur
   */
  export type Absence$approbateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Absence without action
   */
  export type AbsenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Absence
     */
    select?: AbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Absence
     */
    omit?: AbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbsenceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    lastLogin: 'lastLogin',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    entrepriseId: 'entrepriseId',
    employeeId: 'employeeId',
    department: 'department',
    position: 'position',
    contractType: 'contractType',
    salary: 'salary',
    dailyRate: 'dailyRate',
    hourlyRate: 'hourlyRate',
    hireDate: 'hireDate',
    phone: 'phone',
    address: 'address',
    status: 'status',
    qrCode: 'qrCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const EntrepriseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    adresse: 'adresse',
    telephone: 'telephone',
    email: 'email',
    siteWeb: 'siteWeb',
    logo: 'logo',
    couleurPrimaire: 'couleurPrimaire',
    couleurSecondaire: 'couleurSecondaire',
    couleurDashboard: 'couleurDashboard',
    description: 'description',
    devise: 'devise',
    timezone: 'timezone',
    periodePayroll: 'periodePayroll',
    estActive: 'estActive',
    parametres: 'parametres',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type EntrepriseScalarFieldEnum = (typeof EntrepriseScalarFieldEnum)[keyof typeof EntrepriseScalarFieldEnum]


  export const JournalAuditScalarFieldEnum: {
    id: 'id',
    utilisateurId: 'utilisateurId',
    action: 'action',
    nomTable: 'nomTable',
    idEnregistrement: 'idEnregistrement',
    anciennes_valeurs: 'anciennes_valeurs',
    nouvelles_valeurs: 'nouvelles_valeurs',
    creeLe: 'creeLe'
  };

  export type JournalAuditScalarFieldEnum = (typeof JournalAuditScalarFieldEnum)[keyof typeof JournalAuditScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    status: 'status',
    notes: 'notes',
    processedBy: 'processedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    category: 'category',
    isRead: 'isRead',
    link: 'link',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const CompanyFactureScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    numeroFacture: 'numeroFacture',
    montant: 'montant',
    description: 'description',
    statut: 'statut',
    dateEcheance: 'dateEcheance',
    datePaiement: 'datePaiement',
    creePar: 'creePar',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type CompanyFactureScalarFieldEnum = (typeof CompanyFactureScalarFieldEnum)[keyof typeof CompanyFactureScalarFieldEnum]


  export const CompanyLigneFactureScalarFieldEnum: {
    id: 'id',
    factureId: 'factureId',
    description: 'description',
    quantite: 'quantite',
    prixUnitaire: 'prixUnitaire',
    prixTotal: 'prixTotal',
    creeLe: 'creeLe'
  };

  export type CompanyLigneFactureScalarFieldEnum = (typeof CompanyLigneFactureScalarFieldEnum)[keyof typeof CompanyLigneFactureScalarFieldEnum]


  export const CompanyPayRunScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    datePaiement: 'datePaiement',
    statut: 'statut',
    totalBrut: 'totalBrut',
    totalNet: 'totalNet',
    totalDeductions: 'totalDeductions',
    nombreEmployes: 'nombreEmployes',
    metadata: 'metadata',
    entrepriseId: 'entrepriseId',
    periodePaieId: 'periodePaieId',
    creePar: 'creePar',
    creeLe: 'creeLe',
    approuveLe: 'approuveLe',
    approuvePar: 'approuvePar'
  };

  export type CompanyPayRunScalarFieldEnum = (typeof CompanyPayRunScalarFieldEnum)[keyof typeof CompanyPayRunScalarFieldEnum]


  export const CompanyBulletinScalarFieldEnum: {
    id: 'id',
    numeroBulletin: 'numeroBulletin',
    datePaiement: 'datePaiement',
    joursTravailles: 'joursTravailles',
    heuresTravailes: 'heuresTravailes',
    salaireBrut: 'salaireBrut',
    salaireBase: 'salaireBase',
    montantHeuresSupp: 'montantHeuresSupp',
    montantBonus: 'montantBonus',
    indemnites: 'indemnites',
    deductions: 'deductions',
    totalDeductions: 'totalDeductions',
    salaireNet: 'salaireNet',
    montantPaye: 'montantPaye',
    resteAPayer: 'resteAPayer',
    statutPaiement: 'statutPaiement',
    cheminPDF: 'cheminPDF',
    calculs: 'calculs',
    estVerrouille: 'estVerrouille',
    payRunId: 'payRunId',
    employeId: 'employeId',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type CompanyBulletinScalarFieldEnum = (typeof CompanyBulletinScalarFieldEnum)[keyof typeof CompanyBulletinScalarFieldEnum]


  export const CompanyPaiementScalarFieldEnum: {
    id: 'id',
    referenceTransaction: 'referenceTransaction',
    montant: 'montant',
    methodePaiement: 'methodePaiement',
    referencePaiement: 'referencePaiement',
    datePaiement: 'datePaiement',
    notes: 'notes',
    cheminRecu: 'cheminRecu',
    statut: 'statut',
    metadata: 'metadata',
    bulletinId: 'bulletinId',
    traitePar: 'traitePar',
    creeLe: 'creeLe'
  };

  export type CompanyPaiementScalarFieldEnum = (typeof CompanyPaiementScalarFieldEnum)[keyof typeof CompanyPaiementScalarFieldEnum]


  export const CompanyTemplateScalarFieldEnum: {
    id: 'id',
    typeTemplate: 'typeTemplate',
    nom: 'nom',
    contenu: 'contenu',
    variables: 'variables',
    estDefaut: 'estDefaut',
    estActif: 'estActif',
    entrepriseId: 'entrepriseId',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type CompanyTemplateScalarFieldEnum = (typeof CompanyTemplateScalarFieldEnum)[keyof typeof CompanyTemplateScalarFieldEnum]


  export const CompanySettingScalarFieldEnum: {
    id: 'id',
    cle: 'cle',
    valeur: 'valeur',
    description: 'description',
    typeData: 'typeData',
    estEncrypte: 'estEncrypte',
    entrepriseId: 'entrepriseId',
    modifieLe: 'modifieLe'
  };

  export type CompanySettingScalarFieldEnum = (typeof CompanySettingScalarFieldEnum)[keyof typeof CompanySettingScalarFieldEnum]


  export const CompanyDocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    titre: 'titre',
    description: 'description',
    cheminFichier: 'cheminFichier',
    tailleFichier: 'tailleFichier',
    mimeType: 'mimeType',
    metadata: 'metadata',
    tags: 'tags',
    employeId: 'employeId',
    uploadePar: 'uploadePar',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type CompanyDocumentScalarFieldEnum = (typeof CompanyDocumentScalarFieldEnum)[keyof typeof CompanyDocumentScalarFieldEnum]


  export const CompanyModeleDocumentScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    type: 'type',
    contenu: 'contenu',
    variables: 'variables',
    estActif: 'estActif',
    entrepriseId: 'entrepriseId',
    version: 'version',
    creePar: 'creePar',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type CompanyModeleDocumentScalarFieldEnum = (typeof CompanyModeleDocumentScalarFieldEnum)[keyof typeof CompanyModeleDocumentScalarFieldEnum]


  export const CompanyPeriodePaieScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    estCloturee: 'estCloturee',
    dateReglement: 'dateReglement',
    notes: 'notes',
    metadata: 'metadata',
    entrepriseId: 'entrepriseId',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type CompanyPeriodePaieScalarFieldEnum = (typeof CompanyPeriodePaieScalarFieldEnum)[keyof typeof CompanyPeriodePaieScalarFieldEnum]


  export const CompanyConfigurationPaieScalarFieldEnum: {
    id: 'id',
    entrepriseId: 'entrepriseId',
    jourPaie: 'jourPaie',
    periodeCalcul: 'periodeCalcul',
    regleArrondi: 'regleArrondi',
    deviseSecondaire: 'deviseSecondaire',
    tauxChange: 'tauxChange',
    formatNumeration: 'formatNumeration',
    regleValidation: 'regleValidation',
    parametresCalcul: 'parametresCalcul',
    modifieLe: 'modifieLe'
  };

  export type CompanyConfigurationPaieScalarFieldEnum = (typeof CompanyConfigurationPaieScalarFieldEnum)[keyof typeof CompanyConfigurationPaieScalarFieldEnum]


  export const CompanyHistoriqueSalaireScalarFieldEnum: {
    id: 'id',
    employeId: 'employeId',
    ancienSalaire: 'ancienSalaire',
    nouveauSalaire: 'nouveauSalaire',
    dateEffet: 'dateEffet',
    motif: 'motif',
    notes: 'notes',
    documents: 'documents',
    modifiePar: 'modifiePar',
    creeLe: 'creeLe'
  };

  export type CompanyHistoriqueSalaireScalarFieldEnum = (typeof CompanyHistoriqueSalaireScalarFieldEnum)[keyof typeof CompanyHistoriqueSalaireScalarFieldEnum]


  export const CompanyRegleDeductionScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    type: 'type',
    formule: 'formule',
    conditionsApplication: 'conditionsApplication',
    estObligatoire: 'estObligatoire',
    ordre: 'ordre',
    configurationId: 'configurationId',
    estActif: 'estActif',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type CompanyRegleDeductionScalarFieldEnum = (typeof CompanyRegleDeductionScalarFieldEnum)[keyof typeof CompanyRegleDeductionScalarFieldEnum]


  export const PointageScalarFieldEnum: {
    id: 'id',
    employeId: 'employeId',
    date: 'date',
    heureArrivee: 'heureArrivee',
    heureDepart: 'heureDepart',
    statut: 'statut',
    typePointage: 'typePointage',
    commentaire: 'commentaire',
    latitude: 'latitude',
    longitude: 'longitude',
    ipAddress: 'ipAddress',
    deviceInfo: 'deviceInfo',
    validePar: 'validePar',
    dateValidation: 'dateValidation',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type PointageScalarFieldEnum = (typeof PointageScalarFieldEnum)[keyof typeof PointageScalarFieldEnum]


  export const ReglePointageScalarFieldEnum: {
    id: 'id',
    entrepriseId: 'entrepriseId',
    heureDebut: 'heureDebut',
    heureFin: 'heureFin',
    toleranceRetard: 'toleranceRetard',
    toleranceDepart: 'toleranceDepart',
    joursTravail: 'joursTravail',
    heuresParJour: 'heuresParJour',
    heuresSupAutorise: 'heuresSupAutorise',
    seuilHeuresSup: 'seuilHeuresSup',
    pauseDejeuner: 'pauseDejeuner',
    estFlexible: 'estFlexible',
    plageHoraireMin: 'plageHoraireMin',
    plageHoraireMax: 'plageHoraireMax',
    joursFeries: 'joursFeries',
    modifieLe: 'modifieLe'
  };

  export type ReglePointageScalarFieldEnum = (typeof ReglePointageScalarFieldEnum)[keyof typeof ReglePointageScalarFieldEnum]


  export const AbsenceScalarFieldEnum: {
    id: 'id',
    employeId: 'employeId',
    typeAbsence: 'typeAbsence',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    motif: 'motif',
    statut: 'statut',
    joursOuvres: 'joursOuvres',
    heuresAbsence: 'heuresAbsence',
    commentaire: 'commentaire',
    pieceJointe: 'pieceJointe',
    approuvePar: 'approuvePar',
    dateApprobation: 'dateApprobation',
    creeLe: 'creeLe',
    modifieLe: 'modifieLe'
  };

  export type AbsenceScalarFieldEnum = (typeof AbsenceScalarFieldEnum)[keyof typeof AbsenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    twoFactorSecret: 'twoFactorSecret'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const EmployeeOrderByRelevanceFieldEnum: {
    employeeId: 'employeeId',
    department: 'department',
    position: 'position',
    phone: 'phone',
    address: 'address',
    qrCode: 'qrCode'
  };

  export type EmployeeOrderByRelevanceFieldEnum = (typeof EmployeeOrderByRelevanceFieldEnum)[keyof typeof EmployeeOrderByRelevanceFieldEnum]


  export const EntrepriseOrderByRelevanceFieldEnum: {
    nom: 'nom',
    adresse: 'adresse',
    telephone: 'telephone',
    email: 'email',
    siteWeb: 'siteWeb',
    logo: 'logo',
    couleurPrimaire: 'couleurPrimaire',
    couleurSecondaire: 'couleurSecondaire',
    couleurDashboard: 'couleurDashboard',
    description: 'description',
    devise: 'devise',
    timezone: 'timezone',
    periodePayroll: 'periodePayroll'
  };

  export type EntrepriseOrderByRelevanceFieldEnum = (typeof EntrepriseOrderByRelevanceFieldEnum)[keyof typeof EntrepriseOrderByRelevanceFieldEnum]


  export const JournalAuditOrderByRelevanceFieldEnum: {
    action: 'action',
    nomTable: 'nomTable'
  };

  export type JournalAuditOrderByRelevanceFieldEnum = (typeof JournalAuditOrderByRelevanceFieldEnum)[keyof typeof JournalAuditOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    reference: 'reference',
    notes: 'notes'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    title: 'title',
    message: 'message',
    category: 'category',
    link: 'link'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const CompanyFactureOrderByRelevanceFieldEnum: {
    numeroFacture: 'numeroFacture',
    description: 'description'
  };

  export type CompanyFactureOrderByRelevanceFieldEnum = (typeof CompanyFactureOrderByRelevanceFieldEnum)[keyof typeof CompanyFactureOrderByRelevanceFieldEnum]


  export const CompanyLigneFactureOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type CompanyLigneFactureOrderByRelevanceFieldEnum = (typeof CompanyLigneFactureOrderByRelevanceFieldEnum)[keyof typeof CompanyLigneFactureOrderByRelevanceFieldEnum]


  export const CompanyPayRunOrderByRelevanceFieldEnum: {
    reference: 'reference'
  };

  export type CompanyPayRunOrderByRelevanceFieldEnum = (typeof CompanyPayRunOrderByRelevanceFieldEnum)[keyof typeof CompanyPayRunOrderByRelevanceFieldEnum]


  export const CompanyBulletinOrderByRelevanceFieldEnum: {
    numeroBulletin: 'numeroBulletin',
    statutPaiement: 'statutPaiement',
    cheminPDF: 'cheminPDF'
  };

  export type CompanyBulletinOrderByRelevanceFieldEnum = (typeof CompanyBulletinOrderByRelevanceFieldEnum)[keyof typeof CompanyBulletinOrderByRelevanceFieldEnum]


  export const CompanyPaiementOrderByRelevanceFieldEnum: {
    referenceTransaction: 'referenceTransaction',
    methodePaiement: 'methodePaiement',
    referencePaiement: 'referencePaiement',
    notes: 'notes',
    cheminRecu: 'cheminRecu',
    statut: 'statut'
  };

  export type CompanyPaiementOrderByRelevanceFieldEnum = (typeof CompanyPaiementOrderByRelevanceFieldEnum)[keyof typeof CompanyPaiementOrderByRelevanceFieldEnum]


  export const CompanyTemplateOrderByRelevanceFieldEnum: {
    typeTemplate: 'typeTemplate',
    nom: 'nom',
    contenu: 'contenu'
  };

  export type CompanyTemplateOrderByRelevanceFieldEnum = (typeof CompanyTemplateOrderByRelevanceFieldEnum)[keyof typeof CompanyTemplateOrderByRelevanceFieldEnum]


  export const CompanySettingOrderByRelevanceFieldEnum: {
    cle: 'cle',
    valeur: 'valeur',
    description: 'description',
    typeData: 'typeData'
  };

  export type CompanySettingOrderByRelevanceFieldEnum = (typeof CompanySettingOrderByRelevanceFieldEnum)[keyof typeof CompanySettingOrderByRelevanceFieldEnum]


  export const CompanyDocumentOrderByRelevanceFieldEnum: {
    type: 'type',
    titre: 'titre',
    description: 'description',
    cheminFichier: 'cheminFichier',
    mimeType: 'mimeType',
    tags: 'tags'
  };

  export type CompanyDocumentOrderByRelevanceFieldEnum = (typeof CompanyDocumentOrderByRelevanceFieldEnum)[keyof typeof CompanyDocumentOrderByRelevanceFieldEnum]


  export const CompanyModeleDocumentOrderByRelevanceFieldEnum: {
    nom: 'nom',
    description: 'description',
    type: 'type',
    contenu: 'contenu'
  };

  export type CompanyModeleDocumentOrderByRelevanceFieldEnum = (typeof CompanyModeleDocumentOrderByRelevanceFieldEnum)[keyof typeof CompanyModeleDocumentOrderByRelevanceFieldEnum]


  export const CompanyPeriodePaieOrderByRelevanceFieldEnum: {
    nom: 'nom',
    notes: 'notes'
  };

  export type CompanyPeriodePaieOrderByRelevanceFieldEnum = (typeof CompanyPeriodePaieOrderByRelevanceFieldEnum)[keyof typeof CompanyPeriodePaieOrderByRelevanceFieldEnum]


  export const CompanyConfigurationPaieOrderByRelevanceFieldEnum: {
    periodeCalcul: 'periodeCalcul',
    regleArrondi: 'regleArrondi',
    deviseSecondaire: 'deviseSecondaire'
  };

  export type CompanyConfigurationPaieOrderByRelevanceFieldEnum = (typeof CompanyConfigurationPaieOrderByRelevanceFieldEnum)[keyof typeof CompanyConfigurationPaieOrderByRelevanceFieldEnum]


  export const CompanyHistoriqueSalaireOrderByRelevanceFieldEnum: {
    motif: 'motif',
    notes: 'notes'
  };

  export type CompanyHistoriqueSalaireOrderByRelevanceFieldEnum = (typeof CompanyHistoriqueSalaireOrderByRelevanceFieldEnum)[keyof typeof CompanyHistoriqueSalaireOrderByRelevanceFieldEnum]


  export const CompanyRegleDeductionOrderByRelevanceFieldEnum: {
    nom: 'nom',
    description: 'description',
    type: 'type',
    formule: 'formule'
  };

  export type CompanyRegleDeductionOrderByRelevanceFieldEnum = (typeof CompanyRegleDeductionOrderByRelevanceFieldEnum)[keyof typeof CompanyRegleDeductionOrderByRelevanceFieldEnum]


  export const PointageOrderByRelevanceFieldEnum: {
    commentaire: 'commentaire',
    ipAddress: 'ipAddress',
    deviceInfo: 'deviceInfo'
  };

  export type PointageOrderByRelevanceFieldEnum = (typeof PointageOrderByRelevanceFieldEnum)[keyof typeof PointageOrderByRelevanceFieldEnum]


  export const ReglePointageOrderByRelevanceFieldEnum: {
    heureDebut: 'heureDebut',
    heureFin: 'heureFin',
    plageHoraireMin: 'plageHoraireMin',
    plageHoraireMax: 'plageHoraireMax'
  };

  export type ReglePointageOrderByRelevanceFieldEnum = (typeof ReglePointageOrderByRelevanceFieldEnum)[keyof typeof ReglePointageOrderByRelevanceFieldEnum]


  export const AbsenceOrderByRelevanceFieldEnum: {
    motif: 'motif',
    commentaire: 'commentaire',
    pieceJointe: 'pieceJointe'
  };

  export type AbsenceOrderByRelevanceFieldEnum = (typeof AbsenceOrderByRelevanceFieldEnum)[keyof typeof AbsenceOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ContractType'
   */
  export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'EmployeeStatus'
   */
  export type EnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'CompanyStatutFacture'
   */
  export type EnumCompanyStatutFactureFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatutFacture'>
    


  /**
   * Reference to a field of type 'CompanyStatutPayRun'
   */
  export type EnumCompanyStatutPayRunFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatutPayRun'>
    


  /**
   * Reference to a field of type 'StatutPointage'
   */
  export type EnumStatutPointageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutPointage'>
    


  /**
   * Reference to a field of type 'TypePointage'
   */
  export type EnumTypePointageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypePointage'>
    


  /**
   * Reference to a field of type 'TypeAbsence'
   */
  export type EnumTypeAbsenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeAbsence'>
    


  /**
   * Reference to a field of type 'StatutAbsence'
   */
  export type EnumStatutAbsenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutAbsence'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    permissions?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    journalAudit?: JournalAuditListRelationFilter
    processedPayments?: PaymentListRelationFilter
    notifications?: NotificationListRelationFilter
    createdFactures?: CompanyFactureListRelationFilter
    createdPayRuns?: CompanyPayRunListRelationFilter
    approvedPayRuns?: CompanyPayRunListRelationFilter
    processedPaymentsCompany?: CompanyPaiementListRelationFilter
    uploadedDocuments?: CompanyDocumentListRelationFilter
    createdModeles?: CompanyModeleDocumentListRelationFilter
    modifiedSalaries?: CompanyHistoriqueSalaireListRelationFilter
    validatedPointages?: PointageListRelationFilter
    approvedAbsences?: AbsenceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    journalAudit?: JournalAuditOrderByRelationAggregateInput
    processedPayments?: PaymentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    createdFactures?: CompanyFactureOrderByRelationAggregateInput
    createdPayRuns?: CompanyPayRunOrderByRelationAggregateInput
    approvedPayRuns?: CompanyPayRunOrderByRelationAggregateInput
    processedPaymentsCompany?: CompanyPaiementOrderByRelationAggregateInput
    uploadedDocuments?: CompanyDocumentOrderByRelationAggregateInput
    createdModeles?: CompanyModeleDocumentOrderByRelationAggregateInput
    modifiedSalaries?: CompanyHistoriqueSalaireOrderByRelationAggregateInput
    validatedPointages?: PointageOrderByRelationAggregateInput
    approvedAbsences?: AbsenceOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    permissions?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    journalAudit?: JournalAuditListRelationFilter
    processedPayments?: PaymentListRelationFilter
    notifications?: NotificationListRelationFilter
    createdFactures?: CompanyFactureListRelationFilter
    createdPayRuns?: CompanyPayRunListRelationFilter
    approvedPayRuns?: CompanyPayRunListRelationFilter
    processedPaymentsCompany?: CompanyPaiementListRelationFilter
    uploadedDocuments?: CompanyDocumentListRelationFilter
    createdModeles?: CompanyModeleDocumentListRelationFilter
    modifiedSalaries?: CompanyHistoriqueSalaireListRelationFilter
    validatedPointages?: PointageListRelationFilter
    approvedAbsences?: AbsenceListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    permissions?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    userId?: IntFilter<"Employee"> | number
    entrepriseId?: IntFilter<"Employee"> | number
    employeeId?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    contractType?: EnumContractTypeFilter<"Employee"> | $Enums.ContractType
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    dailyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    qrCode?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    payments?: PaymentListRelationFilter
    factures?: CompanyFactureListRelationFilter
    bulletins?: CompanyBulletinListRelationFilter
    documents?: CompanyDocumentListRelationFilter
    salaryHistory?: CompanyHistoriqueSalaireListRelationFilter
    pointages?: PointageListRelationFilter
    absences?: AbsenceListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    entrepriseId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    contractType?: SortOrder
    salary?: SortOrderInput | SortOrder
    dailyRate?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    entreprise?: EntrepriseOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    factures?: CompanyFactureOrderByRelationAggregateInput
    bulletins?: CompanyBulletinOrderByRelationAggregateInput
    documents?: CompanyDocumentOrderByRelationAggregateInput
    salaryHistory?: CompanyHistoriqueSalaireOrderByRelationAggregateInput
    pointages?: PointageOrderByRelationAggregateInput
    absences?: AbsenceOrderByRelationAggregateInput
    _relevance?: EmployeeOrderByRelevanceInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    employeeId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    entrepriseId?: IntFilter<"Employee"> | number
    department?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    contractType?: EnumContractTypeFilter<"Employee"> | $Enums.ContractType
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    dailyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    qrCode?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    payments?: PaymentListRelationFilter
    factures?: CompanyFactureListRelationFilter
    bulletins?: CompanyBulletinListRelationFilter
    documents?: CompanyDocumentListRelationFilter
    salaryHistory?: CompanyHistoriqueSalaireListRelationFilter
    pointages?: PointageListRelationFilter
    absences?: AbsenceListRelationFilter
  }, "id" | "userId" | "employeeId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    entrepriseId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    contractType?: SortOrder
    salary?: SortOrderInput | SortOrder
    dailyRate?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    userId?: IntWithAggregatesFilter<"Employee"> | number
    entrepriseId?: IntWithAggregatesFilter<"Employee"> | number
    employeeId?: StringWithAggregatesFilter<"Employee"> | string
    department?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    position?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    contractType?: EnumContractTypeWithAggregatesFilter<"Employee"> | $Enums.ContractType
    salary?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    dailyRate?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: DecimalNullableWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusWithAggregatesFilter<"Employee"> | $Enums.EmployeeStatus
    qrCode?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type EntrepriseWhereInput = {
    AND?: EntrepriseWhereInput | EntrepriseWhereInput[]
    OR?: EntrepriseWhereInput[]
    NOT?: EntrepriseWhereInput | EntrepriseWhereInput[]
    id?: IntFilter<"Entreprise"> | number
    nom?: StringFilter<"Entreprise"> | string
    adresse?: StringNullableFilter<"Entreprise"> | string | null
    telephone?: StringNullableFilter<"Entreprise"> | string | null
    email?: StringNullableFilter<"Entreprise"> | string | null
    siteWeb?: StringNullableFilter<"Entreprise"> | string | null
    logo?: StringNullableFilter<"Entreprise"> | string | null
    couleurPrimaire?: StringNullableFilter<"Entreprise"> | string | null
    couleurSecondaire?: StringNullableFilter<"Entreprise"> | string | null
    couleurDashboard?: StringNullableFilter<"Entreprise"> | string | null
    description?: StringNullableFilter<"Entreprise"> | string | null
    devise?: StringFilter<"Entreprise"> | string
    timezone?: StringFilter<"Entreprise"> | string
    periodePayroll?: StringFilter<"Entreprise"> | string
    estActive?: BoolFilter<"Entreprise"> | boolean
    parametres?: JsonNullableFilter<"Entreprise">
    creeLe?: DateTimeFilter<"Entreprise"> | Date | string
    modifieLe?: DateTimeFilter<"Entreprise"> | Date | string
    employees?: EmployeeListRelationFilter
    payRuns?: CompanyPayRunListRelationFilter
    templates?: CompanyTemplateListRelationFilter
    settings?: CompanySettingListRelationFilter
    modeles?: CompanyModeleDocumentListRelationFilter
    periodesPaie?: CompanyPeriodePaieListRelationFilter
    configurationsPaie?: CompanyConfigurationPaieListRelationFilter
    reglePointage?: XOR<ReglePointageNullableScalarRelationFilter, ReglePointageWhereInput> | null
  }

  export type EntrepriseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    siteWeb?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    couleurPrimaire?: SortOrderInput | SortOrder
    couleurSecondaire?: SortOrderInput | SortOrder
    couleurDashboard?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    devise?: SortOrder
    timezone?: SortOrder
    periodePayroll?: SortOrder
    estActive?: SortOrder
    parametres?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    payRuns?: CompanyPayRunOrderByRelationAggregateInput
    templates?: CompanyTemplateOrderByRelationAggregateInput
    settings?: CompanySettingOrderByRelationAggregateInput
    modeles?: CompanyModeleDocumentOrderByRelationAggregateInput
    periodesPaie?: CompanyPeriodePaieOrderByRelationAggregateInput
    configurationsPaie?: CompanyConfigurationPaieOrderByRelationAggregateInput
    reglePointage?: ReglePointageOrderByWithRelationInput
    _relevance?: EntrepriseOrderByRelevanceInput
  }

  export type EntrepriseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntrepriseWhereInput | EntrepriseWhereInput[]
    OR?: EntrepriseWhereInput[]
    NOT?: EntrepriseWhereInput | EntrepriseWhereInput[]
    nom?: StringFilter<"Entreprise"> | string
    adresse?: StringNullableFilter<"Entreprise"> | string | null
    telephone?: StringNullableFilter<"Entreprise"> | string | null
    email?: StringNullableFilter<"Entreprise"> | string | null
    siteWeb?: StringNullableFilter<"Entreprise"> | string | null
    logo?: StringNullableFilter<"Entreprise"> | string | null
    couleurPrimaire?: StringNullableFilter<"Entreprise"> | string | null
    couleurSecondaire?: StringNullableFilter<"Entreprise"> | string | null
    couleurDashboard?: StringNullableFilter<"Entreprise"> | string | null
    description?: StringNullableFilter<"Entreprise"> | string | null
    devise?: StringFilter<"Entreprise"> | string
    timezone?: StringFilter<"Entreprise"> | string
    periodePayroll?: StringFilter<"Entreprise"> | string
    estActive?: BoolFilter<"Entreprise"> | boolean
    parametres?: JsonNullableFilter<"Entreprise">
    creeLe?: DateTimeFilter<"Entreprise"> | Date | string
    modifieLe?: DateTimeFilter<"Entreprise"> | Date | string
    employees?: EmployeeListRelationFilter
    payRuns?: CompanyPayRunListRelationFilter
    templates?: CompanyTemplateListRelationFilter
    settings?: CompanySettingListRelationFilter
    modeles?: CompanyModeleDocumentListRelationFilter
    periodesPaie?: CompanyPeriodePaieListRelationFilter
    configurationsPaie?: CompanyConfigurationPaieListRelationFilter
    reglePointage?: XOR<ReglePointageNullableScalarRelationFilter, ReglePointageWhereInput> | null
  }, "id">

  export type EntrepriseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    siteWeb?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    couleurPrimaire?: SortOrderInput | SortOrder
    couleurSecondaire?: SortOrderInput | SortOrder
    couleurDashboard?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    devise?: SortOrder
    timezone?: SortOrder
    periodePayroll?: SortOrder
    estActive?: SortOrder
    parametres?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: EntrepriseCountOrderByAggregateInput
    _avg?: EntrepriseAvgOrderByAggregateInput
    _max?: EntrepriseMaxOrderByAggregateInput
    _min?: EntrepriseMinOrderByAggregateInput
    _sum?: EntrepriseSumOrderByAggregateInput
  }

  export type EntrepriseScalarWhereWithAggregatesInput = {
    AND?: EntrepriseScalarWhereWithAggregatesInput | EntrepriseScalarWhereWithAggregatesInput[]
    OR?: EntrepriseScalarWhereWithAggregatesInput[]
    NOT?: EntrepriseScalarWhereWithAggregatesInput | EntrepriseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entreprise"> | number
    nom?: StringWithAggregatesFilter<"Entreprise"> | string
    adresse?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    email?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    siteWeb?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    couleurPrimaire?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    couleurSecondaire?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    couleurDashboard?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    description?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    devise?: StringWithAggregatesFilter<"Entreprise"> | string
    timezone?: StringWithAggregatesFilter<"Entreprise"> | string
    periodePayroll?: StringWithAggregatesFilter<"Entreprise"> | string
    estActive?: BoolWithAggregatesFilter<"Entreprise"> | boolean
    parametres?: JsonNullableWithAggregatesFilter<"Entreprise">
    creeLe?: DateTimeWithAggregatesFilter<"Entreprise"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"Entreprise"> | Date | string
  }

  export type JournalAuditWhereInput = {
    AND?: JournalAuditWhereInput | JournalAuditWhereInput[]
    OR?: JournalAuditWhereInput[]
    NOT?: JournalAuditWhereInput | JournalAuditWhereInput[]
    id?: IntFilter<"JournalAudit"> | number
    utilisateurId?: IntNullableFilter<"JournalAudit"> | number | null
    action?: StringFilter<"JournalAudit"> | string
    nomTable?: StringFilter<"JournalAudit"> | string
    idEnregistrement?: IntNullableFilter<"JournalAudit"> | number | null
    anciennes_valeurs?: JsonNullableFilter<"JournalAudit">
    nouvelles_valeurs?: JsonNullableFilter<"JournalAudit">
    creeLe?: DateTimeFilter<"JournalAudit"> | Date | string
    utilisateur?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type JournalAuditOrderByWithRelationInput = {
    id?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    action?: SortOrder
    nomTable?: SortOrder
    idEnregistrement?: SortOrderInput | SortOrder
    anciennes_valeurs?: SortOrderInput | SortOrder
    nouvelles_valeurs?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    utilisateur?: UserOrderByWithRelationInput
    _relevance?: JournalAuditOrderByRelevanceInput
  }

  export type JournalAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JournalAuditWhereInput | JournalAuditWhereInput[]
    OR?: JournalAuditWhereInput[]
    NOT?: JournalAuditWhereInput | JournalAuditWhereInput[]
    utilisateurId?: IntNullableFilter<"JournalAudit"> | number | null
    action?: StringFilter<"JournalAudit"> | string
    nomTable?: StringFilter<"JournalAudit"> | string
    idEnregistrement?: IntNullableFilter<"JournalAudit"> | number | null
    anciennes_valeurs?: JsonNullableFilter<"JournalAudit">
    nouvelles_valeurs?: JsonNullableFilter<"JournalAudit">
    creeLe?: DateTimeFilter<"JournalAudit"> | Date | string
    utilisateur?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type JournalAuditOrderByWithAggregationInput = {
    id?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    action?: SortOrder
    nomTable?: SortOrder
    idEnregistrement?: SortOrderInput | SortOrder
    anciennes_valeurs?: SortOrderInput | SortOrder
    nouvelles_valeurs?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    _count?: JournalAuditCountOrderByAggregateInput
    _avg?: JournalAuditAvgOrderByAggregateInput
    _max?: JournalAuditMaxOrderByAggregateInput
    _min?: JournalAuditMinOrderByAggregateInput
    _sum?: JournalAuditSumOrderByAggregateInput
  }

  export type JournalAuditScalarWhereWithAggregatesInput = {
    AND?: JournalAuditScalarWhereWithAggregatesInput | JournalAuditScalarWhereWithAggregatesInput[]
    OR?: JournalAuditScalarWhereWithAggregatesInput[]
    NOT?: JournalAuditScalarWhereWithAggregatesInput | JournalAuditScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JournalAudit"> | number
    utilisateurId?: IntNullableWithAggregatesFilter<"JournalAudit"> | number | null
    action?: StringWithAggregatesFilter<"JournalAudit"> | string
    nomTable?: StringWithAggregatesFilter<"JournalAudit"> | string
    idEnregistrement?: IntNullableWithAggregatesFilter<"JournalAudit"> | number | null
    anciennes_valeurs?: JsonNullableWithAggregatesFilter<"JournalAudit">
    nouvelles_valeurs?: JsonNullableWithAggregatesFilter<"JournalAudit">
    creeLe?: DateTimeWithAggregatesFilter<"JournalAudit"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    employeeId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Payment"> | string | null
    processedBy?: IntNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    cashier?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    cashier?: UserOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    employeeId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Payment"> | string | null
    processedBy?: IntNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    cashier?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "reference">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    employeeId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    processedBy?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    link?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    category?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type CompanyFactureWhereInput = {
    AND?: CompanyFactureWhereInput | CompanyFactureWhereInput[]
    OR?: CompanyFactureWhereInput[]
    NOT?: CompanyFactureWhereInput | CompanyFactureWhereInput[]
    id?: IntFilter<"CompanyFacture"> | number
    employeeId?: IntFilter<"CompanyFacture"> | number
    numeroFacture?: StringFilter<"CompanyFacture"> | string
    montant?: DecimalFilter<"CompanyFacture"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"CompanyFacture"> | string | null
    statut?: EnumCompanyStatutFactureFilter<"CompanyFacture"> | $Enums.CompanyStatutFacture
    dateEcheance?: DateTimeNullableFilter<"CompanyFacture"> | Date | string | null
    datePaiement?: DateTimeNullableFilter<"CompanyFacture"> | Date | string | null
    creePar?: IntFilter<"CompanyFacture"> | number
    creeLe?: DateTimeFilter<"CompanyFacture"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyFacture"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    lignesFacture?: CompanyLigneFactureListRelationFilter
  }

  export type CompanyFactureOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    numeroFacture?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    statut?: SortOrder
    dateEcheance?: SortOrderInput | SortOrder
    datePaiement?: SortOrderInput | SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    lignesFacture?: CompanyLigneFactureOrderByRelationAggregateInput
    _relevance?: CompanyFactureOrderByRelevanceInput
  }

  export type CompanyFactureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    numeroFacture?: string
    AND?: CompanyFactureWhereInput | CompanyFactureWhereInput[]
    OR?: CompanyFactureWhereInput[]
    NOT?: CompanyFactureWhereInput | CompanyFactureWhereInput[]
    employeeId?: IntFilter<"CompanyFacture"> | number
    montant?: DecimalFilter<"CompanyFacture"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"CompanyFacture"> | string | null
    statut?: EnumCompanyStatutFactureFilter<"CompanyFacture"> | $Enums.CompanyStatutFacture
    dateEcheance?: DateTimeNullableFilter<"CompanyFacture"> | Date | string | null
    datePaiement?: DateTimeNullableFilter<"CompanyFacture"> | Date | string | null
    creePar?: IntFilter<"CompanyFacture"> | number
    creeLe?: DateTimeFilter<"CompanyFacture"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyFacture"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    lignesFacture?: CompanyLigneFactureListRelationFilter
  }, "id" | "numeroFacture">

  export type CompanyFactureOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    numeroFacture?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    statut?: SortOrder
    dateEcheance?: SortOrderInput | SortOrder
    datePaiement?: SortOrderInput | SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyFactureCountOrderByAggregateInput
    _avg?: CompanyFactureAvgOrderByAggregateInput
    _max?: CompanyFactureMaxOrderByAggregateInput
    _min?: CompanyFactureMinOrderByAggregateInput
    _sum?: CompanyFactureSumOrderByAggregateInput
  }

  export type CompanyFactureScalarWhereWithAggregatesInput = {
    AND?: CompanyFactureScalarWhereWithAggregatesInput | CompanyFactureScalarWhereWithAggregatesInput[]
    OR?: CompanyFactureScalarWhereWithAggregatesInput[]
    NOT?: CompanyFactureScalarWhereWithAggregatesInput | CompanyFactureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyFacture"> | number
    employeeId?: IntWithAggregatesFilter<"CompanyFacture"> | number
    numeroFacture?: StringWithAggregatesFilter<"CompanyFacture"> | string
    montant?: DecimalWithAggregatesFilter<"CompanyFacture"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"CompanyFacture"> | string | null
    statut?: EnumCompanyStatutFactureWithAggregatesFilter<"CompanyFacture"> | $Enums.CompanyStatutFacture
    dateEcheance?: DateTimeNullableWithAggregatesFilter<"CompanyFacture"> | Date | string | null
    datePaiement?: DateTimeNullableWithAggregatesFilter<"CompanyFacture"> | Date | string | null
    creePar?: IntWithAggregatesFilter<"CompanyFacture"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyFacture"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyFacture"> | Date | string
  }

  export type CompanyLigneFactureWhereInput = {
    AND?: CompanyLigneFactureWhereInput | CompanyLigneFactureWhereInput[]
    OR?: CompanyLigneFactureWhereInput[]
    NOT?: CompanyLigneFactureWhereInput | CompanyLigneFactureWhereInput[]
    id?: IntFilter<"CompanyLigneFacture"> | number
    factureId?: IntFilter<"CompanyLigneFacture"> | number
    description?: StringFilter<"CompanyLigneFacture"> | string
    quantite?: IntFilter<"CompanyLigneFacture"> | number
    prixUnitaire?: DecimalFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFilter<"CompanyLigneFacture"> | Date | string
    facture?: XOR<CompanyFactureScalarRelationFilter, CompanyFactureWhereInput>
  }

  export type CompanyLigneFactureOrderByWithRelationInput = {
    id?: SortOrder
    factureId?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    creeLe?: SortOrder
    facture?: CompanyFactureOrderByWithRelationInput
    _relevance?: CompanyLigneFactureOrderByRelevanceInput
  }

  export type CompanyLigneFactureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyLigneFactureWhereInput | CompanyLigneFactureWhereInput[]
    OR?: CompanyLigneFactureWhereInput[]
    NOT?: CompanyLigneFactureWhereInput | CompanyLigneFactureWhereInput[]
    factureId?: IntFilter<"CompanyLigneFacture"> | number
    description?: StringFilter<"CompanyLigneFacture"> | string
    quantite?: IntFilter<"CompanyLigneFacture"> | number
    prixUnitaire?: DecimalFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFilter<"CompanyLigneFacture"> | Date | string
    facture?: XOR<CompanyFactureScalarRelationFilter, CompanyFactureWhereInput>
  }, "id">

  export type CompanyLigneFactureOrderByWithAggregationInput = {
    id?: SortOrder
    factureId?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    creeLe?: SortOrder
    _count?: CompanyLigneFactureCountOrderByAggregateInput
    _avg?: CompanyLigneFactureAvgOrderByAggregateInput
    _max?: CompanyLigneFactureMaxOrderByAggregateInput
    _min?: CompanyLigneFactureMinOrderByAggregateInput
    _sum?: CompanyLigneFactureSumOrderByAggregateInput
  }

  export type CompanyLigneFactureScalarWhereWithAggregatesInput = {
    AND?: CompanyLigneFactureScalarWhereWithAggregatesInput | CompanyLigneFactureScalarWhereWithAggregatesInput[]
    OR?: CompanyLigneFactureScalarWhereWithAggregatesInput[]
    NOT?: CompanyLigneFactureScalarWhereWithAggregatesInput | CompanyLigneFactureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyLigneFacture"> | number
    factureId?: IntWithAggregatesFilter<"CompanyLigneFacture"> | number
    description?: StringWithAggregatesFilter<"CompanyLigneFacture"> | string
    quantite?: IntWithAggregatesFilter<"CompanyLigneFacture"> | number
    prixUnitaire?: DecimalWithAggregatesFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalWithAggregatesFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeWithAggregatesFilter<"CompanyLigneFacture"> | Date | string
  }

  export type CompanyPayRunWhereInput = {
    AND?: CompanyPayRunWhereInput | CompanyPayRunWhereInput[]
    OR?: CompanyPayRunWhereInput[]
    NOT?: CompanyPayRunWhereInput | CompanyPayRunWhereInput[]
    id?: IntFilter<"CompanyPayRun"> | number
    reference?: StringFilter<"CompanyPayRun"> | string
    dateDebut?: DateTimeFilter<"CompanyPayRun"> | Date | string
    dateFin?: DateTimeFilter<"CompanyPayRun"> | Date | string
    datePaiement?: DateTimeFilter<"CompanyPayRun"> | Date | string
    statut?: EnumCompanyStatutPayRunFilter<"CompanyPayRun"> | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFilter<"CompanyPayRun"> | number
    metadata?: JsonNullableFilter<"CompanyPayRun">
    entrepriseId?: IntFilter<"CompanyPayRun"> | number
    periodePaieId?: IntFilter<"CompanyPayRun"> | number
    creePar?: IntFilter<"CompanyPayRun"> | number
    creeLe?: DateTimeFilter<"CompanyPayRun"> | Date | string
    approuveLe?: DateTimeNullableFilter<"CompanyPayRun"> | Date | string | null
    approuvePar?: IntNullableFilter<"CompanyPayRun"> | number | null
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    periodePaie?: XOR<CompanyPeriodePaieScalarRelationFilter, CompanyPeriodePaieWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bulletins?: CompanyBulletinListRelationFilter
  }

  export type CompanyPayRunOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    datePaiement?: SortOrder
    statut?: SortOrder
    totalBrut?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
    nombreEmployes?: SortOrder
    metadata?: SortOrderInput | SortOrder
    entrepriseId?: SortOrder
    periodePaieId?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    approuveLe?: SortOrderInput | SortOrder
    approuvePar?: SortOrderInput | SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    periodePaie?: CompanyPeriodePaieOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    bulletins?: CompanyBulletinOrderByRelationAggregateInput
    _relevance?: CompanyPayRunOrderByRelevanceInput
  }

  export type CompanyPayRunWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    reference?: string
    AND?: CompanyPayRunWhereInput | CompanyPayRunWhereInput[]
    OR?: CompanyPayRunWhereInput[]
    NOT?: CompanyPayRunWhereInput | CompanyPayRunWhereInput[]
    dateDebut?: DateTimeFilter<"CompanyPayRun"> | Date | string
    dateFin?: DateTimeFilter<"CompanyPayRun"> | Date | string
    datePaiement?: DateTimeFilter<"CompanyPayRun"> | Date | string
    statut?: EnumCompanyStatutPayRunFilter<"CompanyPayRun"> | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFilter<"CompanyPayRun"> | number
    metadata?: JsonNullableFilter<"CompanyPayRun">
    entrepriseId?: IntFilter<"CompanyPayRun"> | number
    periodePaieId?: IntFilter<"CompanyPayRun"> | number
    creePar?: IntFilter<"CompanyPayRun"> | number
    creeLe?: DateTimeFilter<"CompanyPayRun"> | Date | string
    approuveLe?: DateTimeNullableFilter<"CompanyPayRun"> | Date | string | null
    approuvePar?: IntNullableFilter<"CompanyPayRun"> | number | null
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    periodePaie?: XOR<CompanyPeriodePaieScalarRelationFilter, CompanyPeriodePaieWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bulletins?: CompanyBulletinListRelationFilter
  }, "id" | "reference">

  export type CompanyPayRunOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    datePaiement?: SortOrder
    statut?: SortOrder
    totalBrut?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
    nombreEmployes?: SortOrder
    metadata?: SortOrderInput | SortOrder
    entrepriseId?: SortOrder
    periodePaieId?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    approuveLe?: SortOrderInput | SortOrder
    approuvePar?: SortOrderInput | SortOrder
    _count?: CompanyPayRunCountOrderByAggregateInput
    _avg?: CompanyPayRunAvgOrderByAggregateInput
    _max?: CompanyPayRunMaxOrderByAggregateInput
    _min?: CompanyPayRunMinOrderByAggregateInput
    _sum?: CompanyPayRunSumOrderByAggregateInput
  }

  export type CompanyPayRunScalarWhereWithAggregatesInput = {
    AND?: CompanyPayRunScalarWhereWithAggregatesInput | CompanyPayRunScalarWhereWithAggregatesInput[]
    OR?: CompanyPayRunScalarWhereWithAggregatesInput[]
    NOT?: CompanyPayRunScalarWhereWithAggregatesInput | CompanyPayRunScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyPayRun"> | number
    reference?: StringWithAggregatesFilter<"CompanyPayRun"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"CompanyPayRun"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"CompanyPayRun"> | Date | string
    datePaiement?: DateTimeWithAggregatesFilter<"CompanyPayRun"> | Date | string
    statut?: EnumCompanyStatutPayRunWithAggregatesFilter<"CompanyPayRun"> | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalWithAggregatesFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalWithAggregatesFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalWithAggregatesFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntWithAggregatesFilter<"CompanyPayRun"> | number
    metadata?: JsonNullableWithAggregatesFilter<"CompanyPayRun">
    entrepriseId?: IntWithAggregatesFilter<"CompanyPayRun"> | number
    periodePaieId?: IntWithAggregatesFilter<"CompanyPayRun"> | number
    creePar?: IntWithAggregatesFilter<"CompanyPayRun"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyPayRun"> | Date | string
    approuveLe?: DateTimeNullableWithAggregatesFilter<"CompanyPayRun"> | Date | string | null
    approuvePar?: IntNullableWithAggregatesFilter<"CompanyPayRun"> | number | null
  }

  export type CompanyBulletinWhereInput = {
    AND?: CompanyBulletinWhereInput | CompanyBulletinWhereInput[]
    OR?: CompanyBulletinWhereInput[]
    NOT?: CompanyBulletinWhereInput | CompanyBulletinWhereInput[]
    id?: IntFilter<"CompanyBulletin"> | number
    numeroBulletin?: StringFilter<"CompanyBulletin"> | string
    datePaiement?: DateTimeFilter<"CompanyBulletin"> | Date | string
    joursTravailles?: IntFilter<"CompanyBulletin"> | number
    heuresTravailes?: IntFilter<"CompanyBulletin"> | number
    salaireBrut?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    deductions?: JsonFilter<"CompanyBulletin">
    totalDeductions?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFilter<"CompanyBulletin"> | string
    cheminPDF?: StringNullableFilter<"CompanyBulletin"> | string | null
    calculs?: JsonNullableFilter<"CompanyBulletin">
    estVerrouille?: BoolFilter<"CompanyBulletin"> | boolean
    payRunId?: IntFilter<"CompanyBulletin"> | number
    employeId?: IntFilter<"CompanyBulletin"> | number
    creeLe?: DateTimeFilter<"CompanyBulletin"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyBulletin"> | Date | string
    payRun?: XOR<CompanyPayRunScalarRelationFilter, CompanyPayRunWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    paiements?: CompanyPaiementListRelationFilter
  }

  export type CompanyBulletinOrderByWithRelationInput = {
    id?: SortOrder
    numeroBulletin?: SortOrder
    datePaiement?: SortOrder
    joursTravailles?: SortOrder
    heuresTravailes?: SortOrder
    salaireBrut?: SortOrder
    salaireBase?: SortOrder
    montantHeuresSupp?: SortOrder
    montantBonus?: SortOrder
    indemnites?: SortOrder
    deductions?: SortOrder
    totalDeductions?: SortOrder
    salaireNet?: SortOrder
    montantPaye?: SortOrder
    resteAPayer?: SortOrder
    statutPaiement?: SortOrder
    cheminPDF?: SortOrderInput | SortOrder
    calculs?: SortOrderInput | SortOrder
    estVerrouille?: SortOrder
    payRunId?: SortOrder
    employeId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    payRun?: CompanyPayRunOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    paiements?: CompanyPaiementOrderByRelationAggregateInput
    _relevance?: CompanyBulletinOrderByRelevanceInput
  }

  export type CompanyBulletinWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    numeroBulletin?: string
    AND?: CompanyBulletinWhereInput | CompanyBulletinWhereInput[]
    OR?: CompanyBulletinWhereInput[]
    NOT?: CompanyBulletinWhereInput | CompanyBulletinWhereInput[]
    datePaiement?: DateTimeFilter<"CompanyBulletin"> | Date | string
    joursTravailles?: IntFilter<"CompanyBulletin"> | number
    heuresTravailes?: IntFilter<"CompanyBulletin"> | number
    salaireBrut?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    deductions?: JsonFilter<"CompanyBulletin">
    totalDeductions?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFilter<"CompanyBulletin"> | string
    cheminPDF?: StringNullableFilter<"CompanyBulletin"> | string | null
    calculs?: JsonNullableFilter<"CompanyBulletin">
    estVerrouille?: BoolFilter<"CompanyBulletin"> | boolean
    payRunId?: IntFilter<"CompanyBulletin"> | number
    employeId?: IntFilter<"CompanyBulletin"> | number
    creeLe?: DateTimeFilter<"CompanyBulletin"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyBulletin"> | Date | string
    payRun?: XOR<CompanyPayRunScalarRelationFilter, CompanyPayRunWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    paiements?: CompanyPaiementListRelationFilter
  }, "id" | "numeroBulletin">

  export type CompanyBulletinOrderByWithAggregationInput = {
    id?: SortOrder
    numeroBulletin?: SortOrder
    datePaiement?: SortOrder
    joursTravailles?: SortOrder
    heuresTravailes?: SortOrder
    salaireBrut?: SortOrder
    salaireBase?: SortOrder
    montantHeuresSupp?: SortOrder
    montantBonus?: SortOrder
    indemnites?: SortOrder
    deductions?: SortOrder
    totalDeductions?: SortOrder
    salaireNet?: SortOrder
    montantPaye?: SortOrder
    resteAPayer?: SortOrder
    statutPaiement?: SortOrder
    cheminPDF?: SortOrderInput | SortOrder
    calculs?: SortOrderInput | SortOrder
    estVerrouille?: SortOrder
    payRunId?: SortOrder
    employeId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyBulletinCountOrderByAggregateInput
    _avg?: CompanyBulletinAvgOrderByAggregateInput
    _max?: CompanyBulletinMaxOrderByAggregateInput
    _min?: CompanyBulletinMinOrderByAggregateInput
    _sum?: CompanyBulletinSumOrderByAggregateInput
  }

  export type CompanyBulletinScalarWhereWithAggregatesInput = {
    AND?: CompanyBulletinScalarWhereWithAggregatesInput | CompanyBulletinScalarWhereWithAggregatesInput[]
    OR?: CompanyBulletinScalarWhereWithAggregatesInput[]
    NOT?: CompanyBulletinScalarWhereWithAggregatesInput | CompanyBulletinScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyBulletin"> | number
    numeroBulletin?: StringWithAggregatesFilter<"CompanyBulletin"> | string
    datePaiement?: DateTimeWithAggregatesFilter<"CompanyBulletin"> | Date | string
    joursTravailles?: IntWithAggregatesFilter<"CompanyBulletin"> | number
    heuresTravailes?: IntWithAggregatesFilter<"CompanyBulletin"> | number
    salaireBrut?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    deductions?: JsonWithAggregatesFilter<"CompanyBulletin">
    totalDeductions?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalWithAggregatesFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringWithAggregatesFilter<"CompanyBulletin"> | string
    cheminPDF?: StringNullableWithAggregatesFilter<"CompanyBulletin"> | string | null
    calculs?: JsonNullableWithAggregatesFilter<"CompanyBulletin">
    estVerrouille?: BoolWithAggregatesFilter<"CompanyBulletin"> | boolean
    payRunId?: IntWithAggregatesFilter<"CompanyBulletin"> | number
    employeId?: IntWithAggregatesFilter<"CompanyBulletin"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyBulletin"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyBulletin"> | Date | string
  }

  export type CompanyPaiementWhereInput = {
    AND?: CompanyPaiementWhereInput | CompanyPaiementWhereInput[]
    OR?: CompanyPaiementWhereInput[]
    NOT?: CompanyPaiementWhereInput | CompanyPaiementWhereInput[]
    id?: IntFilter<"CompanyPaiement"> | number
    referenceTransaction?: StringFilter<"CompanyPaiement"> | string
    montant?: DecimalFilter<"CompanyPaiement"> | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFilter<"CompanyPaiement"> | string
    referencePaiement?: StringNullableFilter<"CompanyPaiement"> | string | null
    datePaiement?: DateTimeFilter<"CompanyPaiement"> | Date | string
    notes?: StringNullableFilter<"CompanyPaiement"> | string | null
    cheminRecu?: StringNullableFilter<"CompanyPaiement"> | string | null
    statut?: StringFilter<"CompanyPaiement"> | string
    metadata?: JsonNullableFilter<"CompanyPaiement">
    bulletinId?: IntFilter<"CompanyPaiement"> | number
    traitePar?: IntFilter<"CompanyPaiement"> | number
    creeLe?: DateTimeFilter<"CompanyPaiement"> | Date | string
    bulletin?: XOR<CompanyBulletinScalarRelationFilter, CompanyBulletinWhereInput>
    processor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CompanyPaiementOrderByWithRelationInput = {
    id?: SortOrder
    referenceTransaction?: SortOrder
    montant?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrderInput | SortOrder
    datePaiement?: SortOrder
    notes?: SortOrderInput | SortOrder
    cheminRecu?: SortOrderInput | SortOrder
    statut?: SortOrder
    metadata?: SortOrderInput | SortOrder
    bulletinId?: SortOrder
    traitePar?: SortOrder
    creeLe?: SortOrder
    bulletin?: CompanyBulletinOrderByWithRelationInput
    processor?: UserOrderByWithRelationInput
    _relevance?: CompanyPaiementOrderByRelevanceInput
  }

  export type CompanyPaiementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referenceTransaction?: string
    AND?: CompanyPaiementWhereInput | CompanyPaiementWhereInput[]
    OR?: CompanyPaiementWhereInput[]
    NOT?: CompanyPaiementWhereInput | CompanyPaiementWhereInput[]
    montant?: DecimalFilter<"CompanyPaiement"> | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFilter<"CompanyPaiement"> | string
    referencePaiement?: StringNullableFilter<"CompanyPaiement"> | string | null
    datePaiement?: DateTimeFilter<"CompanyPaiement"> | Date | string
    notes?: StringNullableFilter<"CompanyPaiement"> | string | null
    cheminRecu?: StringNullableFilter<"CompanyPaiement"> | string | null
    statut?: StringFilter<"CompanyPaiement"> | string
    metadata?: JsonNullableFilter<"CompanyPaiement">
    bulletinId?: IntFilter<"CompanyPaiement"> | number
    traitePar?: IntFilter<"CompanyPaiement"> | number
    creeLe?: DateTimeFilter<"CompanyPaiement"> | Date | string
    bulletin?: XOR<CompanyBulletinScalarRelationFilter, CompanyBulletinWhereInput>
    processor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "referenceTransaction">

  export type CompanyPaiementOrderByWithAggregationInput = {
    id?: SortOrder
    referenceTransaction?: SortOrder
    montant?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrderInput | SortOrder
    datePaiement?: SortOrder
    notes?: SortOrderInput | SortOrder
    cheminRecu?: SortOrderInput | SortOrder
    statut?: SortOrder
    metadata?: SortOrderInput | SortOrder
    bulletinId?: SortOrder
    traitePar?: SortOrder
    creeLe?: SortOrder
    _count?: CompanyPaiementCountOrderByAggregateInput
    _avg?: CompanyPaiementAvgOrderByAggregateInput
    _max?: CompanyPaiementMaxOrderByAggregateInput
    _min?: CompanyPaiementMinOrderByAggregateInput
    _sum?: CompanyPaiementSumOrderByAggregateInput
  }

  export type CompanyPaiementScalarWhereWithAggregatesInput = {
    AND?: CompanyPaiementScalarWhereWithAggregatesInput | CompanyPaiementScalarWhereWithAggregatesInput[]
    OR?: CompanyPaiementScalarWhereWithAggregatesInput[]
    NOT?: CompanyPaiementScalarWhereWithAggregatesInput | CompanyPaiementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyPaiement"> | number
    referenceTransaction?: StringWithAggregatesFilter<"CompanyPaiement"> | string
    montant?: DecimalWithAggregatesFilter<"CompanyPaiement"> | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringWithAggregatesFilter<"CompanyPaiement"> | string
    referencePaiement?: StringNullableWithAggregatesFilter<"CompanyPaiement"> | string | null
    datePaiement?: DateTimeWithAggregatesFilter<"CompanyPaiement"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"CompanyPaiement"> | string | null
    cheminRecu?: StringNullableWithAggregatesFilter<"CompanyPaiement"> | string | null
    statut?: StringWithAggregatesFilter<"CompanyPaiement"> | string
    metadata?: JsonNullableWithAggregatesFilter<"CompanyPaiement">
    bulletinId?: IntWithAggregatesFilter<"CompanyPaiement"> | number
    traitePar?: IntWithAggregatesFilter<"CompanyPaiement"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyPaiement"> | Date | string
  }

  export type CompanyTemplateWhereInput = {
    AND?: CompanyTemplateWhereInput | CompanyTemplateWhereInput[]
    OR?: CompanyTemplateWhereInput[]
    NOT?: CompanyTemplateWhereInput | CompanyTemplateWhereInput[]
    id?: IntFilter<"CompanyTemplate"> | number
    typeTemplate?: StringFilter<"CompanyTemplate"> | string
    nom?: StringFilter<"CompanyTemplate"> | string
    contenu?: StringFilter<"CompanyTemplate"> | string
    variables?: JsonFilter<"CompanyTemplate">
    estDefaut?: BoolFilter<"CompanyTemplate"> | boolean
    estActif?: BoolFilter<"CompanyTemplate"> | boolean
    entrepriseId?: IntFilter<"CompanyTemplate"> | number
    creeLe?: DateTimeFilter<"CompanyTemplate"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyTemplate"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
  }

  export type CompanyTemplateOrderByWithRelationInput = {
    id?: SortOrder
    typeTemplate?: SortOrder
    nom?: SortOrder
    contenu?: SortOrder
    variables?: SortOrder
    estDefaut?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    _relevance?: CompanyTemplateOrderByRelevanceInput
  }

  export type CompanyTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyTemplateWhereInput | CompanyTemplateWhereInput[]
    OR?: CompanyTemplateWhereInput[]
    NOT?: CompanyTemplateWhereInput | CompanyTemplateWhereInput[]
    typeTemplate?: StringFilter<"CompanyTemplate"> | string
    nom?: StringFilter<"CompanyTemplate"> | string
    contenu?: StringFilter<"CompanyTemplate"> | string
    variables?: JsonFilter<"CompanyTemplate">
    estDefaut?: BoolFilter<"CompanyTemplate"> | boolean
    estActif?: BoolFilter<"CompanyTemplate"> | boolean
    entrepriseId?: IntFilter<"CompanyTemplate"> | number
    creeLe?: DateTimeFilter<"CompanyTemplate"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyTemplate"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
  }, "id">

  export type CompanyTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    typeTemplate?: SortOrder
    nom?: SortOrder
    contenu?: SortOrder
    variables?: SortOrder
    estDefaut?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyTemplateCountOrderByAggregateInput
    _avg?: CompanyTemplateAvgOrderByAggregateInput
    _max?: CompanyTemplateMaxOrderByAggregateInput
    _min?: CompanyTemplateMinOrderByAggregateInput
    _sum?: CompanyTemplateSumOrderByAggregateInput
  }

  export type CompanyTemplateScalarWhereWithAggregatesInput = {
    AND?: CompanyTemplateScalarWhereWithAggregatesInput | CompanyTemplateScalarWhereWithAggregatesInput[]
    OR?: CompanyTemplateScalarWhereWithAggregatesInput[]
    NOT?: CompanyTemplateScalarWhereWithAggregatesInput | CompanyTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyTemplate"> | number
    typeTemplate?: StringWithAggregatesFilter<"CompanyTemplate"> | string
    nom?: StringWithAggregatesFilter<"CompanyTemplate"> | string
    contenu?: StringWithAggregatesFilter<"CompanyTemplate"> | string
    variables?: JsonWithAggregatesFilter<"CompanyTemplate">
    estDefaut?: BoolWithAggregatesFilter<"CompanyTemplate"> | boolean
    estActif?: BoolWithAggregatesFilter<"CompanyTemplate"> | boolean
    entrepriseId?: IntWithAggregatesFilter<"CompanyTemplate"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyTemplate"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyTemplate"> | Date | string
  }

  export type CompanySettingWhereInput = {
    AND?: CompanySettingWhereInput | CompanySettingWhereInput[]
    OR?: CompanySettingWhereInput[]
    NOT?: CompanySettingWhereInput | CompanySettingWhereInput[]
    id?: IntFilter<"CompanySetting"> | number
    cle?: StringFilter<"CompanySetting"> | string
    valeur?: StringFilter<"CompanySetting"> | string
    description?: StringNullableFilter<"CompanySetting"> | string | null
    typeData?: StringFilter<"CompanySetting"> | string
    estEncrypte?: BoolFilter<"CompanySetting"> | boolean
    entrepriseId?: IntFilter<"CompanySetting"> | number
    modifieLe?: DateTimeFilter<"CompanySetting"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
  }

  export type CompanySettingOrderByWithRelationInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    description?: SortOrderInput | SortOrder
    typeData?: SortOrder
    estEncrypte?: SortOrder
    entrepriseId?: SortOrder
    modifieLe?: SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    _relevance?: CompanySettingOrderByRelevanceInput
  }

  export type CompanySettingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cle_entrepriseId?: CompanySettingCleEntrepriseIdCompoundUniqueInput
    AND?: CompanySettingWhereInput | CompanySettingWhereInput[]
    OR?: CompanySettingWhereInput[]
    NOT?: CompanySettingWhereInput | CompanySettingWhereInput[]
    cle?: StringFilter<"CompanySetting"> | string
    valeur?: StringFilter<"CompanySetting"> | string
    description?: StringNullableFilter<"CompanySetting"> | string | null
    typeData?: StringFilter<"CompanySetting"> | string
    estEncrypte?: BoolFilter<"CompanySetting"> | boolean
    entrepriseId?: IntFilter<"CompanySetting"> | number
    modifieLe?: DateTimeFilter<"CompanySetting"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
  }, "id" | "cle_entrepriseId">

  export type CompanySettingOrderByWithAggregationInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    description?: SortOrderInput | SortOrder
    typeData?: SortOrder
    estEncrypte?: SortOrder
    entrepriseId?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanySettingCountOrderByAggregateInput
    _avg?: CompanySettingAvgOrderByAggregateInput
    _max?: CompanySettingMaxOrderByAggregateInput
    _min?: CompanySettingMinOrderByAggregateInput
    _sum?: CompanySettingSumOrderByAggregateInput
  }

  export type CompanySettingScalarWhereWithAggregatesInput = {
    AND?: CompanySettingScalarWhereWithAggregatesInput | CompanySettingScalarWhereWithAggregatesInput[]
    OR?: CompanySettingScalarWhereWithAggregatesInput[]
    NOT?: CompanySettingScalarWhereWithAggregatesInput | CompanySettingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanySetting"> | number
    cle?: StringWithAggregatesFilter<"CompanySetting"> | string
    valeur?: StringWithAggregatesFilter<"CompanySetting"> | string
    description?: StringNullableWithAggregatesFilter<"CompanySetting"> | string | null
    typeData?: StringWithAggregatesFilter<"CompanySetting"> | string
    estEncrypte?: BoolWithAggregatesFilter<"CompanySetting"> | boolean
    entrepriseId?: IntWithAggregatesFilter<"CompanySetting"> | number
    modifieLe?: DateTimeWithAggregatesFilter<"CompanySetting"> | Date | string
  }

  export type CompanyDocumentWhereInput = {
    AND?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    OR?: CompanyDocumentWhereInput[]
    NOT?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    id?: IntFilter<"CompanyDocument"> | number
    type?: StringFilter<"CompanyDocument"> | string
    titre?: StringFilter<"CompanyDocument"> | string
    description?: StringNullableFilter<"CompanyDocument"> | string | null
    cheminFichier?: StringFilter<"CompanyDocument"> | string
    tailleFichier?: IntFilter<"CompanyDocument"> | number
    mimeType?: StringFilter<"CompanyDocument"> | string
    metadata?: JsonNullableFilter<"CompanyDocument">
    tags?: StringFilter<"CompanyDocument"> | string
    employeId?: IntFilter<"CompanyDocument"> | number
    uploadePar?: IntFilter<"CompanyDocument"> | number
    creeLe?: DateTimeFilter<"CompanyDocument"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyDocument"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CompanyDocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    titre?: SortOrder
    description?: SortOrderInput | SortOrder
    cheminFichier?: SortOrder
    tailleFichier?: SortOrder
    mimeType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    tags?: SortOrder
    employeId?: SortOrder
    uploadePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
    _relevance?: CompanyDocumentOrderByRelevanceInput
  }

  export type CompanyDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    OR?: CompanyDocumentWhereInput[]
    NOT?: CompanyDocumentWhereInput | CompanyDocumentWhereInput[]
    type?: StringFilter<"CompanyDocument"> | string
    titre?: StringFilter<"CompanyDocument"> | string
    description?: StringNullableFilter<"CompanyDocument"> | string | null
    cheminFichier?: StringFilter<"CompanyDocument"> | string
    tailleFichier?: IntFilter<"CompanyDocument"> | number
    mimeType?: StringFilter<"CompanyDocument"> | string
    metadata?: JsonNullableFilter<"CompanyDocument">
    tags?: StringFilter<"CompanyDocument"> | string
    employeId?: IntFilter<"CompanyDocument"> | number
    uploadePar?: IntFilter<"CompanyDocument"> | number
    creeLe?: DateTimeFilter<"CompanyDocument"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyDocument"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CompanyDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    titre?: SortOrder
    description?: SortOrderInput | SortOrder
    cheminFichier?: SortOrder
    tailleFichier?: SortOrder
    mimeType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    tags?: SortOrder
    employeId?: SortOrder
    uploadePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyDocumentCountOrderByAggregateInput
    _avg?: CompanyDocumentAvgOrderByAggregateInput
    _max?: CompanyDocumentMaxOrderByAggregateInput
    _min?: CompanyDocumentMinOrderByAggregateInput
    _sum?: CompanyDocumentSumOrderByAggregateInput
  }

  export type CompanyDocumentScalarWhereWithAggregatesInput = {
    AND?: CompanyDocumentScalarWhereWithAggregatesInput | CompanyDocumentScalarWhereWithAggregatesInput[]
    OR?: CompanyDocumentScalarWhereWithAggregatesInput[]
    NOT?: CompanyDocumentScalarWhereWithAggregatesInput | CompanyDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyDocument"> | number
    type?: StringWithAggregatesFilter<"CompanyDocument"> | string
    titre?: StringWithAggregatesFilter<"CompanyDocument"> | string
    description?: StringNullableWithAggregatesFilter<"CompanyDocument"> | string | null
    cheminFichier?: StringWithAggregatesFilter<"CompanyDocument"> | string
    tailleFichier?: IntWithAggregatesFilter<"CompanyDocument"> | number
    mimeType?: StringWithAggregatesFilter<"CompanyDocument"> | string
    metadata?: JsonNullableWithAggregatesFilter<"CompanyDocument">
    tags?: StringWithAggregatesFilter<"CompanyDocument"> | string
    employeId?: IntWithAggregatesFilter<"CompanyDocument"> | number
    uploadePar?: IntWithAggregatesFilter<"CompanyDocument"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyDocument"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyDocument"> | Date | string
  }

  export type CompanyModeleDocumentWhereInput = {
    AND?: CompanyModeleDocumentWhereInput | CompanyModeleDocumentWhereInput[]
    OR?: CompanyModeleDocumentWhereInput[]
    NOT?: CompanyModeleDocumentWhereInput | CompanyModeleDocumentWhereInput[]
    id?: IntFilter<"CompanyModeleDocument"> | number
    nom?: StringFilter<"CompanyModeleDocument"> | string
    description?: StringNullableFilter<"CompanyModeleDocument"> | string | null
    type?: StringFilter<"CompanyModeleDocument"> | string
    contenu?: StringFilter<"CompanyModeleDocument"> | string
    variables?: JsonFilter<"CompanyModeleDocument">
    estActif?: BoolFilter<"CompanyModeleDocument"> | boolean
    entrepriseId?: IntFilter<"CompanyModeleDocument"> | number
    version?: IntFilter<"CompanyModeleDocument"> | number
    creePar?: IntFilter<"CompanyModeleDocument"> | number
    creeLe?: DateTimeFilter<"CompanyModeleDocument"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyModeleDocument"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CompanyModeleDocumentOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    contenu?: SortOrder
    variables?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    version?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    _relevance?: CompanyModeleDocumentOrderByRelevanceInput
  }

  export type CompanyModeleDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    entrepriseId_nom_version?: CompanyModeleDocumentEntrepriseIdNomVersionCompoundUniqueInput
    AND?: CompanyModeleDocumentWhereInput | CompanyModeleDocumentWhereInput[]
    OR?: CompanyModeleDocumentWhereInput[]
    NOT?: CompanyModeleDocumentWhereInput | CompanyModeleDocumentWhereInput[]
    nom?: StringFilter<"CompanyModeleDocument"> | string
    description?: StringNullableFilter<"CompanyModeleDocument"> | string | null
    type?: StringFilter<"CompanyModeleDocument"> | string
    contenu?: StringFilter<"CompanyModeleDocument"> | string
    variables?: JsonFilter<"CompanyModeleDocument">
    estActif?: BoolFilter<"CompanyModeleDocument"> | boolean
    entrepriseId?: IntFilter<"CompanyModeleDocument"> | number
    version?: IntFilter<"CompanyModeleDocument"> | number
    creePar?: IntFilter<"CompanyModeleDocument"> | number
    creeLe?: DateTimeFilter<"CompanyModeleDocument"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyModeleDocument"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "entrepriseId_nom_version">

  export type CompanyModeleDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    contenu?: SortOrder
    variables?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    version?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyModeleDocumentCountOrderByAggregateInput
    _avg?: CompanyModeleDocumentAvgOrderByAggregateInput
    _max?: CompanyModeleDocumentMaxOrderByAggregateInput
    _min?: CompanyModeleDocumentMinOrderByAggregateInput
    _sum?: CompanyModeleDocumentSumOrderByAggregateInput
  }

  export type CompanyModeleDocumentScalarWhereWithAggregatesInput = {
    AND?: CompanyModeleDocumentScalarWhereWithAggregatesInput | CompanyModeleDocumentScalarWhereWithAggregatesInput[]
    OR?: CompanyModeleDocumentScalarWhereWithAggregatesInput[]
    NOT?: CompanyModeleDocumentScalarWhereWithAggregatesInput | CompanyModeleDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyModeleDocument"> | number
    nom?: StringWithAggregatesFilter<"CompanyModeleDocument"> | string
    description?: StringNullableWithAggregatesFilter<"CompanyModeleDocument"> | string | null
    type?: StringWithAggregatesFilter<"CompanyModeleDocument"> | string
    contenu?: StringWithAggregatesFilter<"CompanyModeleDocument"> | string
    variables?: JsonWithAggregatesFilter<"CompanyModeleDocument">
    estActif?: BoolWithAggregatesFilter<"CompanyModeleDocument"> | boolean
    entrepriseId?: IntWithAggregatesFilter<"CompanyModeleDocument"> | number
    version?: IntWithAggregatesFilter<"CompanyModeleDocument"> | number
    creePar?: IntWithAggregatesFilter<"CompanyModeleDocument"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyModeleDocument"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyModeleDocument"> | Date | string
  }

  export type CompanyPeriodePaieWhereInput = {
    AND?: CompanyPeriodePaieWhereInput | CompanyPeriodePaieWhereInput[]
    OR?: CompanyPeriodePaieWhereInput[]
    NOT?: CompanyPeriodePaieWhereInput | CompanyPeriodePaieWhereInput[]
    id?: IntFilter<"CompanyPeriodePaie"> | number
    nom?: StringFilter<"CompanyPeriodePaie"> | string
    dateDebut?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    dateFin?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    estCloturee?: BoolFilter<"CompanyPeriodePaie"> | boolean
    dateReglement?: DateTimeNullableFilter<"CompanyPeriodePaie"> | Date | string | null
    notes?: StringNullableFilter<"CompanyPeriodePaie"> | string | null
    metadata?: JsonNullableFilter<"CompanyPeriodePaie">
    entrepriseId?: IntFilter<"CompanyPeriodePaie"> | number
    creeLe?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    payRuns?: CompanyPayRunListRelationFilter
  }

  export type CompanyPeriodePaieOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estCloturee?: SortOrder
    dateReglement?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    payRuns?: CompanyPayRunOrderByRelationAggregateInput
    _relevance?: CompanyPeriodePaieOrderByRelevanceInput
  }

  export type CompanyPeriodePaieWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyPeriodePaieWhereInput | CompanyPeriodePaieWhereInput[]
    OR?: CompanyPeriodePaieWhereInput[]
    NOT?: CompanyPeriodePaieWhereInput | CompanyPeriodePaieWhereInput[]
    nom?: StringFilter<"CompanyPeriodePaie"> | string
    dateDebut?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    dateFin?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    estCloturee?: BoolFilter<"CompanyPeriodePaie"> | boolean
    dateReglement?: DateTimeNullableFilter<"CompanyPeriodePaie"> | Date | string | null
    notes?: StringNullableFilter<"CompanyPeriodePaie"> | string | null
    metadata?: JsonNullableFilter<"CompanyPeriodePaie">
    entrepriseId?: IntFilter<"CompanyPeriodePaie"> | number
    creeLe?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    payRuns?: CompanyPayRunListRelationFilter
  }, "id">

  export type CompanyPeriodePaieOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estCloturee?: SortOrder
    dateReglement?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyPeriodePaieCountOrderByAggregateInput
    _avg?: CompanyPeriodePaieAvgOrderByAggregateInput
    _max?: CompanyPeriodePaieMaxOrderByAggregateInput
    _min?: CompanyPeriodePaieMinOrderByAggregateInput
    _sum?: CompanyPeriodePaieSumOrderByAggregateInput
  }

  export type CompanyPeriodePaieScalarWhereWithAggregatesInput = {
    AND?: CompanyPeriodePaieScalarWhereWithAggregatesInput | CompanyPeriodePaieScalarWhereWithAggregatesInput[]
    OR?: CompanyPeriodePaieScalarWhereWithAggregatesInput[]
    NOT?: CompanyPeriodePaieScalarWhereWithAggregatesInput | CompanyPeriodePaieScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyPeriodePaie"> | number
    nom?: StringWithAggregatesFilter<"CompanyPeriodePaie"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"CompanyPeriodePaie"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"CompanyPeriodePaie"> | Date | string
    estCloturee?: BoolWithAggregatesFilter<"CompanyPeriodePaie"> | boolean
    dateReglement?: DateTimeNullableWithAggregatesFilter<"CompanyPeriodePaie"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"CompanyPeriodePaie"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"CompanyPeriodePaie">
    entrepriseId?: IntWithAggregatesFilter<"CompanyPeriodePaie"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyPeriodePaie"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyPeriodePaie"> | Date | string
  }

  export type CompanyConfigurationPaieWhereInput = {
    AND?: CompanyConfigurationPaieWhereInput | CompanyConfigurationPaieWhereInput[]
    OR?: CompanyConfigurationPaieWhereInput[]
    NOT?: CompanyConfigurationPaieWhereInput | CompanyConfigurationPaieWhereInput[]
    id?: IntFilter<"CompanyConfigurationPaie"> | number
    entrepriseId?: IntFilter<"CompanyConfigurationPaie"> | number
    jourPaie?: IntFilter<"CompanyConfigurationPaie"> | number
    periodeCalcul?: StringFilter<"CompanyConfigurationPaie"> | string
    regleArrondi?: StringFilter<"CompanyConfigurationPaie"> | string
    deviseSecondaire?: StringNullableFilter<"CompanyConfigurationPaie"> | string | null
    tauxChange?: DecimalNullableFilter<"CompanyConfigurationPaie"> | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonFilter<"CompanyConfigurationPaie">
    regleValidation?: JsonFilter<"CompanyConfigurationPaie">
    parametresCalcul?: JsonFilter<"CompanyConfigurationPaie">
    modifieLe?: DateTimeFilter<"CompanyConfigurationPaie"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    reglesDeduction?: CompanyRegleDeductionListRelationFilter
  }

  export type CompanyConfigurationPaieOrderByWithRelationInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    jourPaie?: SortOrder
    periodeCalcul?: SortOrder
    regleArrondi?: SortOrder
    deviseSecondaire?: SortOrderInput | SortOrder
    tauxChange?: SortOrderInput | SortOrder
    formatNumeration?: SortOrder
    regleValidation?: SortOrder
    parametresCalcul?: SortOrder
    modifieLe?: SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    reglesDeduction?: CompanyRegleDeductionOrderByRelationAggregateInput
    _relevance?: CompanyConfigurationPaieOrderByRelevanceInput
  }

  export type CompanyConfigurationPaieWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    entrepriseId?: number
    AND?: CompanyConfigurationPaieWhereInput | CompanyConfigurationPaieWhereInput[]
    OR?: CompanyConfigurationPaieWhereInput[]
    NOT?: CompanyConfigurationPaieWhereInput | CompanyConfigurationPaieWhereInput[]
    jourPaie?: IntFilter<"CompanyConfigurationPaie"> | number
    periodeCalcul?: StringFilter<"CompanyConfigurationPaie"> | string
    regleArrondi?: StringFilter<"CompanyConfigurationPaie"> | string
    deviseSecondaire?: StringNullableFilter<"CompanyConfigurationPaie"> | string | null
    tauxChange?: DecimalNullableFilter<"CompanyConfigurationPaie"> | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonFilter<"CompanyConfigurationPaie">
    regleValidation?: JsonFilter<"CompanyConfigurationPaie">
    parametresCalcul?: JsonFilter<"CompanyConfigurationPaie">
    modifieLe?: DateTimeFilter<"CompanyConfigurationPaie"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
    reglesDeduction?: CompanyRegleDeductionListRelationFilter
  }, "id" | "entrepriseId">

  export type CompanyConfigurationPaieOrderByWithAggregationInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    jourPaie?: SortOrder
    periodeCalcul?: SortOrder
    regleArrondi?: SortOrder
    deviseSecondaire?: SortOrderInput | SortOrder
    tauxChange?: SortOrderInput | SortOrder
    formatNumeration?: SortOrder
    regleValidation?: SortOrder
    parametresCalcul?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyConfigurationPaieCountOrderByAggregateInput
    _avg?: CompanyConfigurationPaieAvgOrderByAggregateInput
    _max?: CompanyConfigurationPaieMaxOrderByAggregateInput
    _min?: CompanyConfigurationPaieMinOrderByAggregateInput
    _sum?: CompanyConfigurationPaieSumOrderByAggregateInput
  }

  export type CompanyConfigurationPaieScalarWhereWithAggregatesInput = {
    AND?: CompanyConfigurationPaieScalarWhereWithAggregatesInput | CompanyConfigurationPaieScalarWhereWithAggregatesInput[]
    OR?: CompanyConfigurationPaieScalarWhereWithAggregatesInput[]
    NOT?: CompanyConfigurationPaieScalarWhereWithAggregatesInput | CompanyConfigurationPaieScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyConfigurationPaie"> | number
    entrepriseId?: IntWithAggregatesFilter<"CompanyConfigurationPaie"> | number
    jourPaie?: IntWithAggregatesFilter<"CompanyConfigurationPaie"> | number
    periodeCalcul?: StringWithAggregatesFilter<"CompanyConfigurationPaie"> | string
    regleArrondi?: StringWithAggregatesFilter<"CompanyConfigurationPaie"> | string
    deviseSecondaire?: StringNullableWithAggregatesFilter<"CompanyConfigurationPaie"> | string | null
    tauxChange?: DecimalNullableWithAggregatesFilter<"CompanyConfigurationPaie"> | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonWithAggregatesFilter<"CompanyConfigurationPaie">
    regleValidation?: JsonWithAggregatesFilter<"CompanyConfigurationPaie">
    parametresCalcul?: JsonWithAggregatesFilter<"CompanyConfigurationPaie">
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyConfigurationPaie"> | Date | string
  }

  export type CompanyHistoriqueSalaireWhereInput = {
    AND?: CompanyHistoriqueSalaireWhereInput | CompanyHistoriqueSalaireWhereInput[]
    OR?: CompanyHistoriqueSalaireWhereInput[]
    NOT?: CompanyHistoriqueSalaireWhereInput | CompanyHistoriqueSalaireWhereInput[]
    id?: IntFilter<"CompanyHistoriqueSalaire"> | number
    employeId?: IntFilter<"CompanyHistoriqueSalaire"> | number
    ancienSalaire?: DecimalFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFilter<"CompanyHistoriqueSalaire"> | Date | string
    motif?: StringFilter<"CompanyHistoriqueSalaire"> | string
    notes?: StringNullableFilter<"CompanyHistoriqueSalaire"> | string | null
    documents?: JsonNullableFilter<"CompanyHistoriqueSalaire">
    modifiePar?: IntFilter<"CompanyHistoriqueSalaire"> | number
    creeLe?: DateTimeFilter<"CompanyHistoriqueSalaire"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    modifier?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CompanyHistoriqueSalaireOrderByWithRelationInput = {
    id?: SortOrder
    employeId?: SortOrder
    ancienSalaire?: SortOrder
    nouveauSalaire?: SortOrder
    dateEffet?: SortOrder
    motif?: SortOrder
    notes?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    modifiePar?: SortOrder
    creeLe?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    modifier?: UserOrderByWithRelationInput
    _relevance?: CompanyHistoriqueSalaireOrderByRelevanceInput
  }

  export type CompanyHistoriqueSalaireWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyHistoriqueSalaireWhereInput | CompanyHistoriqueSalaireWhereInput[]
    OR?: CompanyHistoriqueSalaireWhereInput[]
    NOT?: CompanyHistoriqueSalaireWhereInput | CompanyHistoriqueSalaireWhereInput[]
    employeId?: IntFilter<"CompanyHistoriqueSalaire"> | number
    ancienSalaire?: DecimalFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFilter<"CompanyHistoriqueSalaire"> | Date | string
    motif?: StringFilter<"CompanyHistoriqueSalaire"> | string
    notes?: StringNullableFilter<"CompanyHistoriqueSalaire"> | string | null
    documents?: JsonNullableFilter<"CompanyHistoriqueSalaire">
    modifiePar?: IntFilter<"CompanyHistoriqueSalaire"> | number
    creeLe?: DateTimeFilter<"CompanyHistoriqueSalaire"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    modifier?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CompanyHistoriqueSalaireOrderByWithAggregationInput = {
    id?: SortOrder
    employeId?: SortOrder
    ancienSalaire?: SortOrder
    nouveauSalaire?: SortOrder
    dateEffet?: SortOrder
    motif?: SortOrder
    notes?: SortOrderInput | SortOrder
    documents?: SortOrderInput | SortOrder
    modifiePar?: SortOrder
    creeLe?: SortOrder
    _count?: CompanyHistoriqueSalaireCountOrderByAggregateInput
    _avg?: CompanyHistoriqueSalaireAvgOrderByAggregateInput
    _max?: CompanyHistoriqueSalaireMaxOrderByAggregateInput
    _min?: CompanyHistoriqueSalaireMinOrderByAggregateInput
    _sum?: CompanyHistoriqueSalaireSumOrderByAggregateInput
  }

  export type CompanyHistoriqueSalaireScalarWhereWithAggregatesInput = {
    AND?: CompanyHistoriqueSalaireScalarWhereWithAggregatesInput | CompanyHistoriqueSalaireScalarWhereWithAggregatesInput[]
    OR?: CompanyHistoriqueSalaireScalarWhereWithAggregatesInput[]
    NOT?: CompanyHistoriqueSalaireScalarWhereWithAggregatesInput | CompanyHistoriqueSalaireScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyHistoriqueSalaire"> | number
    employeId?: IntWithAggregatesFilter<"CompanyHistoriqueSalaire"> | number
    ancienSalaire?: DecimalWithAggregatesFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalWithAggregatesFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeWithAggregatesFilter<"CompanyHistoriqueSalaire"> | Date | string
    motif?: StringWithAggregatesFilter<"CompanyHistoriqueSalaire"> | string
    notes?: StringNullableWithAggregatesFilter<"CompanyHistoriqueSalaire"> | string | null
    documents?: JsonNullableWithAggregatesFilter<"CompanyHistoriqueSalaire">
    modifiePar?: IntWithAggregatesFilter<"CompanyHistoriqueSalaire"> | number
    creeLe?: DateTimeWithAggregatesFilter<"CompanyHistoriqueSalaire"> | Date | string
  }

  export type CompanyRegleDeductionWhereInput = {
    AND?: CompanyRegleDeductionWhereInput | CompanyRegleDeductionWhereInput[]
    OR?: CompanyRegleDeductionWhereInput[]
    NOT?: CompanyRegleDeductionWhereInput | CompanyRegleDeductionWhereInput[]
    id?: IntFilter<"CompanyRegleDeduction"> | number
    nom?: StringFilter<"CompanyRegleDeduction"> | string
    description?: StringNullableFilter<"CompanyRegleDeduction"> | string | null
    type?: StringFilter<"CompanyRegleDeduction"> | string
    formule?: StringFilter<"CompanyRegleDeduction"> | string
    conditionsApplication?: JsonFilter<"CompanyRegleDeduction">
    estObligatoire?: BoolFilter<"CompanyRegleDeduction"> | boolean
    ordre?: IntFilter<"CompanyRegleDeduction"> | number
    configurationId?: IntFilter<"CompanyRegleDeduction"> | number
    estActif?: BoolFilter<"CompanyRegleDeduction"> | boolean
    creeLe?: DateTimeFilter<"CompanyRegleDeduction"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyRegleDeduction"> | Date | string
    configuration?: XOR<CompanyConfigurationPaieScalarRelationFilter, CompanyConfigurationPaieWhereInput>
  }

  export type CompanyRegleDeductionOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    formule?: SortOrder
    conditionsApplication?: SortOrder
    estObligatoire?: SortOrder
    ordre?: SortOrder
    configurationId?: SortOrder
    estActif?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    configuration?: CompanyConfigurationPaieOrderByWithRelationInput
    _relevance?: CompanyRegleDeductionOrderByRelevanceInput
  }

  export type CompanyRegleDeductionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyRegleDeductionWhereInput | CompanyRegleDeductionWhereInput[]
    OR?: CompanyRegleDeductionWhereInput[]
    NOT?: CompanyRegleDeductionWhereInput | CompanyRegleDeductionWhereInput[]
    nom?: StringFilter<"CompanyRegleDeduction"> | string
    description?: StringNullableFilter<"CompanyRegleDeduction"> | string | null
    type?: StringFilter<"CompanyRegleDeduction"> | string
    formule?: StringFilter<"CompanyRegleDeduction"> | string
    conditionsApplication?: JsonFilter<"CompanyRegleDeduction">
    estObligatoire?: BoolFilter<"CompanyRegleDeduction"> | boolean
    ordre?: IntFilter<"CompanyRegleDeduction"> | number
    configurationId?: IntFilter<"CompanyRegleDeduction"> | number
    estActif?: BoolFilter<"CompanyRegleDeduction"> | boolean
    creeLe?: DateTimeFilter<"CompanyRegleDeduction"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyRegleDeduction"> | Date | string
    configuration?: XOR<CompanyConfigurationPaieScalarRelationFilter, CompanyConfigurationPaieWhereInput>
  }, "id">

  export type CompanyRegleDeductionOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    formule?: SortOrder
    conditionsApplication?: SortOrder
    estObligatoire?: SortOrder
    ordre?: SortOrder
    configurationId?: SortOrder
    estActif?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: CompanyRegleDeductionCountOrderByAggregateInput
    _avg?: CompanyRegleDeductionAvgOrderByAggregateInput
    _max?: CompanyRegleDeductionMaxOrderByAggregateInput
    _min?: CompanyRegleDeductionMinOrderByAggregateInput
    _sum?: CompanyRegleDeductionSumOrderByAggregateInput
  }

  export type CompanyRegleDeductionScalarWhereWithAggregatesInput = {
    AND?: CompanyRegleDeductionScalarWhereWithAggregatesInput | CompanyRegleDeductionScalarWhereWithAggregatesInput[]
    OR?: CompanyRegleDeductionScalarWhereWithAggregatesInput[]
    NOT?: CompanyRegleDeductionScalarWhereWithAggregatesInput | CompanyRegleDeductionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CompanyRegleDeduction"> | number
    nom?: StringWithAggregatesFilter<"CompanyRegleDeduction"> | string
    description?: StringNullableWithAggregatesFilter<"CompanyRegleDeduction"> | string | null
    type?: StringWithAggregatesFilter<"CompanyRegleDeduction"> | string
    formule?: StringWithAggregatesFilter<"CompanyRegleDeduction"> | string
    conditionsApplication?: JsonWithAggregatesFilter<"CompanyRegleDeduction">
    estObligatoire?: BoolWithAggregatesFilter<"CompanyRegleDeduction"> | boolean
    ordre?: IntWithAggregatesFilter<"CompanyRegleDeduction"> | number
    configurationId?: IntWithAggregatesFilter<"CompanyRegleDeduction"> | number
    estActif?: BoolWithAggregatesFilter<"CompanyRegleDeduction"> | boolean
    creeLe?: DateTimeWithAggregatesFilter<"CompanyRegleDeduction"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"CompanyRegleDeduction"> | Date | string
  }

  export type PointageWhereInput = {
    AND?: PointageWhereInput | PointageWhereInput[]
    OR?: PointageWhereInput[]
    NOT?: PointageWhereInput | PointageWhereInput[]
    id?: IntFilter<"Pointage"> | number
    employeId?: IntFilter<"Pointage"> | number
    date?: DateTimeFilter<"Pointage"> | Date | string
    heureArrivee?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    heureDepart?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    statut?: EnumStatutPointageFilter<"Pointage"> | $Enums.StatutPointage
    typePointage?: EnumTypePointageFilter<"Pointage"> | $Enums.TypePointage
    commentaire?: StringNullableFilter<"Pointage"> | string | null
    latitude?: DecimalNullableFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    ipAddress?: StringNullableFilter<"Pointage"> | string | null
    deviceInfo?: StringNullableFilter<"Pointage"> | string | null
    validePar?: IntNullableFilter<"Pointage"> | number | null
    dateValidation?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    creeLe?: DateTimeFilter<"Pointage"> | Date | string
    modifieLe?: DateTimeFilter<"Pointage"> | Date | string
    employe?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    validateur?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PointageOrderByWithRelationInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureArrivee?: SortOrderInput | SortOrder
    heureDepart?: SortOrderInput | SortOrder
    statut?: SortOrder
    typePointage?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    validePar?: SortOrderInput | SortOrder
    dateValidation?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    employe?: EmployeeOrderByWithRelationInput
    validateur?: UserOrderByWithRelationInput
    _relevance?: PointageOrderByRelevanceInput
  }

  export type PointageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PointageWhereInput | PointageWhereInput[]
    OR?: PointageWhereInput[]
    NOT?: PointageWhereInput | PointageWhereInput[]
    employeId?: IntFilter<"Pointage"> | number
    date?: DateTimeFilter<"Pointage"> | Date | string
    heureArrivee?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    heureDepart?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    statut?: EnumStatutPointageFilter<"Pointage"> | $Enums.StatutPointage
    typePointage?: EnumTypePointageFilter<"Pointage"> | $Enums.TypePointage
    commentaire?: StringNullableFilter<"Pointage"> | string | null
    latitude?: DecimalNullableFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    ipAddress?: StringNullableFilter<"Pointage"> | string | null
    deviceInfo?: StringNullableFilter<"Pointage"> | string | null
    validePar?: IntNullableFilter<"Pointage"> | number | null
    dateValidation?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    creeLe?: DateTimeFilter<"Pointage"> | Date | string
    modifieLe?: DateTimeFilter<"Pointage"> | Date | string
    employe?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    validateur?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PointageOrderByWithAggregationInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureArrivee?: SortOrderInput | SortOrder
    heureDepart?: SortOrderInput | SortOrder
    statut?: SortOrder
    typePointage?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    validePar?: SortOrderInput | SortOrder
    dateValidation?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: PointageCountOrderByAggregateInput
    _avg?: PointageAvgOrderByAggregateInput
    _max?: PointageMaxOrderByAggregateInput
    _min?: PointageMinOrderByAggregateInput
    _sum?: PointageSumOrderByAggregateInput
  }

  export type PointageScalarWhereWithAggregatesInput = {
    AND?: PointageScalarWhereWithAggregatesInput | PointageScalarWhereWithAggregatesInput[]
    OR?: PointageScalarWhereWithAggregatesInput[]
    NOT?: PointageScalarWhereWithAggregatesInput | PointageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pointage"> | number
    employeId?: IntWithAggregatesFilter<"Pointage"> | number
    date?: DateTimeWithAggregatesFilter<"Pointage"> | Date | string
    heureArrivee?: DateTimeNullableWithAggregatesFilter<"Pointage"> | Date | string | null
    heureDepart?: DateTimeNullableWithAggregatesFilter<"Pointage"> | Date | string | null
    statut?: EnumStatutPointageWithAggregatesFilter<"Pointage"> | $Enums.StatutPointage
    typePointage?: EnumTypePointageWithAggregatesFilter<"Pointage"> | $Enums.TypePointage
    commentaire?: StringNullableWithAggregatesFilter<"Pointage"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Pointage"> | string | null
    deviceInfo?: StringNullableWithAggregatesFilter<"Pointage"> | string | null
    validePar?: IntNullableWithAggregatesFilter<"Pointage"> | number | null
    dateValidation?: DateTimeNullableWithAggregatesFilter<"Pointage"> | Date | string | null
    creeLe?: DateTimeWithAggregatesFilter<"Pointage"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"Pointage"> | Date | string
  }

  export type ReglePointageWhereInput = {
    AND?: ReglePointageWhereInput | ReglePointageWhereInput[]
    OR?: ReglePointageWhereInput[]
    NOT?: ReglePointageWhereInput | ReglePointageWhereInput[]
    id?: IntFilter<"ReglePointage"> | number
    entrepriseId?: IntFilter<"ReglePointage"> | number
    heureDebut?: StringFilter<"ReglePointage"> | string
    heureFin?: StringFilter<"ReglePointage"> | string
    toleranceRetard?: IntFilter<"ReglePointage"> | number
    toleranceDepart?: IntFilter<"ReglePointage"> | number
    joursTravail?: JsonFilter<"ReglePointage">
    heuresParJour?: IntFilter<"ReglePointage"> | number
    heuresSupAutorise?: BoolFilter<"ReglePointage"> | boolean
    seuilHeuresSup?: IntFilter<"ReglePointage"> | number
    pauseDejeuner?: IntFilter<"ReglePointage"> | number
    estFlexible?: BoolFilter<"ReglePointage"> | boolean
    plageHoraireMin?: StringNullableFilter<"ReglePointage"> | string | null
    plageHoraireMax?: StringNullableFilter<"ReglePointage"> | string | null
    joursFeries?: JsonNullableFilter<"ReglePointage">
    modifieLe?: DateTimeFilter<"ReglePointage"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
  }

  export type ReglePointageOrderByWithRelationInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    toleranceRetard?: SortOrder
    toleranceDepart?: SortOrder
    joursTravail?: SortOrder
    heuresParJour?: SortOrder
    heuresSupAutorise?: SortOrder
    seuilHeuresSup?: SortOrder
    pauseDejeuner?: SortOrder
    estFlexible?: SortOrder
    plageHoraireMin?: SortOrderInput | SortOrder
    plageHoraireMax?: SortOrderInput | SortOrder
    joursFeries?: SortOrderInput | SortOrder
    modifieLe?: SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    _relevance?: ReglePointageOrderByRelevanceInput
  }

  export type ReglePointageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    entrepriseId?: number
    AND?: ReglePointageWhereInput | ReglePointageWhereInput[]
    OR?: ReglePointageWhereInput[]
    NOT?: ReglePointageWhereInput | ReglePointageWhereInput[]
    heureDebut?: StringFilter<"ReglePointage"> | string
    heureFin?: StringFilter<"ReglePointage"> | string
    toleranceRetard?: IntFilter<"ReglePointage"> | number
    toleranceDepart?: IntFilter<"ReglePointage"> | number
    joursTravail?: JsonFilter<"ReglePointage">
    heuresParJour?: IntFilter<"ReglePointage"> | number
    heuresSupAutorise?: BoolFilter<"ReglePointage"> | boolean
    seuilHeuresSup?: IntFilter<"ReglePointage"> | number
    pauseDejeuner?: IntFilter<"ReglePointage"> | number
    estFlexible?: BoolFilter<"ReglePointage"> | boolean
    plageHoraireMin?: StringNullableFilter<"ReglePointage"> | string | null
    plageHoraireMax?: StringNullableFilter<"ReglePointage"> | string | null
    joursFeries?: JsonNullableFilter<"ReglePointage">
    modifieLe?: DateTimeFilter<"ReglePointage"> | Date | string
    entreprise?: XOR<EntrepriseScalarRelationFilter, EntrepriseWhereInput>
  }, "id" | "entrepriseId">

  export type ReglePointageOrderByWithAggregationInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    toleranceRetard?: SortOrder
    toleranceDepart?: SortOrder
    joursTravail?: SortOrder
    heuresParJour?: SortOrder
    heuresSupAutorise?: SortOrder
    seuilHeuresSup?: SortOrder
    pauseDejeuner?: SortOrder
    estFlexible?: SortOrder
    plageHoraireMin?: SortOrderInput | SortOrder
    plageHoraireMax?: SortOrderInput | SortOrder
    joursFeries?: SortOrderInput | SortOrder
    modifieLe?: SortOrder
    _count?: ReglePointageCountOrderByAggregateInput
    _avg?: ReglePointageAvgOrderByAggregateInput
    _max?: ReglePointageMaxOrderByAggregateInput
    _min?: ReglePointageMinOrderByAggregateInput
    _sum?: ReglePointageSumOrderByAggregateInput
  }

  export type ReglePointageScalarWhereWithAggregatesInput = {
    AND?: ReglePointageScalarWhereWithAggregatesInput | ReglePointageScalarWhereWithAggregatesInput[]
    OR?: ReglePointageScalarWhereWithAggregatesInput[]
    NOT?: ReglePointageScalarWhereWithAggregatesInput | ReglePointageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReglePointage"> | number
    entrepriseId?: IntWithAggregatesFilter<"ReglePointage"> | number
    heureDebut?: StringWithAggregatesFilter<"ReglePointage"> | string
    heureFin?: StringWithAggregatesFilter<"ReglePointage"> | string
    toleranceRetard?: IntWithAggregatesFilter<"ReglePointage"> | number
    toleranceDepart?: IntWithAggregatesFilter<"ReglePointage"> | number
    joursTravail?: JsonWithAggregatesFilter<"ReglePointage">
    heuresParJour?: IntWithAggregatesFilter<"ReglePointage"> | number
    heuresSupAutorise?: BoolWithAggregatesFilter<"ReglePointage"> | boolean
    seuilHeuresSup?: IntWithAggregatesFilter<"ReglePointage"> | number
    pauseDejeuner?: IntWithAggregatesFilter<"ReglePointage"> | number
    estFlexible?: BoolWithAggregatesFilter<"ReglePointage"> | boolean
    plageHoraireMin?: StringNullableWithAggregatesFilter<"ReglePointage"> | string | null
    plageHoraireMax?: StringNullableWithAggregatesFilter<"ReglePointage"> | string | null
    joursFeries?: JsonNullableWithAggregatesFilter<"ReglePointage">
    modifieLe?: DateTimeWithAggregatesFilter<"ReglePointage"> | Date | string
  }

  export type AbsenceWhereInput = {
    AND?: AbsenceWhereInput | AbsenceWhereInput[]
    OR?: AbsenceWhereInput[]
    NOT?: AbsenceWhereInput | AbsenceWhereInput[]
    id?: IntFilter<"Absence"> | number
    employeId?: IntFilter<"Absence"> | number
    typeAbsence?: EnumTypeAbsenceFilter<"Absence"> | $Enums.TypeAbsence
    dateDebut?: DateTimeFilter<"Absence"> | Date | string
    dateFin?: DateTimeFilter<"Absence"> | Date | string
    motif?: StringNullableFilter<"Absence"> | string | null
    statut?: EnumStatutAbsenceFilter<"Absence"> | $Enums.StatutAbsence
    joursOuvres?: IntFilter<"Absence"> | number
    heuresAbsence?: DecimalFilter<"Absence"> | Decimal | DecimalJsLike | number | string
    commentaire?: StringNullableFilter<"Absence"> | string | null
    pieceJointe?: StringNullableFilter<"Absence"> | string | null
    approuvePar?: IntNullableFilter<"Absence"> | number | null
    dateApprobation?: DateTimeNullableFilter<"Absence"> | Date | string | null
    creeLe?: DateTimeFilter<"Absence"> | Date | string
    modifieLe?: DateTimeFilter<"Absence"> | Date | string
    employe?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    approbateur?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AbsenceOrderByWithRelationInput = {
    id?: SortOrder
    employeId?: SortOrder
    typeAbsence?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    motif?: SortOrderInput | SortOrder
    statut?: SortOrder
    joursOuvres?: SortOrder
    heuresAbsence?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    pieceJointe?: SortOrderInput | SortOrder
    approuvePar?: SortOrderInput | SortOrder
    dateApprobation?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    employe?: EmployeeOrderByWithRelationInput
    approbateur?: UserOrderByWithRelationInput
    _relevance?: AbsenceOrderByRelevanceInput
  }

  export type AbsenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AbsenceWhereInput | AbsenceWhereInput[]
    OR?: AbsenceWhereInput[]
    NOT?: AbsenceWhereInput | AbsenceWhereInput[]
    employeId?: IntFilter<"Absence"> | number
    typeAbsence?: EnumTypeAbsenceFilter<"Absence"> | $Enums.TypeAbsence
    dateDebut?: DateTimeFilter<"Absence"> | Date | string
    dateFin?: DateTimeFilter<"Absence"> | Date | string
    motif?: StringNullableFilter<"Absence"> | string | null
    statut?: EnumStatutAbsenceFilter<"Absence"> | $Enums.StatutAbsence
    joursOuvres?: IntFilter<"Absence"> | number
    heuresAbsence?: DecimalFilter<"Absence"> | Decimal | DecimalJsLike | number | string
    commentaire?: StringNullableFilter<"Absence"> | string | null
    pieceJointe?: StringNullableFilter<"Absence"> | string | null
    approuvePar?: IntNullableFilter<"Absence"> | number | null
    dateApprobation?: DateTimeNullableFilter<"Absence"> | Date | string | null
    creeLe?: DateTimeFilter<"Absence"> | Date | string
    modifieLe?: DateTimeFilter<"Absence"> | Date | string
    employe?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    approbateur?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AbsenceOrderByWithAggregationInput = {
    id?: SortOrder
    employeId?: SortOrder
    typeAbsence?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    motif?: SortOrderInput | SortOrder
    statut?: SortOrder
    joursOuvres?: SortOrder
    heuresAbsence?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    pieceJointe?: SortOrderInput | SortOrder
    approuvePar?: SortOrderInput | SortOrder
    dateApprobation?: SortOrderInput | SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
    _count?: AbsenceCountOrderByAggregateInput
    _avg?: AbsenceAvgOrderByAggregateInput
    _max?: AbsenceMaxOrderByAggregateInput
    _min?: AbsenceMinOrderByAggregateInput
    _sum?: AbsenceSumOrderByAggregateInput
  }

  export type AbsenceScalarWhereWithAggregatesInput = {
    AND?: AbsenceScalarWhereWithAggregatesInput | AbsenceScalarWhereWithAggregatesInput[]
    OR?: AbsenceScalarWhereWithAggregatesInput[]
    NOT?: AbsenceScalarWhereWithAggregatesInput | AbsenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Absence"> | number
    employeId?: IntWithAggregatesFilter<"Absence"> | number
    typeAbsence?: EnumTypeAbsenceWithAggregatesFilter<"Absence"> | $Enums.TypeAbsence
    dateDebut?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
    motif?: StringNullableWithAggregatesFilter<"Absence"> | string | null
    statut?: EnumStatutAbsenceWithAggregatesFilter<"Absence"> | $Enums.StatutAbsence
    joursOuvres?: IntWithAggregatesFilter<"Absence"> | number
    heuresAbsence?: DecimalWithAggregatesFilter<"Absence"> | Decimal | DecimalJsLike | number | string
    commentaire?: StringNullableWithAggregatesFilter<"Absence"> | string | null
    pieceJointe?: StringNullableWithAggregatesFilter<"Absence"> | string | null
    approuvePar?: IntNullableWithAggregatesFilter<"Absence"> | number | null
    dateApprobation?: DateTimeNullableWithAggregatesFilter<"Absence"> | Date | string | null
    creeLe?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
    modifieLe?: DateTimeWithAggregatesFilter<"Absence"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUpdateInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntrepriseCreateInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseCreateManyInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type EntrepriseUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntrepriseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalAuditCreateInput = {
    action: string
    nomTable: string
    idEnregistrement?: number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    utilisateur?: UserCreateNestedOneWithoutJournalAuditInput
  }

  export type JournalAuditUncheckedCreateInput = {
    id?: number
    utilisateurId?: number | null
    action: string
    nomTable: string
    idEnregistrement?: number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
  }

  export type JournalAuditUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    nomTable?: StringFieldUpdateOperationsInput | string
    idEnregistrement?: NullableIntFieldUpdateOperationsInput | number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UserUpdateOneWithoutJournalAuditNestedInput
  }

  export type JournalAuditUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    nomTable?: StringFieldUpdateOperationsInput | string
    idEnregistrement?: NullableIntFieldUpdateOperationsInput | number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalAuditCreateManyInput = {
    id?: number
    utilisateurId?: number | null
    action: string
    nomTable: string
    idEnregistrement?: number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
  }

  export type JournalAuditUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    nomTable?: StringFieldUpdateOperationsInput | string
    idEnregistrement?: NullableIntFieldUpdateOperationsInput | number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalAuditUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    nomTable?: StringFieldUpdateOperationsInput | string
    idEnregistrement?: NullableIntFieldUpdateOperationsInput | number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPaymentsInput
    cashier?: UserCreateNestedOneWithoutProcessedPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    employeeId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPaymentsNestedInput
    cashier?: UserUpdateOneWithoutProcessedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    employeeId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    title: string
    message: string
    type?: $Enums.NotificationType
    category: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    message: string
    type?: $Enums.NotificationType
    category: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    title: string
    message: string
    type?: $Enums.NotificationType
    category: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFactureCreateInput = {
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutFacturesInput
    creator: UserCreateNestedOneWithoutCreatedFacturesInput
    lignesFacture?: CompanyLigneFactureCreateNestedManyWithoutFactureInput
  }

  export type CompanyFactureUncheckedCreateInput = {
    id?: number
    employeeId: number
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
    lignesFacture?: CompanyLigneFactureUncheckedCreateNestedManyWithoutFactureInput
  }

  export type CompanyFactureUpdateInput = {
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutFacturesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedFacturesNestedInput
    lignesFacture?: CompanyLigneFactureUpdateManyWithoutFactureNestedInput
  }

  export type CompanyFactureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesFacture?: CompanyLigneFactureUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type CompanyFactureCreateManyInput = {
    id?: number
    employeeId: number
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyFactureUpdateManyMutationInput = {
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFactureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyLigneFactureCreateInput = {
    description: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    prixTotal: Decimal | DecimalJsLike | number | string
    creeLe?: Date | string
    facture: CompanyFactureCreateNestedOneWithoutLignesFactureInput
  }

  export type CompanyLigneFactureUncheckedCreateInput = {
    id?: number
    factureId: number
    description: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    prixTotal: Decimal | DecimalJsLike | number | string
    creeLe?: Date | string
  }

  export type CompanyLigneFactureUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    facture?: CompanyFactureUpdateOneRequiredWithoutLignesFactureNestedInput
  }

  export type CompanyLigneFactureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    factureId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyLigneFactureCreateManyInput = {
    id?: number
    factureId: number
    description: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    prixTotal: Decimal | DecimalJsLike | number | string
    creeLe?: Date | string
  }

  export type CompanyLigneFactureUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyLigneFactureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    factureId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPayRunCreateInput = {
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    approuveLe?: Date | string | null
    entreprise: EntrepriseCreateNestedOneWithoutPayRunsInput
    periodePaie: CompanyPeriodePaieCreateNestedOneWithoutPayRunsInput
    creator: UserCreateNestedOneWithoutCreatedPayRunsInput
    approver?: UserCreateNestedOneWithoutApprovedPayRunsInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunUncheckedCreateInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    periodePaieId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entreprise?: EntrepriseUpdateOneRequiredWithoutPayRunsNestedInput
    periodePaie?: CompanyPeriodePaieUpdateOneRequiredWithoutPayRunsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPayRunsNestedInput
    approver?: UserUpdateOneWithoutApprovedPayRunsNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunCreateManyInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    periodePaieId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
  }

  export type CompanyPayRunUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyPayRunUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyBulletinCreateInput = {
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
    payRun: CompanyPayRunCreateNestedOneWithoutBulletinsInput
    employee: EmployeeCreateNestedOneWithoutBulletinsInput
    paiements?: CompanyPaiementCreateNestedManyWithoutBulletinInput
  }

  export type CompanyBulletinUncheckedCreateInput = {
    id?: number
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    payRunId: number
    employeId: number
    creeLe?: Date | string
    modifieLe?: Date | string
    paiements?: CompanyPaiementUncheckedCreateNestedManyWithoutBulletinInput
  }

  export type CompanyBulletinUpdateInput = {
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRun?: CompanyPayRunUpdateOneRequiredWithoutBulletinsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutBulletinsNestedInput
    paiements?: CompanyPaiementUpdateManyWithoutBulletinNestedInput
  }

  export type CompanyBulletinUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    payRunId?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: CompanyPaiementUncheckedUpdateManyWithoutBulletinNestedInput
  }

  export type CompanyBulletinCreateManyInput = {
    id?: number
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    payRunId: number
    employeId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyBulletinUpdateManyMutationInput = {
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBulletinUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    payRunId?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPaiementCreateInput = {
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    bulletin: CompanyBulletinCreateNestedOneWithoutPaiementsInput
    processor: UserCreateNestedOneWithoutProcessedPaymentsCompanyInput
  }

  export type CompanyPaiementUncheckedCreateInput = {
    id?: number
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId: number
    traitePar: number
    creeLe?: Date | string
  }

  export type CompanyPaiementUpdateInput = {
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    bulletin?: CompanyBulletinUpdateOneRequiredWithoutPaiementsNestedInput
    processor?: UserUpdateOneRequiredWithoutProcessedPaymentsCompanyNestedInput
  }

  export type CompanyPaiementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId?: IntFieldUpdateOperationsInput | number
    traitePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPaiementCreateManyInput = {
    id?: number
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId: number
    traitePar: number
    creeLe?: Date | string
  }

  export type CompanyPaiementUpdateManyMutationInput = {
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPaiementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId?: IntFieldUpdateOperationsInput | number
    traitePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyTemplateCreateInput = {
    typeTemplate: string
    nom: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estDefaut?: boolean
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutTemplatesInput
  }

  export type CompanyTemplateUncheckedCreateInput = {
    id?: number
    typeTemplate: string
    nom: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estDefaut?: boolean
    estActif?: boolean
    entrepriseId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyTemplateUpdateInput = {
    typeTemplate?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estDefaut?: BoolFieldUpdateOperationsInput | boolean
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type CompanyTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeTemplate?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estDefaut?: BoolFieldUpdateOperationsInput | boolean
    estActif?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyTemplateCreateManyInput = {
    id?: number
    typeTemplate: string
    nom: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estDefaut?: boolean
    estActif?: boolean
    entrepriseId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyTemplateUpdateManyMutationInput = {
    typeTemplate?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estDefaut?: BoolFieldUpdateOperationsInput | boolean
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeTemplate?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estDefaut?: BoolFieldUpdateOperationsInput | boolean
    estActif?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingCreateInput = {
    cle: string
    valeur: string
    description?: string | null
    typeData: string
    estEncrypte?: boolean
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutSettingsInput
  }

  export type CompanySettingUncheckedCreateInput = {
    id?: number
    cle: string
    valeur: string
    description?: string | null
    typeData: string
    estEncrypte?: boolean
    entrepriseId: number
    modifieLe?: Date | string
  }

  export type CompanySettingUpdateInput = {
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeData?: StringFieldUpdateOperationsInput | string
    estEncrypte?: BoolFieldUpdateOperationsInput | boolean
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type CompanySettingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeData?: StringFieldUpdateOperationsInput | string
    estEncrypte?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingCreateManyInput = {
    id?: number
    cle: string
    valeur: string
    description?: string | null
    typeData: string
    estEncrypte?: boolean
    entrepriseId: number
    modifieLe?: Date | string
  }

  export type CompanySettingUpdateManyMutationInput = {
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeData?: StringFieldUpdateOperationsInput | string
    estEncrypte?: BoolFieldUpdateOperationsInput | boolean
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeData?: StringFieldUpdateOperationsInput | string
    estEncrypte?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentCreateInput = {
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    creeLe?: Date | string
    modifieLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type CompanyDocumentUncheckedCreateInput = {
    id?: number
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    employeId: number
    uploadePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyDocumentUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    employeId?: IntFieldUpdateOperationsInput | number
    uploadePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentCreateManyInput = {
    id?: number
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    employeId: number
    uploadePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyDocumentUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    employeId?: IntFieldUpdateOperationsInput | number
    uploadePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyModeleDocumentCreateInput = {
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    version?: number
    creeLe?: Date | string
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutModelesInput
    creator: UserCreateNestedOneWithoutCreatedModelesInput
  }

  export type CompanyModeleDocumentUncheckedCreateInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    entrepriseId: number
    version?: number
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyModeleDocumentUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutModelesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedModelesNestedInput
  }

  export type CompanyModeleDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyModeleDocumentCreateManyInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    entrepriseId: number
    version?: number
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyModeleDocumentUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyModeleDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPeriodePaieCreateInput = {
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutPeriodesPaieInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutPeriodePaieInput
  }

  export type CompanyPeriodePaieUncheckedCreateInput = {
    id?: number
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    creeLe?: Date | string
    modifieLe?: Date | string
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutPeriodePaieInput
  }

  export type CompanyPeriodePaieUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutPeriodesPaieNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutPeriodePaieNestedInput
  }

  export type CompanyPeriodePaieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutPeriodePaieNestedInput
  }

  export type CompanyPeriodePaieCreateManyInput = {
    id?: number
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyPeriodePaieUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPeriodePaieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyConfigurationPaieCreateInput = {
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutConfigurationsPaieInput
    reglesDeduction?: CompanyRegleDeductionCreateNestedManyWithoutConfigurationInput
  }

  export type CompanyConfigurationPaieUncheckedCreateInput = {
    id?: number
    entrepriseId: number
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
    reglesDeduction?: CompanyRegleDeductionUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type CompanyConfigurationPaieUpdateInput = {
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutConfigurationsPaieNestedInput
    reglesDeduction?: CompanyRegleDeductionUpdateManyWithoutConfigurationNestedInput
  }

  export type CompanyConfigurationPaieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    reglesDeduction?: CompanyRegleDeductionUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type CompanyConfigurationPaieCreateManyInput = {
    id?: number
    entrepriseId: number
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
  }

  export type CompanyConfigurationPaieUpdateManyMutationInput = {
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyConfigurationPaieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHistoriqueSalaireCreateInput = {
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutSalaryHistoryInput
    modifier: UserCreateNestedOneWithoutModifiedSalariesInput
  }

  export type CompanyHistoriqueSalaireUncheckedCreateInput = {
    id?: number
    employeId: number
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar: number
    creeLe?: Date | string
  }

  export type CompanyHistoriqueSalaireUpdateInput = {
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSalaryHistoryNestedInput
    modifier?: UserUpdateOneRequiredWithoutModifiedSalariesNestedInput
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHistoriqueSalaireCreateManyInput = {
    id?: number
    employeId: number
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar: number
    creeLe?: Date | string
  }

  export type CompanyHistoriqueSalaireUpdateManyMutationInput = {
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRegleDeductionCreateInput = {
    nom: string
    description?: string | null
    type: string
    formule: string
    conditionsApplication: JsonNullValueInput | InputJsonValue
    estObligatoire?: boolean
    ordre: number
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
    configuration: CompanyConfigurationPaieCreateNestedOneWithoutReglesDeductionInput
  }

  export type CompanyRegleDeductionUncheckedCreateInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    formule: string
    conditionsApplication: JsonNullValueInput | InputJsonValue
    estObligatoire?: boolean
    ordre: number
    configurationId: number
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyRegleDeductionUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    formule?: StringFieldUpdateOperationsInput | string
    conditionsApplication?: JsonNullValueInput | InputJsonValue
    estObligatoire?: BoolFieldUpdateOperationsInput | boolean
    ordre?: IntFieldUpdateOperationsInput | number
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    configuration?: CompanyConfigurationPaieUpdateOneRequiredWithoutReglesDeductionNestedInput
  }

  export type CompanyRegleDeductionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    formule?: StringFieldUpdateOperationsInput | string
    conditionsApplication?: JsonNullValueInput | InputJsonValue
    estObligatoire?: BoolFieldUpdateOperationsInput | boolean
    ordre?: IntFieldUpdateOperationsInput | number
    configurationId?: IntFieldUpdateOperationsInput | number
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRegleDeductionCreateManyInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    formule: string
    conditionsApplication: JsonNullValueInput | InputJsonValue
    estObligatoire?: boolean
    ordre: number
    configurationId: number
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyRegleDeductionUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    formule?: StringFieldUpdateOperationsInput | string
    conditionsApplication?: JsonNullValueInput | InputJsonValue
    estObligatoire?: BoolFieldUpdateOperationsInput | boolean
    ordre?: IntFieldUpdateOperationsInput | number
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRegleDeductionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    formule?: StringFieldUpdateOperationsInput | string
    conditionsApplication?: JsonNullValueInput | InputJsonValue
    estObligatoire?: BoolFieldUpdateOperationsInput | boolean
    ordre?: IntFieldUpdateOperationsInput | number
    configurationId?: IntFieldUpdateOperationsInput | number
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointageCreateInput = {
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    employe: EmployeeCreateNestedOneWithoutPointagesInput
    validateur?: UserCreateNestedOneWithoutValidatedPointagesInput
  }

  export type PointageUncheckedCreateInput = {
    id?: number
    employeId: number
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    validePar?: number | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type PointageUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employe?: EmployeeUpdateOneRequiredWithoutPointagesNestedInput
    validateur?: UserUpdateOneWithoutValidatedPointagesNestedInput
  }

  export type PointageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    validePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointageCreateManyInput = {
    id?: number
    employeId: number
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    validePar?: number | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type PointageUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    validePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReglePointageCreateInput = {
    heureDebut?: string
    heureFin?: string
    toleranceRetard?: number
    toleranceDepart?: number
    joursTravail: JsonNullValueInput | InputJsonValue
    heuresParJour?: number
    heuresSupAutorise?: boolean
    seuilHeuresSup?: number
    pauseDejeuner?: number
    estFlexible?: boolean
    plageHoraireMin?: string | null
    plageHoraireMax?: string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutReglePointageInput
  }

  export type ReglePointageUncheckedCreateInput = {
    id?: number
    entrepriseId: number
    heureDebut?: string
    heureFin?: string
    toleranceRetard?: number
    toleranceDepart?: number
    joursTravail: JsonNullValueInput | InputJsonValue
    heuresParJour?: number
    heuresSupAutorise?: boolean
    seuilHeuresSup?: number
    pauseDejeuner?: number
    estFlexible?: boolean
    plageHoraireMin?: string | null
    plageHoraireMax?: string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
  }

  export type ReglePointageUpdateInput = {
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    toleranceRetard?: IntFieldUpdateOperationsInput | number
    toleranceDepart?: IntFieldUpdateOperationsInput | number
    joursTravail?: JsonNullValueInput | InputJsonValue
    heuresParJour?: IntFieldUpdateOperationsInput | number
    heuresSupAutorise?: BoolFieldUpdateOperationsInput | boolean
    seuilHeuresSup?: IntFieldUpdateOperationsInput | number
    pauseDejeuner?: IntFieldUpdateOperationsInput | number
    estFlexible?: BoolFieldUpdateOperationsInput | boolean
    plageHoraireMin?: NullableStringFieldUpdateOperationsInput | string | null
    plageHoraireMax?: NullableStringFieldUpdateOperationsInput | string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutReglePointageNestedInput
  }

  export type ReglePointageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    toleranceRetard?: IntFieldUpdateOperationsInput | number
    toleranceDepart?: IntFieldUpdateOperationsInput | number
    joursTravail?: JsonNullValueInput | InputJsonValue
    heuresParJour?: IntFieldUpdateOperationsInput | number
    heuresSupAutorise?: BoolFieldUpdateOperationsInput | boolean
    seuilHeuresSup?: IntFieldUpdateOperationsInput | number
    pauseDejeuner?: IntFieldUpdateOperationsInput | number
    estFlexible?: BoolFieldUpdateOperationsInput | boolean
    plageHoraireMin?: NullableStringFieldUpdateOperationsInput | string | null
    plageHoraireMax?: NullableStringFieldUpdateOperationsInput | string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReglePointageCreateManyInput = {
    id?: number
    entrepriseId: number
    heureDebut?: string
    heureFin?: string
    toleranceRetard?: number
    toleranceDepart?: number
    joursTravail: JsonNullValueInput | InputJsonValue
    heuresParJour?: number
    heuresSupAutorise?: boolean
    seuilHeuresSup?: number
    pauseDejeuner?: number
    estFlexible?: boolean
    plageHoraireMin?: string | null
    plageHoraireMax?: string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
  }

  export type ReglePointageUpdateManyMutationInput = {
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    toleranceRetard?: IntFieldUpdateOperationsInput | number
    toleranceDepart?: IntFieldUpdateOperationsInput | number
    joursTravail?: JsonNullValueInput | InputJsonValue
    heuresParJour?: IntFieldUpdateOperationsInput | number
    heuresSupAutorise?: BoolFieldUpdateOperationsInput | boolean
    seuilHeuresSup?: IntFieldUpdateOperationsInput | number
    pauseDejeuner?: IntFieldUpdateOperationsInput | number
    estFlexible?: BoolFieldUpdateOperationsInput | boolean
    plageHoraireMin?: NullableStringFieldUpdateOperationsInput | string | null
    plageHoraireMax?: NullableStringFieldUpdateOperationsInput | string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReglePointageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    toleranceRetard?: IntFieldUpdateOperationsInput | number
    toleranceDepart?: IntFieldUpdateOperationsInput | number
    joursTravail?: JsonNullValueInput | InputJsonValue
    heuresParJour?: IntFieldUpdateOperationsInput | number
    heuresSupAutorise?: BoolFieldUpdateOperationsInput | boolean
    seuilHeuresSup?: IntFieldUpdateOperationsInput | number
    pauseDejeuner?: IntFieldUpdateOperationsInput | number
    estFlexible?: BoolFieldUpdateOperationsInput | boolean
    plageHoraireMin?: NullableStringFieldUpdateOperationsInput | string | null
    plageHoraireMax?: NullableStringFieldUpdateOperationsInput | string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceCreateInput = {
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    employe: EmployeeCreateNestedOneWithoutAbsencesInput
    approbateur?: UserCreateNestedOneWithoutApprovedAbsencesInput
  }

  export type AbsenceUncheckedCreateInput = {
    id?: number
    employeId: number
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    approuvePar?: number | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type AbsenceUpdateInput = {
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employe?: EmployeeUpdateOneRequiredWithoutAbsencesNestedInput
    approbateur?: UserUpdateOneWithoutApprovedAbsencesNestedInput
  }

  export type AbsenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceCreateManyInput = {
    id?: number
    employeId: number
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    approuvePar?: number | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type AbsenceUpdateManyMutationInput = {
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type JournalAuditListRelationFilter = {
    every?: JournalAuditWhereInput
    some?: JournalAuditWhereInput
    none?: JournalAuditWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CompanyFactureListRelationFilter = {
    every?: CompanyFactureWhereInput
    some?: CompanyFactureWhereInput
    none?: CompanyFactureWhereInput
  }

  export type CompanyPayRunListRelationFilter = {
    every?: CompanyPayRunWhereInput
    some?: CompanyPayRunWhereInput
    none?: CompanyPayRunWhereInput
  }

  export type CompanyPaiementListRelationFilter = {
    every?: CompanyPaiementWhereInput
    some?: CompanyPaiementWhereInput
    none?: CompanyPaiementWhereInput
  }

  export type CompanyDocumentListRelationFilter = {
    every?: CompanyDocumentWhereInput
    some?: CompanyDocumentWhereInput
    none?: CompanyDocumentWhereInput
  }

  export type CompanyModeleDocumentListRelationFilter = {
    every?: CompanyModeleDocumentWhereInput
    some?: CompanyModeleDocumentWhereInput
    none?: CompanyModeleDocumentWhereInput
  }

  export type CompanyHistoriqueSalaireListRelationFilter = {
    every?: CompanyHistoriqueSalaireWhereInput
    some?: CompanyHistoriqueSalaireWhereInput
    none?: CompanyHistoriqueSalaireWhereInput
  }

  export type PointageListRelationFilter = {
    every?: PointageWhereInput
    some?: PointageWhereInput
    none?: PointageWhereInput
  }

  export type AbsenceListRelationFilter = {
    every?: AbsenceWhereInput
    some?: AbsenceWhereInput
    none?: AbsenceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type JournalAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyFactureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyPayRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyPaiementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyModeleDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyHistoriqueSalaireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AbsenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    lastLogin?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumEmployeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[]
    notIn?: $Enums.EmployeeStatus[]
    not?: NestedEnumEmployeeStatusFilter<$PrismaModel> | $Enums.EmployeeStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EntrepriseScalarRelationFilter = {
    is?: EntrepriseWhereInput
    isNot?: EntrepriseWhereInput
  }

  export type CompanyBulletinListRelationFilter = {
    every?: CompanyBulletinWhereInput
    some?: CompanyBulletinWhereInput
    none?: CompanyBulletinWhereInput
  }

  export type CompanyBulletinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelevanceInput = {
    fields: EmployeeOrderByRelevanceFieldEnum | EmployeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entrepriseId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    contractType?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    hireDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entrepriseId?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entrepriseId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    contractType?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    hireDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entrepriseId?: SortOrder
    employeeId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    contractType?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
    hireDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entrepriseId?: SortOrder
    salary?: SortOrder
    dailyRate?: SortOrder
    hourlyRate?: SortOrder
  }

  export type EnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumEmployeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[]
    notIn?: $Enums.EmployeeStatus[]
    not?: NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeStatusFilter<$PrismaModel>
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type CompanyTemplateListRelationFilter = {
    every?: CompanyTemplateWhereInput
    some?: CompanyTemplateWhereInput
    none?: CompanyTemplateWhereInput
  }

  export type CompanySettingListRelationFilter = {
    every?: CompanySettingWhereInput
    some?: CompanySettingWhereInput
    none?: CompanySettingWhereInput
  }

  export type CompanyPeriodePaieListRelationFilter = {
    every?: CompanyPeriodePaieWhereInput
    some?: CompanyPeriodePaieWhereInput
    none?: CompanyPeriodePaieWhereInput
  }

  export type CompanyConfigurationPaieListRelationFilter = {
    every?: CompanyConfigurationPaieWhereInput
    some?: CompanyConfigurationPaieWhereInput
    none?: CompanyConfigurationPaieWhereInput
  }

  export type ReglePointageNullableScalarRelationFilter = {
    is?: ReglePointageWhereInput | null
    isNot?: ReglePointageWhereInput | null
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanySettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyPeriodePaieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyConfigurationPaieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntrepriseOrderByRelevanceInput = {
    fields: EntrepriseOrderByRelevanceFieldEnum | EntrepriseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EntrepriseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    siteWeb?: SortOrder
    logo?: SortOrder
    couleurPrimaire?: SortOrder
    couleurSecondaire?: SortOrder
    couleurDashboard?: SortOrder
    description?: SortOrder
    devise?: SortOrder
    timezone?: SortOrder
    periodePayroll?: SortOrder
    estActive?: SortOrder
    parametres?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type EntrepriseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EntrepriseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    siteWeb?: SortOrder
    logo?: SortOrder
    couleurPrimaire?: SortOrder
    couleurSecondaire?: SortOrder
    couleurDashboard?: SortOrder
    description?: SortOrder
    devise?: SortOrder
    timezone?: SortOrder
    periodePayroll?: SortOrder
    estActive?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type EntrepriseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    adresse?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    siteWeb?: SortOrder
    logo?: SortOrder
    couleurPrimaire?: SortOrder
    couleurSecondaire?: SortOrder
    couleurDashboard?: SortOrder
    description?: SortOrder
    devise?: SortOrder
    timezone?: SortOrder
    periodePayroll?: SortOrder
    estActive?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type EntrepriseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type JournalAuditOrderByRelevanceInput = {
    fields: JournalAuditOrderByRelevanceFieldEnum | JournalAuditOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JournalAuditCountOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    action?: SortOrder
    nomTable?: SortOrder
    idEnregistrement?: SortOrder
    anciennes_valeurs?: SortOrder
    nouvelles_valeurs?: SortOrder
    creeLe?: SortOrder
  }

  export type JournalAuditAvgOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    idEnregistrement?: SortOrder
  }

  export type JournalAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    action?: SortOrder
    nomTable?: SortOrder
    idEnregistrement?: SortOrder
    creeLe?: SortOrder
  }

  export type JournalAuditMinOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    action?: SortOrder
    nomTable?: SortOrder
    idEnregistrement?: SortOrder
    creeLe?: SortOrder
  }

  export type JournalAuditSumOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    idEnregistrement?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    processedBy?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    processedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    processedBy?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumCompanyStatutFactureFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutFacture | EnumCompanyStatutFactureFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutFacture[]
    notIn?: $Enums.CompanyStatutFacture[]
    not?: NestedEnumCompanyStatutFactureFilter<$PrismaModel> | $Enums.CompanyStatutFacture
  }

  export type CompanyLigneFactureListRelationFilter = {
    every?: CompanyLigneFactureWhereInput
    some?: CompanyLigneFactureWhereInput
    none?: CompanyLigneFactureWhereInput
  }

  export type CompanyLigneFactureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyFactureOrderByRelevanceInput = {
    fields: CompanyFactureOrderByRelevanceFieldEnum | CompanyFactureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyFactureCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    numeroFacture?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    dateEcheance?: SortOrder
    datePaiement?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyFactureAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    montant?: SortOrder
    creePar?: SortOrder
  }

  export type CompanyFactureMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    numeroFacture?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    dateEcheance?: SortOrder
    datePaiement?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyFactureMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    numeroFacture?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    dateEcheance?: SortOrder
    datePaiement?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyFactureSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    montant?: SortOrder
    creePar?: SortOrder
  }

  export type EnumCompanyStatutFactureWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutFacture | EnumCompanyStatutFactureFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutFacture[]
    notIn?: $Enums.CompanyStatutFacture[]
    not?: NestedEnumCompanyStatutFactureWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatutFacture
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatutFactureFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatutFactureFilter<$PrismaModel>
  }

  export type CompanyFactureScalarRelationFilter = {
    is?: CompanyFactureWhereInput
    isNot?: CompanyFactureWhereInput
  }

  export type CompanyLigneFactureOrderByRelevanceInput = {
    fields: CompanyLigneFactureOrderByRelevanceFieldEnum | CompanyLigneFactureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyLigneFactureCountOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyLigneFactureAvgOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
  }

  export type CompanyLigneFactureMaxOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyLigneFactureMinOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    description?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyLigneFactureSumOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
  }

  export type EnumCompanyStatutPayRunFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutPayRun | EnumCompanyStatutPayRunFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutPayRun[]
    notIn?: $Enums.CompanyStatutPayRun[]
    not?: NestedEnumCompanyStatutPayRunFilter<$PrismaModel> | $Enums.CompanyStatutPayRun
  }

  export type CompanyPeriodePaieScalarRelationFilter = {
    is?: CompanyPeriodePaieWhereInput
    isNot?: CompanyPeriodePaieWhereInput
  }

  export type CompanyPayRunOrderByRelevanceInput = {
    fields: CompanyPayRunOrderByRelevanceFieldEnum | CompanyPayRunOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyPayRunCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    datePaiement?: SortOrder
    statut?: SortOrder
    totalBrut?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
    nombreEmployes?: SortOrder
    metadata?: SortOrder
    entrepriseId?: SortOrder
    periodePaieId?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    approuveLe?: SortOrder
    approuvePar?: SortOrder
  }

  export type CompanyPayRunAvgOrderByAggregateInput = {
    id?: SortOrder
    totalBrut?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
    nombreEmployes?: SortOrder
    entrepriseId?: SortOrder
    periodePaieId?: SortOrder
    creePar?: SortOrder
    approuvePar?: SortOrder
  }

  export type CompanyPayRunMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    datePaiement?: SortOrder
    statut?: SortOrder
    totalBrut?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
    nombreEmployes?: SortOrder
    entrepriseId?: SortOrder
    periodePaieId?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    approuveLe?: SortOrder
    approuvePar?: SortOrder
  }

  export type CompanyPayRunMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    datePaiement?: SortOrder
    statut?: SortOrder
    totalBrut?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
    nombreEmployes?: SortOrder
    entrepriseId?: SortOrder
    periodePaieId?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    approuveLe?: SortOrder
    approuvePar?: SortOrder
  }

  export type CompanyPayRunSumOrderByAggregateInput = {
    id?: SortOrder
    totalBrut?: SortOrder
    totalNet?: SortOrder
    totalDeductions?: SortOrder
    nombreEmployes?: SortOrder
    entrepriseId?: SortOrder
    periodePaieId?: SortOrder
    creePar?: SortOrder
    approuvePar?: SortOrder
  }

  export type EnumCompanyStatutPayRunWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutPayRun | EnumCompanyStatutPayRunFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutPayRun[]
    notIn?: $Enums.CompanyStatutPayRun[]
    not?: NestedEnumCompanyStatutPayRunWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatutPayRun
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatutPayRunFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatutPayRunFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CompanyPayRunScalarRelationFilter = {
    is?: CompanyPayRunWhereInput
    isNot?: CompanyPayRunWhereInput
  }

  export type CompanyBulletinOrderByRelevanceInput = {
    fields: CompanyBulletinOrderByRelevanceFieldEnum | CompanyBulletinOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyBulletinCountOrderByAggregateInput = {
    id?: SortOrder
    numeroBulletin?: SortOrder
    datePaiement?: SortOrder
    joursTravailles?: SortOrder
    heuresTravailes?: SortOrder
    salaireBrut?: SortOrder
    salaireBase?: SortOrder
    montantHeuresSupp?: SortOrder
    montantBonus?: SortOrder
    indemnites?: SortOrder
    deductions?: SortOrder
    totalDeductions?: SortOrder
    salaireNet?: SortOrder
    montantPaye?: SortOrder
    resteAPayer?: SortOrder
    statutPaiement?: SortOrder
    cheminPDF?: SortOrder
    calculs?: SortOrder
    estVerrouille?: SortOrder
    payRunId?: SortOrder
    employeId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyBulletinAvgOrderByAggregateInput = {
    id?: SortOrder
    joursTravailles?: SortOrder
    heuresTravailes?: SortOrder
    salaireBrut?: SortOrder
    salaireBase?: SortOrder
    montantHeuresSupp?: SortOrder
    montantBonus?: SortOrder
    indemnites?: SortOrder
    totalDeductions?: SortOrder
    salaireNet?: SortOrder
    montantPaye?: SortOrder
    resteAPayer?: SortOrder
    payRunId?: SortOrder
    employeId?: SortOrder
  }

  export type CompanyBulletinMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroBulletin?: SortOrder
    datePaiement?: SortOrder
    joursTravailles?: SortOrder
    heuresTravailes?: SortOrder
    salaireBrut?: SortOrder
    salaireBase?: SortOrder
    montantHeuresSupp?: SortOrder
    montantBonus?: SortOrder
    indemnites?: SortOrder
    totalDeductions?: SortOrder
    salaireNet?: SortOrder
    montantPaye?: SortOrder
    resteAPayer?: SortOrder
    statutPaiement?: SortOrder
    cheminPDF?: SortOrder
    estVerrouille?: SortOrder
    payRunId?: SortOrder
    employeId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyBulletinMinOrderByAggregateInput = {
    id?: SortOrder
    numeroBulletin?: SortOrder
    datePaiement?: SortOrder
    joursTravailles?: SortOrder
    heuresTravailes?: SortOrder
    salaireBrut?: SortOrder
    salaireBase?: SortOrder
    montantHeuresSupp?: SortOrder
    montantBonus?: SortOrder
    indemnites?: SortOrder
    totalDeductions?: SortOrder
    salaireNet?: SortOrder
    montantPaye?: SortOrder
    resteAPayer?: SortOrder
    statutPaiement?: SortOrder
    cheminPDF?: SortOrder
    estVerrouille?: SortOrder
    payRunId?: SortOrder
    employeId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyBulletinSumOrderByAggregateInput = {
    id?: SortOrder
    joursTravailles?: SortOrder
    heuresTravailes?: SortOrder
    salaireBrut?: SortOrder
    salaireBase?: SortOrder
    montantHeuresSupp?: SortOrder
    montantBonus?: SortOrder
    indemnites?: SortOrder
    totalDeductions?: SortOrder
    salaireNet?: SortOrder
    montantPaye?: SortOrder
    resteAPayer?: SortOrder
    payRunId?: SortOrder
    employeId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CompanyBulletinScalarRelationFilter = {
    is?: CompanyBulletinWhereInput
    isNot?: CompanyBulletinWhereInput
  }

  export type CompanyPaiementOrderByRelevanceInput = {
    fields: CompanyPaiementOrderByRelevanceFieldEnum | CompanyPaiementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyPaiementCountOrderByAggregateInput = {
    id?: SortOrder
    referenceTransaction?: SortOrder
    montant?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    datePaiement?: SortOrder
    notes?: SortOrder
    cheminRecu?: SortOrder
    statut?: SortOrder
    metadata?: SortOrder
    bulletinId?: SortOrder
    traitePar?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyPaiementAvgOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    bulletinId?: SortOrder
    traitePar?: SortOrder
  }

  export type CompanyPaiementMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceTransaction?: SortOrder
    montant?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    datePaiement?: SortOrder
    notes?: SortOrder
    cheminRecu?: SortOrder
    statut?: SortOrder
    bulletinId?: SortOrder
    traitePar?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyPaiementMinOrderByAggregateInput = {
    id?: SortOrder
    referenceTransaction?: SortOrder
    montant?: SortOrder
    methodePaiement?: SortOrder
    referencePaiement?: SortOrder
    datePaiement?: SortOrder
    notes?: SortOrder
    cheminRecu?: SortOrder
    statut?: SortOrder
    bulletinId?: SortOrder
    traitePar?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyPaiementSumOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    bulletinId?: SortOrder
    traitePar?: SortOrder
  }

  export type CompanyTemplateOrderByRelevanceInput = {
    fields: CompanyTemplateOrderByRelevanceFieldEnum | CompanyTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    typeTemplate?: SortOrder
    nom?: SortOrder
    contenu?: SortOrder
    variables?: SortOrder
    estDefaut?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
  }

  export type CompanyTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    typeTemplate?: SortOrder
    nom?: SortOrder
    contenu?: SortOrder
    estDefaut?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    typeTemplate?: SortOrder
    nom?: SortOrder
    contenu?: SortOrder
    estDefaut?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
  }

  export type CompanySettingOrderByRelevanceInput = {
    fields: CompanySettingOrderByRelevanceFieldEnum | CompanySettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanySettingCleEntrepriseIdCompoundUniqueInput = {
    cle: string
    entrepriseId: number
  }

  export type CompanySettingCountOrderByAggregateInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    description?: SortOrder
    typeData?: SortOrder
    estEncrypte?: SortOrder
    entrepriseId?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanySettingAvgOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
  }

  export type CompanySettingMaxOrderByAggregateInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    description?: SortOrder
    typeData?: SortOrder
    estEncrypte?: SortOrder
    entrepriseId?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanySettingMinOrderByAggregateInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    description?: SortOrder
    typeData?: SortOrder
    estEncrypte?: SortOrder
    entrepriseId?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanySettingSumOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
  }

  export type CompanyDocumentOrderByRelevanceInput = {
    fields: CompanyDocumentOrderByRelevanceFieldEnum | CompanyDocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    cheminFichier?: SortOrder
    tailleFichier?: SortOrder
    mimeType?: SortOrder
    metadata?: SortOrder
    tags?: SortOrder
    employeId?: SortOrder
    uploadePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    tailleFichier?: SortOrder
    employeId?: SortOrder
    uploadePar?: SortOrder
  }

  export type CompanyDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    cheminFichier?: SortOrder
    tailleFichier?: SortOrder
    mimeType?: SortOrder
    tags?: SortOrder
    employeId?: SortOrder
    uploadePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    cheminFichier?: SortOrder
    tailleFichier?: SortOrder
    mimeType?: SortOrder
    tags?: SortOrder
    employeId?: SortOrder
    uploadePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    tailleFichier?: SortOrder
    employeId?: SortOrder
    uploadePar?: SortOrder
  }

  export type CompanyModeleDocumentOrderByRelevanceInput = {
    fields: CompanyModeleDocumentOrderByRelevanceFieldEnum | CompanyModeleDocumentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyModeleDocumentEntrepriseIdNomVersionCompoundUniqueInput = {
    entrepriseId: number
    nom: string
    version: number
  }

  export type CompanyModeleDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    type?: SortOrder
    contenu?: SortOrder
    variables?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    version?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyModeleDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    version?: SortOrder
    creePar?: SortOrder
  }

  export type CompanyModeleDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    type?: SortOrder
    contenu?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    version?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyModeleDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    type?: SortOrder
    contenu?: SortOrder
    estActif?: SortOrder
    entrepriseId?: SortOrder
    version?: SortOrder
    creePar?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyModeleDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    version?: SortOrder
    creePar?: SortOrder
  }

  export type CompanyPeriodePaieOrderByRelevanceInput = {
    fields: CompanyPeriodePaieOrderByRelevanceFieldEnum | CompanyPeriodePaieOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyPeriodePaieCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estCloturee?: SortOrder
    dateReglement?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyPeriodePaieAvgOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
  }

  export type CompanyPeriodePaieMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estCloturee?: SortOrder
    dateReglement?: SortOrder
    notes?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyPeriodePaieMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    estCloturee?: SortOrder
    dateReglement?: SortOrder
    notes?: SortOrder
    entrepriseId?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyPeriodePaieSumOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
  }

  export type CompanyRegleDeductionListRelationFilter = {
    every?: CompanyRegleDeductionWhereInput
    some?: CompanyRegleDeductionWhereInput
    none?: CompanyRegleDeductionWhereInput
  }

  export type CompanyRegleDeductionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyConfigurationPaieOrderByRelevanceInput = {
    fields: CompanyConfigurationPaieOrderByRelevanceFieldEnum | CompanyConfigurationPaieOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyConfigurationPaieCountOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    jourPaie?: SortOrder
    periodeCalcul?: SortOrder
    regleArrondi?: SortOrder
    deviseSecondaire?: SortOrder
    tauxChange?: SortOrder
    formatNumeration?: SortOrder
    regleValidation?: SortOrder
    parametresCalcul?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyConfigurationPaieAvgOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    jourPaie?: SortOrder
    tauxChange?: SortOrder
  }

  export type CompanyConfigurationPaieMaxOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    jourPaie?: SortOrder
    periodeCalcul?: SortOrder
    regleArrondi?: SortOrder
    deviseSecondaire?: SortOrder
    tauxChange?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyConfigurationPaieMinOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    jourPaie?: SortOrder
    periodeCalcul?: SortOrder
    regleArrondi?: SortOrder
    deviseSecondaire?: SortOrder
    tauxChange?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyConfigurationPaieSumOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    jourPaie?: SortOrder
    tauxChange?: SortOrder
  }

  export type CompanyHistoriqueSalaireOrderByRelevanceInput = {
    fields: CompanyHistoriqueSalaireOrderByRelevanceFieldEnum | CompanyHistoriqueSalaireOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyHistoriqueSalaireCountOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    ancienSalaire?: SortOrder
    nouveauSalaire?: SortOrder
    dateEffet?: SortOrder
    motif?: SortOrder
    notes?: SortOrder
    documents?: SortOrder
    modifiePar?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyHistoriqueSalaireAvgOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    ancienSalaire?: SortOrder
    nouveauSalaire?: SortOrder
    modifiePar?: SortOrder
  }

  export type CompanyHistoriqueSalaireMaxOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    ancienSalaire?: SortOrder
    nouveauSalaire?: SortOrder
    dateEffet?: SortOrder
    motif?: SortOrder
    notes?: SortOrder
    modifiePar?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyHistoriqueSalaireMinOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    ancienSalaire?: SortOrder
    nouveauSalaire?: SortOrder
    dateEffet?: SortOrder
    motif?: SortOrder
    notes?: SortOrder
    modifiePar?: SortOrder
    creeLe?: SortOrder
  }

  export type CompanyHistoriqueSalaireSumOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    ancienSalaire?: SortOrder
    nouveauSalaire?: SortOrder
    modifiePar?: SortOrder
  }

  export type CompanyConfigurationPaieScalarRelationFilter = {
    is?: CompanyConfigurationPaieWhereInput
    isNot?: CompanyConfigurationPaieWhereInput
  }

  export type CompanyRegleDeductionOrderByRelevanceInput = {
    fields: CompanyRegleDeductionOrderByRelevanceFieldEnum | CompanyRegleDeductionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyRegleDeductionCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    type?: SortOrder
    formule?: SortOrder
    conditionsApplication?: SortOrder
    estObligatoire?: SortOrder
    ordre?: SortOrder
    configurationId?: SortOrder
    estActif?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyRegleDeductionAvgOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    configurationId?: SortOrder
  }

  export type CompanyRegleDeductionMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    type?: SortOrder
    formule?: SortOrder
    estObligatoire?: SortOrder
    ordre?: SortOrder
    configurationId?: SortOrder
    estActif?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyRegleDeductionMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    type?: SortOrder
    formule?: SortOrder
    estObligatoire?: SortOrder
    ordre?: SortOrder
    configurationId?: SortOrder
    estActif?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type CompanyRegleDeductionSumOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    configurationId?: SortOrder
  }

  export type EnumStatutPointageFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPointage | EnumStatutPointageFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPointage[]
    notIn?: $Enums.StatutPointage[]
    not?: NestedEnumStatutPointageFilter<$PrismaModel> | $Enums.StatutPointage
  }

  export type EnumTypePointageFilter<$PrismaModel = never> = {
    equals?: $Enums.TypePointage | EnumTypePointageFieldRefInput<$PrismaModel>
    in?: $Enums.TypePointage[]
    notIn?: $Enums.TypePointage[]
    not?: NestedEnumTypePointageFilter<$PrismaModel> | $Enums.TypePointage
  }

  export type PointageOrderByRelevanceInput = {
    fields: PointageOrderByRelevanceFieldEnum | PointageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PointageCountOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    statut?: SortOrder
    typePointage?: SortOrder
    commentaire?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    ipAddress?: SortOrder
    deviceInfo?: SortOrder
    validePar?: SortOrder
    dateValidation?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type PointageAvgOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    validePar?: SortOrder
  }

  export type PointageMaxOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    statut?: SortOrder
    typePointage?: SortOrder
    commentaire?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    ipAddress?: SortOrder
    deviceInfo?: SortOrder
    validePar?: SortOrder
    dateValidation?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type PointageMinOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    statut?: SortOrder
    typePointage?: SortOrder
    commentaire?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    ipAddress?: SortOrder
    deviceInfo?: SortOrder
    validePar?: SortOrder
    dateValidation?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type PointageSumOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    validePar?: SortOrder
  }

  export type EnumStatutPointageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPointage | EnumStatutPointageFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPointage[]
    notIn?: $Enums.StatutPointage[]
    not?: NestedEnumStatutPointageWithAggregatesFilter<$PrismaModel> | $Enums.StatutPointage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutPointageFilter<$PrismaModel>
    _max?: NestedEnumStatutPointageFilter<$PrismaModel>
  }

  export type EnumTypePointageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypePointage | EnumTypePointageFieldRefInput<$PrismaModel>
    in?: $Enums.TypePointage[]
    notIn?: $Enums.TypePointage[]
    not?: NestedEnumTypePointageWithAggregatesFilter<$PrismaModel> | $Enums.TypePointage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypePointageFilter<$PrismaModel>
    _max?: NestedEnumTypePointageFilter<$PrismaModel>
  }

  export type ReglePointageOrderByRelevanceInput = {
    fields: ReglePointageOrderByRelevanceFieldEnum | ReglePointageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReglePointageCountOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    toleranceRetard?: SortOrder
    toleranceDepart?: SortOrder
    joursTravail?: SortOrder
    heuresParJour?: SortOrder
    heuresSupAutorise?: SortOrder
    seuilHeuresSup?: SortOrder
    pauseDejeuner?: SortOrder
    estFlexible?: SortOrder
    plageHoraireMin?: SortOrder
    plageHoraireMax?: SortOrder
    joursFeries?: SortOrder
    modifieLe?: SortOrder
  }

  export type ReglePointageAvgOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    toleranceRetard?: SortOrder
    toleranceDepart?: SortOrder
    heuresParJour?: SortOrder
    seuilHeuresSup?: SortOrder
    pauseDejeuner?: SortOrder
  }

  export type ReglePointageMaxOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    toleranceRetard?: SortOrder
    toleranceDepart?: SortOrder
    heuresParJour?: SortOrder
    heuresSupAutorise?: SortOrder
    seuilHeuresSup?: SortOrder
    pauseDejeuner?: SortOrder
    estFlexible?: SortOrder
    plageHoraireMin?: SortOrder
    plageHoraireMax?: SortOrder
    modifieLe?: SortOrder
  }

  export type ReglePointageMinOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    toleranceRetard?: SortOrder
    toleranceDepart?: SortOrder
    heuresParJour?: SortOrder
    heuresSupAutorise?: SortOrder
    seuilHeuresSup?: SortOrder
    pauseDejeuner?: SortOrder
    estFlexible?: SortOrder
    plageHoraireMin?: SortOrder
    plageHoraireMax?: SortOrder
    modifieLe?: SortOrder
  }

  export type ReglePointageSumOrderByAggregateInput = {
    id?: SortOrder
    entrepriseId?: SortOrder
    toleranceRetard?: SortOrder
    toleranceDepart?: SortOrder
    heuresParJour?: SortOrder
    seuilHeuresSup?: SortOrder
    pauseDejeuner?: SortOrder
  }

  export type EnumTypeAbsenceFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeAbsence | EnumTypeAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeAbsence[]
    notIn?: $Enums.TypeAbsence[]
    not?: NestedEnumTypeAbsenceFilter<$PrismaModel> | $Enums.TypeAbsence
  }

  export type EnumStatutAbsenceFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAbsence | EnumStatutAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAbsence[]
    notIn?: $Enums.StatutAbsence[]
    not?: NestedEnumStatutAbsenceFilter<$PrismaModel> | $Enums.StatutAbsence
  }

  export type AbsenceOrderByRelevanceInput = {
    fields: AbsenceOrderByRelevanceFieldEnum | AbsenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AbsenceCountOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    typeAbsence?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    joursOuvres?: SortOrder
    heuresAbsence?: SortOrder
    commentaire?: SortOrder
    pieceJointe?: SortOrder
    approuvePar?: SortOrder
    dateApprobation?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type AbsenceAvgOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    joursOuvres?: SortOrder
    heuresAbsence?: SortOrder
    approuvePar?: SortOrder
  }

  export type AbsenceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    typeAbsence?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    joursOuvres?: SortOrder
    heuresAbsence?: SortOrder
    commentaire?: SortOrder
    pieceJointe?: SortOrder
    approuvePar?: SortOrder
    dateApprobation?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type AbsenceMinOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    typeAbsence?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    joursOuvres?: SortOrder
    heuresAbsence?: SortOrder
    commentaire?: SortOrder
    pieceJointe?: SortOrder
    approuvePar?: SortOrder
    dateApprobation?: SortOrder
    creeLe?: SortOrder
    modifieLe?: SortOrder
  }

  export type AbsenceSumOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    joursOuvres?: SortOrder
    heuresAbsence?: SortOrder
    approuvePar?: SortOrder
  }

  export type EnumTypeAbsenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeAbsence | EnumTypeAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeAbsence[]
    notIn?: $Enums.TypeAbsence[]
    not?: NestedEnumTypeAbsenceWithAggregatesFilter<$PrismaModel> | $Enums.TypeAbsence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeAbsenceFilter<$PrismaModel>
    _max?: NestedEnumTypeAbsenceFilter<$PrismaModel>
  }

  export type EnumStatutAbsenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAbsence | EnumStatutAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAbsence[]
    notIn?: $Enums.StatutAbsence[]
    not?: NestedEnumStatutAbsenceWithAggregatesFilter<$PrismaModel> | $Enums.StatutAbsence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAbsenceFilter<$PrismaModel>
    _max?: NestedEnumStatutAbsenceFilter<$PrismaModel>
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type JournalAuditCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<JournalAuditCreateWithoutUtilisateurInput, JournalAuditUncheckedCreateWithoutUtilisateurInput> | JournalAuditCreateWithoutUtilisateurInput[] | JournalAuditUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: JournalAuditCreateOrConnectWithoutUtilisateurInput | JournalAuditCreateOrConnectWithoutUtilisateurInput[]
    createMany?: JournalAuditCreateManyUtilisateurInputEnvelope
    connect?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCashierInput = {
    create?: XOR<PaymentCreateWithoutCashierInput, PaymentUncheckedCreateWithoutCashierInput> | PaymentCreateWithoutCashierInput[] | PaymentUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashierInput | PaymentCreateOrConnectWithoutCashierInput[]
    createMany?: PaymentCreateManyCashierInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CompanyFactureCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CompanyFactureCreateWithoutCreatorInput, CompanyFactureUncheckedCreateWithoutCreatorInput> | CompanyFactureCreateWithoutCreatorInput[] | CompanyFactureUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutCreatorInput | CompanyFactureCreateOrConnectWithoutCreatorInput[]
    createMany?: CompanyFactureCreateManyCreatorInputEnvelope
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
  }

  export type CompanyPayRunCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CompanyPayRunCreateWithoutCreatorInput, CompanyPayRunUncheckedCreateWithoutCreatorInput> | CompanyPayRunCreateWithoutCreatorInput[] | CompanyPayRunUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutCreatorInput | CompanyPayRunCreateOrConnectWithoutCreatorInput[]
    createMany?: CompanyPayRunCreateManyCreatorInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type CompanyPayRunCreateNestedManyWithoutApproverInput = {
    create?: XOR<CompanyPayRunCreateWithoutApproverInput, CompanyPayRunUncheckedCreateWithoutApproverInput> | CompanyPayRunCreateWithoutApproverInput[] | CompanyPayRunUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutApproverInput | CompanyPayRunCreateOrConnectWithoutApproverInput[]
    createMany?: CompanyPayRunCreateManyApproverInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type CompanyPaiementCreateNestedManyWithoutProcessorInput = {
    create?: XOR<CompanyPaiementCreateWithoutProcessorInput, CompanyPaiementUncheckedCreateWithoutProcessorInput> | CompanyPaiementCreateWithoutProcessorInput[] | CompanyPaiementUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutProcessorInput | CompanyPaiementCreateOrConnectWithoutProcessorInput[]
    createMany?: CompanyPaiementCreateManyProcessorInputEnvelope
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
  }

  export type CompanyDocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyModeleDocumentCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutCreatorInput, CompanyModeleDocumentUncheckedCreateWithoutCreatorInput> | CompanyModeleDocumentCreateWithoutCreatorInput[] | CompanyModeleDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutCreatorInput | CompanyModeleDocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: CompanyModeleDocumentCreateManyCreatorInputEnvelope
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
  }

  export type CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput> | CompanyHistoriqueSalaireCreateWithoutModifierInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput | CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyModifierInputEnvelope
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
  }

  export type PointageCreateNestedManyWithoutValidateurInput = {
    create?: XOR<PointageCreateWithoutValidateurInput, PointageUncheckedCreateWithoutValidateurInput> | PointageCreateWithoutValidateurInput[] | PointageUncheckedCreateWithoutValidateurInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutValidateurInput | PointageCreateOrConnectWithoutValidateurInput[]
    createMany?: PointageCreateManyValidateurInputEnvelope
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
  }

  export type AbsenceCreateNestedManyWithoutApprobateurInput = {
    create?: XOR<AbsenceCreateWithoutApprobateurInput, AbsenceUncheckedCreateWithoutApprobateurInput> | AbsenceCreateWithoutApprobateurInput[] | AbsenceUncheckedCreateWithoutApprobateurInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutApprobateurInput | AbsenceCreateOrConnectWithoutApprobateurInput[]
    createMany?: AbsenceCreateManyApprobateurInputEnvelope
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<JournalAuditCreateWithoutUtilisateurInput, JournalAuditUncheckedCreateWithoutUtilisateurInput> | JournalAuditCreateWithoutUtilisateurInput[] | JournalAuditUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: JournalAuditCreateOrConnectWithoutUtilisateurInput | JournalAuditCreateOrConnectWithoutUtilisateurInput[]
    createMany?: JournalAuditCreateManyUtilisateurInputEnvelope
    connect?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCashierInput = {
    create?: XOR<PaymentCreateWithoutCashierInput, PaymentUncheckedCreateWithoutCashierInput> | PaymentCreateWithoutCashierInput[] | PaymentUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashierInput | PaymentCreateOrConnectWithoutCashierInput[]
    createMany?: PaymentCreateManyCashierInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CompanyFactureCreateWithoutCreatorInput, CompanyFactureUncheckedCreateWithoutCreatorInput> | CompanyFactureCreateWithoutCreatorInput[] | CompanyFactureUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutCreatorInput | CompanyFactureCreateOrConnectWithoutCreatorInput[]
    createMany?: CompanyFactureCreateManyCreatorInputEnvelope
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
  }

  export type CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CompanyPayRunCreateWithoutCreatorInput, CompanyPayRunUncheckedCreateWithoutCreatorInput> | CompanyPayRunCreateWithoutCreatorInput[] | CompanyPayRunUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutCreatorInput | CompanyPayRunCreateOrConnectWithoutCreatorInput[]
    createMany?: CompanyPayRunCreateManyCreatorInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<CompanyPayRunCreateWithoutApproverInput, CompanyPayRunUncheckedCreateWithoutApproverInput> | CompanyPayRunCreateWithoutApproverInput[] | CompanyPayRunUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutApproverInput | CompanyPayRunCreateOrConnectWithoutApproverInput[]
    createMany?: CompanyPayRunCreateManyApproverInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput = {
    create?: XOR<CompanyPaiementCreateWithoutProcessorInput, CompanyPaiementUncheckedCreateWithoutProcessorInput> | CompanyPaiementCreateWithoutProcessorInput[] | CompanyPaiementUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutProcessorInput | CompanyPaiementCreateOrConnectWithoutProcessorInput[]
    createMany?: CompanyPaiementCreateManyProcessorInputEnvelope
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
  }

  export type CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutCreatorInput, CompanyModeleDocumentUncheckedCreateWithoutCreatorInput> | CompanyModeleDocumentCreateWithoutCreatorInput[] | CompanyModeleDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutCreatorInput | CompanyModeleDocumentCreateOrConnectWithoutCreatorInput[]
    createMany?: CompanyModeleDocumentCreateManyCreatorInputEnvelope
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
  }

  export type CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput> | CompanyHistoriqueSalaireCreateWithoutModifierInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput | CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyModifierInputEnvelope
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
  }

  export type PointageUncheckedCreateNestedManyWithoutValidateurInput = {
    create?: XOR<PointageCreateWithoutValidateurInput, PointageUncheckedCreateWithoutValidateurInput> | PointageCreateWithoutValidateurInput[] | PointageUncheckedCreateWithoutValidateurInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutValidateurInput | PointageCreateOrConnectWithoutValidateurInput[]
    createMany?: PointageCreateManyValidateurInputEnvelope
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
  }

  export type AbsenceUncheckedCreateNestedManyWithoutApprobateurInput = {
    create?: XOR<AbsenceCreateWithoutApprobateurInput, AbsenceUncheckedCreateWithoutApprobateurInput> | AbsenceCreateWithoutApprobateurInput[] | AbsenceUncheckedCreateWithoutApprobateurInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutApprobateurInput | AbsenceCreateOrConnectWithoutApprobateurInput[]
    createMany?: AbsenceCreateManyApprobateurInputEnvelope
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type JournalAuditUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<JournalAuditCreateWithoutUtilisateurInput, JournalAuditUncheckedCreateWithoutUtilisateurInput> | JournalAuditCreateWithoutUtilisateurInput[] | JournalAuditUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: JournalAuditCreateOrConnectWithoutUtilisateurInput | JournalAuditCreateOrConnectWithoutUtilisateurInput[]
    upsert?: JournalAuditUpsertWithWhereUniqueWithoutUtilisateurInput | JournalAuditUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: JournalAuditCreateManyUtilisateurInputEnvelope
    set?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    disconnect?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    delete?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    connect?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    update?: JournalAuditUpdateWithWhereUniqueWithoutUtilisateurInput | JournalAuditUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: JournalAuditUpdateManyWithWhereWithoutUtilisateurInput | JournalAuditUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: JournalAuditScalarWhereInput | JournalAuditScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCashierNestedInput = {
    create?: XOR<PaymentCreateWithoutCashierInput, PaymentUncheckedCreateWithoutCashierInput> | PaymentCreateWithoutCashierInput[] | PaymentUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashierInput | PaymentCreateOrConnectWithoutCashierInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCashierInput | PaymentUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: PaymentCreateManyCashierInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCashierInput | PaymentUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCashierInput | PaymentUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CompanyFactureUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CompanyFactureCreateWithoutCreatorInput, CompanyFactureUncheckedCreateWithoutCreatorInput> | CompanyFactureCreateWithoutCreatorInput[] | CompanyFactureUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutCreatorInput | CompanyFactureCreateOrConnectWithoutCreatorInput[]
    upsert?: CompanyFactureUpsertWithWhereUniqueWithoutCreatorInput | CompanyFactureUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CompanyFactureCreateManyCreatorInputEnvelope
    set?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    disconnect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    delete?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    update?: CompanyFactureUpdateWithWhereUniqueWithoutCreatorInput | CompanyFactureUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CompanyFactureUpdateManyWithWhereWithoutCreatorInput | CompanyFactureUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CompanyFactureScalarWhereInput | CompanyFactureScalarWhereInput[]
  }

  export type CompanyPayRunUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutCreatorInput, CompanyPayRunUncheckedCreateWithoutCreatorInput> | CompanyPayRunCreateWithoutCreatorInput[] | CompanyPayRunUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutCreatorInput | CompanyPayRunCreateOrConnectWithoutCreatorInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutCreatorInput | CompanyPayRunUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CompanyPayRunCreateManyCreatorInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutCreatorInput | CompanyPayRunUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutCreatorInput | CompanyPayRunUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type CompanyPayRunUpdateManyWithoutApproverNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutApproverInput, CompanyPayRunUncheckedCreateWithoutApproverInput> | CompanyPayRunCreateWithoutApproverInput[] | CompanyPayRunUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutApproverInput | CompanyPayRunCreateOrConnectWithoutApproverInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutApproverInput | CompanyPayRunUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: CompanyPayRunCreateManyApproverInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutApproverInput | CompanyPayRunUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutApproverInput | CompanyPayRunUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type CompanyPaiementUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<CompanyPaiementCreateWithoutProcessorInput, CompanyPaiementUncheckedCreateWithoutProcessorInput> | CompanyPaiementCreateWithoutProcessorInput[] | CompanyPaiementUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutProcessorInput | CompanyPaiementCreateOrConnectWithoutProcessorInput[]
    upsert?: CompanyPaiementUpsertWithWhereUniqueWithoutProcessorInput | CompanyPaiementUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: CompanyPaiementCreateManyProcessorInputEnvelope
    set?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    disconnect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    delete?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    update?: CompanyPaiementUpdateWithWhereUniqueWithoutProcessorInput | CompanyPaiementUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: CompanyPaiementUpdateManyWithWhereWithoutProcessorInput | CompanyPaiementUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: CompanyPaiementScalarWhereInput | CompanyPaiementScalarWhereInput[]
  }

  export type CompanyDocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutUploaderInput | CompanyDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutCreatorInput, CompanyModeleDocumentUncheckedCreateWithoutCreatorInput> | CompanyModeleDocumentCreateWithoutCreatorInput[] | CompanyModeleDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutCreatorInput | CompanyModeleDocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: CompanyModeleDocumentUpsertWithWhereUniqueWithoutCreatorInput | CompanyModeleDocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CompanyModeleDocumentCreateManyCreatorInputEnvelope
    set?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    disconnect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    delete?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    update?: CompanyModeleDocumentUpdateWithWhereUniqueWithoutCreatorInput | CompanyModeleDocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CompanyModeleDocumentUpdateManyWithWhereWithoutCreatorInput | CompanyModeleDocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CompanyModeleDocumentScalarWhereInput | CompanyModeleDocumentScalarWhereInput[]
  }

  export type CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput> | CompanyHistoriqueSalaireCreateWithoutModifierInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput | CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput[]
    upsert?: CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutModifierInput | CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutModifierInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyModifierInputEnvelope
    set?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    disconnect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    delete?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    update?: CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutModifierInput | CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutModifierInput[]
    updateMany?: CompanyHistoriqueSalaireUpdateManyWithWhereWithoutModifierInput | CompanyHistoriqueSalaireUpdateManyWithWhereWithoutModifierInput[]
    deleteMany?: CompanyHistoriqueSalaireScalarWhereInput | CompanyHistoriqueSalaireScalarWhereInput[]
  }

  export type PointageUpdateManyWithoutValidateurNestedInput = {
    create?: XOR<PointageCreateWithoutValidateurInput, PointageUncheckedCreateWithoutValidateurInput> | PointageCreateWithoutValidateurInput[] | PointageUncheckedCreateWithoutValidateurInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutValidateurInput | PointageCreateOrConnectWithoutValidateurInput[]
    upsert?: PointageUpsertWithWhereUniqueWithoutValidateurInput | PointageUpsertWithWhereUniqueWithoutValidateurInput[]
    createMany?: PointageCreateManyValidateurInputEnvelope
    set?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    disconnect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    delete?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    update?: PointageUpdateWithWhereUniqueWithoutValidateurInput | PointageUpdateWithWhereUniqueWithoutValidateurInput[]
    updateMany?: PointageUpdateManyWithWhereWithoutValidateurInput | PointageUpdateManyWithWhereWithoutValidateurInput[]
    deleteMany?: PointageScalarWhereInput | PointageScalarWhereInput[]
  }

  export type AbsenceUpdateManyWithoutApprobateurNestedInput = {
    create?: XOR<AbsenceCreateWithoutApprobateurInput, AbsenceUncheckedCreateWithoutApprobateurInput> | AbsenceCreateWithoutApprobateurInput[] | AbsenceUncheckedCreateWithoutApprobateurInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutApprobateurInput | AbsenceCreateOrConnectWithoutApprobateurInput[]
    upsert?: AbsenceUpsertWithWhereUniqueWithoutApprobateurInput | AbsenceUpsertWithWhereUniqueWithoutApprobateurInput[]
    createMany?: AbsenceCreateManyApprobateurInputEnvelope
    set?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    disconnect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    delete?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    update?: AbsenceUpdateWithWhereUniqueWithoutApprobateurInput | AbsenceUpdateWithWhereUniqueWithoutApprobateurInput[]
    updateMany?: AbsenceUpdateManyWithWhereWithoutApprobateurInput | AbsenceUpdateManyWithWhereWithoutApprobateurInput[]
    deleteMany?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<JournalAuditCreateWithoutUtilisateurInput, JournalAuditUncheckedCreateWithoutUtilisateurInput> | JournalAuditCreateWithoutUtilisateurInput[] | JournalAuditUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: JournalAuditCreateOrConnectWithoutUtilisateurInput | JournalAuditCreateOrConnectWithoutUtilisateurInput[]
    upsert?: JournalAuditUpsertWithWhereUniqueWithoutUtilisateurInput | JournalAuditUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: JournalAuditCreateManyUtilisateurInputEnvelope
    set?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    disconnect?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    delete?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    connect?: JournalAuditWhereUniqueInput | JournalAuditWhereUniqueInput[]
    update?: JournalAuditUpdateWithWhereUniqueWithoutUtilisateurInput | JournalAuditUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: JournalAuditUpdateManyWithWhereWithoutUtilisateurInput | JournalAuditUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: JournalAuditScalarWhereInput | JournalAuditScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCashierNestedInput = {
    create?: XOR<PaymentCreateWithoutCashierInput, PaymentUncheckedCreateWithoutCashierInput> | PaymentCreateWithoutCashierInput[] | PaymentUncheckedCreateWithoutCashierInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashierInput | PaymentCreateOrConnectWithoutCashierInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCashierInput | PaymentUpsertWithWhereUniqueWithoutCashierInput[]
    createMany?: PaymentCreateManyCashierInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCashierInput | PaymentUpdateWithWhereUniqueWithoutCashierInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCashierInput | PaymentUpdateManyWithWhereWithoutCashierInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CompanyFactureCreateWithoutCreatorInput, CompanyFactureUncheckedCreateWithoutCreatorInput> | CompanyFactureCreateWithoutCreatorInput[] | CompanyFactureUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutCreatorInput | CompanyFactureCreateOrConnectWithoutCreatorInput[]
    upsert?: CompanyFactureUpsertWithWhereUniqueWithoutCreatorInput | CompanyFactureUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CompanyFactureCreateManyCreatorInputEnvelope
    set?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    disconnect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    delete?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    update?: CompanyFactureUpdateWithWhereUniqueWithoutCreatorInput | CompanyFactureUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CompanyFactureUpdateManyWithWhereWithoutCreatorInput | CompanyFactureUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CompanyFactureScalarWhereInput | CompanyFactureScalarWhereInput[]
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutCreatorInput, CompanyPayRunUncheckedCreateWithoutCreatorInput> | CompanyPayRunCreateWithoutCreatorInput[] | CompanyPayRunUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutCreatorInput | CompanyPayRunCreateOrConnectWithoutCreatorInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutCreatorInput | CompanyPayRunUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CompanyPayRunCreateManyCreatorInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutCreatorInput | CompanyPayRunUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutCreatorInput | CompanyPayRunUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutApproverInput, CompanyPayRunUncheckedCreateWithoutApproverInput> | CompanyPayRunCreateWithoutApproverInput[] | CompanyPayRunUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutApproverInput | CompanyPayRunCreateOrConnectWithoutApproverInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutApproverInput | CompanyPayRunUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: CompanyPayRunCreateManyApproverInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutApproverInput | CompanyPayRunUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutApproverInput | CompanyPayRunUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<CompanyPaiementCreateWithoutProcessorInput, CompanyPaiementUncheckedCreateWithoutProcessorInput> | CompanyPaiementCreateWithoutProcessorInput[] | CompanyPaiementUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutProcessorInput | CompanyPaiementCreateOrConnectWithoutProcessorInput[]
    upsert?: CompanyPaiementUpsertWithWhereUniqueWithoutProcessorInput | CompanyPaiementUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: CompanyPaiementCreateManyProcessorInputEnvelope
    set?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    disconnect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    delete?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    update?: CompanyPaiementUpdateWithWhereUniqueWithoutProcessorInput | CompanyPaiementUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: CompanyPaiementUpdateManyWithWhereWithoutProcessorInput | CompanyPaiementUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: CompanyPaiementScalarWhereInput | CompanyPaiementScalarWhereInput[]
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput> | CompanyDocumentCreateWithoutUploaderInput[] | CompanyDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutUploaderInput | CompanyDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CompanyDocumentCreateManyUploaderInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput | CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutUploaderInput | CompanyDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutCreatorInput, CompanyModeleDocumentUncheckedCreateWithoutCreatorInput> | CompanyModeleDocumentCreateWithoutCreatorInput[] | CompanyModeleDocumentUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutCreatorInput | CompanyModeleDocumentCreateOrConnectWithoutCreatorInput[]
    upsert?: CompanyModeleDocumentUpsertWithWhereUniqueWithoutCreatorInput | CompanyModeleDocumentUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CompanyModeleDocumentCreateManyCreatorInputEnvelope
    set?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    disconnect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    delete?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    update?: CompanyModeleDocumentUpdateWithWhereUniqueWithoutCreatorInput | CompanyModeleDocumentUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CompanyModeleDocumentUpdateManyWithWhereWithoutCreatorInput | CompanyModeleDocumentUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CompanyModeleDocumentScalarWhereInput | CompanyModeleDocumentScalarWhereInput[]
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput> | CompanyHistoriqueSalaireCreateWithoutModifierInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput | CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput[]
    upsert?: CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutModifierInput | CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutModifierInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyModifierInputEnvelope
    set?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    disconnect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    delete?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    update?: CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutModifierInput | CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutModifierInput[]
    updateMany?: CompanyHistoriqueSalaireUpdateManyWithWhereWithoutModifierInput | CompanyHistoriqueSalaireUpdateManyWithWhereWithoutModifierInput[]
    deleteMany?: CompanyHistoriqueSalaireScalarWhereInput | CompanyHistoriqueSalaireScalarWhereInput[]
  }

  export type PointageUncheckedUpdateManyWithoutValidateurNestedInput = {
    create?: XOR<PointageCreateWithoutValidateurInput, PointageUncheckedCreateWithoutValidateurInput> | PointageCreateWithoutValidateurInput[] | PointageUncheckedCreateWithoutValidateurInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutValidateurInput | PointageCreateOrConnectWithoutValidateurInput[]
    upsert?: PointageUpsertWithWhereUniqueWithoutValidateurInput | PointageUpsertWithWhereUniqueWithoutValidateurInput[]
    createMany?: PointageCreateManyValidateurInputEnvelope
    set?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    disconnect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    delete?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    update?: PointageUpdateWithWhereUniqueWithoutValidateurInput | PointageUpdateWithWhereUniqueWithoutValidateurInput[]
    updateMany?: PointageUpdateManyWithWhereWithoutValidateurInput | PointageUpdateManyWithWhereWithoutValidateurInput[]
    deleteMany?: PointageScalarWhereInput | PointageScalarWhereInput[]
  }

  export type AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput = {
    create?: XOR<AbsenceCreateWithoutApprobateurInput, AbsenceUncheckedCreateWithoutApprobateurInput> | AbsenceCreateWithoutApprobateurInput[] | AbsenceUncheckedCreateWithoutApprobateurInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutApprobateurInput | AbsenceCreateOrConnectWithoutApprobateurInput[]
    upsert?: AbsenceUpsertWithWhereUniqueWithoutApprobateurInput | AbsenceUpsertWithWhereUniqueWithoutApprobateurInput[]
    createMany?: AbsenceCreateManyApprobateurInputEnvelope
    set?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    disconnect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    delete?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    update?: AbsenceUpdateWithWhereUniqueWithoutApprobateurInput | AbsenceUpdateWithWhereUniqueWithoutApprobateurInput[]
    updateMany?: AbsenceUpdateManyWithWhereWithoutApprobateurInput | AbsenceUpdateManyWithWhereWithoutApprobateurInput[]
    deleteMany?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type EntrepriseCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<EntrepriseCreateWithoutEmployeesInput, EntrepriseUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutEmployeesInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PaymentCreateWithoutEmployeeInput, PaymentUncheckedCreateWithoutEmployeeInput> | PaymentCreateWithoutEmployeeInput[] | PaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutEmployeeInput | PaymentCreateOrConnectWithoutEmployeeInput[]
    createMany?: PaymentCreateManyEmployeeInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CompanyFactureCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyFactureCreateWithoutEmployeeInput, CompanyFactureUncheckedCreateWithoutEmployeeInput> | CompanyFactureCreateWithoutEmployeeInput[] | CompanyFactureUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutEmployeeInput | CompanyFactureCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyFactureCreateManyEmployeeInputEnvelope
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
  }

  export type CompanyBulletinCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyBulletinCreateWithoutEmployeeInput, CompanyBulletinUncheckedCreateWithoutEmployeeInput> | CompanyBulletinCreateWithoutEmployeeInput[] | CompanyBulletinUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutEmployeeInput | CompanyBulletinCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyBulletinCreateManyEmployeeInputEnvelope
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
  }

  export type CompanyDocumentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyDocumentCreateWithoutEmployeeInput, CompanyDocumentUncheckedCreateWithoutEmployeeInput> | CompanyDocumentCreateWithoutEmployeeInput[] | CompanyDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutEmployeeInput | CompanyDocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyDocumentCreateManyEmployeeInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput> | CompanyHistoriqueSalaireCreateWithoutEmployeeInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput | CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyEmployeeInputEnvelope
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
  }

  export type PointageCreateNestedManyWithoutEmployeInput = {
    create?: XOR<PointageCreateWithoutEmployeInput, PointageUncheckedCreateWithoutEmployeInput> | PointageCreateWithoutEmployeInput[] | PointageUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutEmployeInput | PointageCreateOrConnectWithoutEmployeInput[]
    createMany?: PointageCreateManyEmployeInputEnvelope
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
  }

  export type AbsenceCreateNestedManyWithoutEmployeInput = {
    create?: XOR<AbsenceCreateWithoutEmployeInput, AbsenceUncheckedCreateWithoutEmployeInput> | AbsenceCreateWithoutEmployeInput[] | AbsenceUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeInput | AbsenceCreateOrConnectWithoutEmployeInput[]
    createMany?: AbsenceCreateManyEmployeInputEnvelope
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PaymentCreateWithoutEmployeeInput, PaymentUncheckedCreateWithoutEmployeeInput> | PaymentCreateWithoutEmployeeInput[] | PaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutEmployeeInput | PaymentCreateOrConnectWithoutEmployeeInput[]
    createMany?: PaymentCreateManyEmployeeInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyFactureCreateWithoutEmployeeInput, CompanyFactureUncheckedCreateWithoutEmployeeInput> | CompanyFactureCreateWithoutEmployeeInput[] | CompanyFactureUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutEmployeeInput | CompanyFactureCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyFactureCreateManyEmployeeInputEnvelope
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
  }

  export type CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyBulletinCreateWithoutEmployeeInput, CompanyBulletinUncheckedCreateWithoutEmployeeInput> | CompanyBulletinCreateWithoutEmployeeInput[] | CompanyBulletinUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutEmployeeInput | CompanyBulletinCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyBulletinCreateManyEmployeeInputEnvelope
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
  }

  export type CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyDocumentCreateWithoutEmployeeInput, CompanyDocumentUncheckedCreateWithoutEmployeeInput> | CompanyDocumentCreateWithoutEmployeeInput[] | CompanyDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutEmployeeInput | CompanyDocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyDocumentCreateManyEmployeeInputEnvelope
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
  }

  export type CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput> | CompanyHistoriqueSalaireCreateWithoutEmployeeInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput | CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyEmployeeInputEnvelope
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
  }

  export type PointageUncheckedCreateNestedManyWithoutEmployeInput = {
    create?: XOR<PointageCreateWithoutEmployeInput, PointageUncheckedCreateWithoutEmployeInput> | PointageCreateWithoutEmployeInput[] | PointageUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutEmployeInput | PointageCreateOrConnectWithoutEmployeInput[]
    createMany?: PointageCreateManyEmployeInputEnvelope
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
  }

  export type AbsenceUncheckedCreateNestedManyWithoutEmployeInput = {
    create?: XOR<AbsenceCreateWithoutEmployeInput, AbsenceUncheckedCreateWithoutEmployeInput> | AbsenceCreateWithoutEmployeInput[] | AbsenceUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeInput | AbsenceCreateOrConnectWithoutEmployeInput[]
    createMany?: AbsenceCreateManyEmployeInputEnvelope
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
  }

  export type EnumContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContractType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumEmployeeStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeStatus
  }

  export type UserUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<EntrepriseCreateWithoutEmployeesInput, EntrepriseUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutEmployeesInput
    upsert?: EntrepriseUpsertWithoutEmployeesInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutEmployeesInput, EntrepriseUpdateWithoutEmployeesInput>, EntrepriseUncheckedUpdateWithoutEmployeesInput>
  }

  export type PaymentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PaymentCreateWithoutEmployeeInput, PaymentUncheckedCreateWithoutEmployeeInput> | PaymentCreateWithoutEmployeeInput[] | PaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutEmployeeInput | PaymentCreateOrConnectWithoutEmployeeInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutEmployeeInput | PaymentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PaymentCreateManyEmployeeInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutEmployeeInput | PaymentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutEmployeeInput | PaymentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CompanyFactureUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyFactureCreateWithoutEmployeeInput, CompanyFactureUncheckedCreateWithoutEmployeeInput> | CompanyFactureCreateWithoutEmployeeInput[] | CompanyFactureUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutEmployeeInput | CompanyFactureCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyFactureUpsertWithWhereUniqueWithoutEmployeeInput | CompanyFactureUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyFactureCreateManyEmployeeInputEnvelope
    set?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    disconnect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    delete?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    update?: CompanyFactureUpdateWithWhereUniqueWithoutEmployeeInput | CompanyFactureUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyFactureUpdateManyWithWhereWithoutEmployeeInput | CompanyFactureUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyFactureScalarWhereInput | CompanyFactureScalarWhereInput[]
  }

  export type CompanyBulletinUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyBulletinCreateWithoutEmployeeInput, CompanyBulletinUncheckedCreateWithoutEmployeeInput> | CompanyBulletinCreateWithoutEmployeeInput[] | CompanyBulletinUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutEmployeeInput | CompanyBulletinCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyBulletinUpsertWithWhereUniqueWithoutEmployeeInput | CompanyBulletinUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyBulletinCreateManyEmployeeInputEnvelope
    set?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    disconnect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    delete?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    update?: CompanyBulletinUpdateWithWhereUniqueWithoutEmployeeInput | CompanyBulletinUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyBulletinUpdateManyWithWhereWithoutEmployeeInput | CompanyBulletinUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyBulletinScalarWhereInput | CompanyBulletinScalarWhereInput[]
  }

  export type CompanyDocumentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutEmployeeInput, CompanyDocumentUncheckedCreateWithoutEmployeeInput> | CompanyDocumentCreateWithoutEmployeeInput[] | CompanyDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutEmployeeInput | CompanyDocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutEmployeeInput | CompanyDocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyDocumentCreateManyEmployeeInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutEmployeeInput | CompanyDocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutEmployeeInput | CompanyDocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput> | CompanyHistoriqueSalaireCreateWithoutEmployeeInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput | CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutEmployeeInput | CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyEmployeeInputEnvelope
    set?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    disconnect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    delete?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    update?: CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutEmployeeInput | CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyHistoriqueSalaireUpdateManyWithWhereWithoutEmployeeInput | CompanyHistoriqueSalaireUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyHistoriqueSalaireScalarWhereInput | CompanyHistoriqueSalaireScalarWhereInput[]
  }

  export type PointageUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<PointageCreateWithoutEmployeInput, PointageUncheckedCreateWithoutEmployeInput> | PointageCreateWithoutEmployeInput[] | PointageUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutEmployeInput | PointageCreateOrConnectWithoutEmployeInput[]
    upsert?: PointageUpsertWithWhereUniqueWithoutEmployeInput | PointageUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: PointageCreateManyEmployeInputEnvelope
    set?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    disconnect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    delete?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    update?: PointageUpdateWithWhereUniqueWithoutEmployeInput | PointageUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: PointageUpdateManyWithWhereWithoutEmployeInput | PointageUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: PointageScalarWhereInput | PointageScalarWhereInput[]
  }

  export type AbsenceUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<AbsenceCreateWithoutEmployeInput, AbsenceUncheckedCreateWithoutEmployeInput> | AbsenceCreateWithoutEmployeInput[] | AbsenceUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeInput | AbsenceCreateOrConnectWithoutEmployeInput[]
    upsert?: AbsenceUpsertWithWhereUniqueWithoutEmployeInput | AbsenceUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: AbsenceCreateManyEmployeInputEnvelope
    set?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    disconnect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    delete?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    update?: AbsenceUpdateWithWhereUniqueWithoutEmployeInput | AbsenceUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: AbsenceUpdateManyWithWhereWithoutEmployeInput | AbsenceUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PaymentCreateWithoutEmployeeInput, PaymentUncheckedCreateWithoutEmployeeInput> | PaymentCreateWithoutEmployeeInput[] | PaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutEmployeeInput | PaymentCreateOrConnectWithoutEmployeeInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutEmployeeInput | PaymentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PaymentCreateManyEmployeeInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutEmployeeInput | PaymentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutEmployeeInput | PaymentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyFactureCreateWithoutEmployeeInput, CompanyFactureUncheckedCreateWithoutEmployeeInput> | CompanyFactureCreateWithoutEmployeeInput[] | CompanyFactureUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutEmployeeInput | CompanyFactureCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyFactureUpsertWithWhereUniqueWithoutEmployeeInput | CompanyFactureUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyFactureCreateManyEmployeeInputEnvelope
    set?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    disconnect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    delete?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    connect?: CompanyFactureWhereUniqueInput | CompanyFactureWhereUniqueInput[]
    update?: CompanyFactureUpdateWithWhereUniqueWithoutEmployeeInput | CompanyFactureUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyFactureUpdateManyWithWhereWithoutEmployeeInput | CompanyFactureUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyFactureScalarWhereInput | CompanyFactureScalarWhereInput[]
  }

  export type CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyBulletinCreateWithoutEmployeeInput, CompanyBulletinUncheckedCreateWithoutEmployeeInput> | CompanyBulletinCreateWithoutEmployeeInput[] | CompanyBulletinUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutEmployeeInput | CompanyBulletinCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyBulletinUpsertWithWhereUniqueWithoutEmployeeInput | CompanyBulletinUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyBulletinCreateManyEmployeeInputEnvelope
    set?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    disconnect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    delete?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    update?: CompanyBulletinUpdateWithWhereUniqueWithoutEmployeeInput | CompanyBulletinUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyBulletinUpdateManyWithWhereWithoutEmployeeInput | CompanyBulletinUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyBulletinScalarWhereInput | CompanyBulletinScalarWhereInput[]
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyDocumentCreateWithoutEmployeeInput, CompanyDocumentUncheckedCreateWithoutEmployeeInput> | CompanyDocumentCreateWithoutEmployeeInput[] | CompanyDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyDocumentCreateOrConnectWithoutEmployeeInput | CompanyDocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyDocumentUpsertWithWhereUniqueWithoutEmployeeInput | CompanyDocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyDocumentCreateManyEmployeeInputEnvelope
    set?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    disconnect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    delete?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    connect?: CompanyDocumentWhereUniqueInput | CompanyDocumentWhereUniqueInput[]
    update?: CompanyDocumentUpdateWithWhereUniqueWithoutEmployeeInput | CompanyDocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyDocumentUpdateManyWithWhereWithoutEmployeeInput | CompanyDocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<CompanyHistoriqueSalaireCreateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput> | CompanyHistoriqueSalaireCreateWithoutEmployeeInput[] | CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput | CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput[]
    upsert?: CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutEmployeeInput | CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: CompanyHistoriqueSalaireCreateManyEmployeeInputEnvelope
    set?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    disconnect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    delete?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    connect?: CompanyHistoriqueSalaireWhereUniqueInput | CompanyHistoriqueSalaireWhereUniqueInput[]
    update?: CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutEmployeeInput | CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: CompanyHistoriqueSalaireUpdateManyWithWhereWithoutEmployeeInput | CompanyHistoriqueSalaireUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: CompanyHistoriqueSalaireScalarWhereInput | CompanyHistoriqueSalaireScalarWhereInput[]
  }

  export type PointageUncheckedUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<PointageCreateWithoutEmployeInput, PointageUncheckedCreateWithoutEmployeInput> | PointageCreateWithoutEmployeInput[] | PointageUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PointageCreateOrConnectWithoutEmployeInput | PointageCreateOrConnectWithoutEmployeInput[]
    upsert?: PointageUpsertWithWhereUniqueWithoutEmployeInput | PointageUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: PointageCreateManyEmployeInputEnvelope
    set?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    disconnect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    delete?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    connect?: PointageWhereUniqueInput | PointageWhereUniqueInput[]
    update?: PointageUpdateWithWhereUniqueWithoutEmployeInput | PointageUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: PointageUpdateManyWithWhereWithoutEmployeInput | PointageUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: PointageScalarWhereInput | PointageScalarWhereInput[]
  }

  export type AbsenceUncheckedUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<AbsenceCreateWithoutEmployeInput, AbsenceUncheckedCreateWithoutEmployeInput> | AbsenceCreateWithoutEmployeInput[] | AbsenceUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: AbsenceCreateOrConnectWithoutEmployeInput | AbsenceCreateOrConnectWithoutEmployeInput[]
    upsert?: AbsenceUpsertWithWhereUniqueWithoutEmployeInput | AbsenceUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: AbsenceCreateManyEmployeInputEnvelope
    set?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    disconnect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    delete?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    connect?: AbsenceWhereUniqueInput | AbsenceWhereUniqueInput[]
    update?: AbsenceUpdateWithWhereUniqueWithoutEmployeInput | AbsenceUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: AbsenceUpdateManyWithWhereWithoutEmployeInput | AbsenceUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<EmployeeCreateWithoutEntrepriseInput, EmployeeUncheckedCreateWithoutEntrepriseInput> | EmployeeCreateWithoutEntrepriseInput[] | EmployeeUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEntrepriseInput | EmployeeCreateOrConnectWithoutEntrepriseInput[]
    createMany?: EmployeeCreateManyEntrepriseInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type CompanyPayRunCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyPayRunCreateWithoutEntrepriseInput, CompanyPayRunUncheckedCreateWithoutEntrepriseInput> | CompanyPayRunCreateWithoutEntrepriseInput[] | CompanyPayRunUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutEntrepriseInput | CompanyPayRunCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyPayRunCreateManyEntrepriseInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type CompanyTemplateCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyTemplateCreateWithoutEntrepriseInput, CompanyTemplateUncheckedCreateWithoutEntrepriseInput> | CompanyTemplateCreateWithoutEntrepriseInput[] | CompanyTemplateUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyTemplateCreateOrConnectWithoutEntrepriseInput | CompanyTemplateCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyTemplateCreateManyEntrepriseInputEnvelope
    connect?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
  }

  export type CompanySettingCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanySettingCreateWithoutEntrepriseInput, CompanySettingUncheckedCreateWithoutEntrepriseInput> | CompanySettingCreateWithoutEntrepriseInput[] | CompanySettingUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanySettingCreateOrConnectWithoutEntrepriseInput | CompanySettingCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanySettingCreateManyEntrepriseInputEnvelope
    connect?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
  }

  export type CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput> | CompanyModeleDocumentCreateWithoutEntrepriseInput[] | CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput | CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyModeleDocumentCreateManyEntrepriseInputEnvelope
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
  }

  export type CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyPeriodePaieCreateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput> | CompanyPeriodePaieCreateWithoutEntrepriseInput[] | CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput | CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyPeriodePaieCreateManyEntrepriseInputEnvelope
    connect?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
  }

  export type CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyConfigurationPaieCreateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput> | CompanyConfigurationPaieCreateWithoutEntrepriseInput[] | CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput | CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyConfigurationPaieCreateManyEntrepriseInputEnvelope
    connect?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
  }

  export type ReglePointageCreateNestedOneWithoutEntrepriseInput = {
    create?: XOR<ReglePointageCreateWithoutEntrepriseInput, ReglePointageUncheckedCreateWithoutEntrepriseInput>
    connectOrCreate?: ReglePointageCreateOrConnectWithoutEntrepriseInput
    connect?: ReglePointageWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<EmployeeCreateWithoutEntrepriseInput, EmployeeUncheckedCreateWithoutEntrepriseInput> | EmployeeCreateWithoutEntrepriseInput[] | EmployeeUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEntrepriseInput | EmployeeCreateOrConnectWithoutEntrepriseInput[]
    createMany?: EmployeeCreateManyEntrepriseInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyPayRunCreateWithoutEntrepriseInput, CompanyPayRunUncheckedCreateWithoutEntrepriseInput> | CompanyPayRunCreateWithoutEntrepriseInput[] | CompanyPayRunUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutEntrepriseInput | CompanyPayRunCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyPayRunCreateManyEntrepriseInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyTemplateCreateWithoutEntrepriseInput, CompanyTemplateUncheckedCreateWithoutEntrepriseInput> | CompanyTemplateCreateWithoutEntrepriseInput[] | CompanyTemplateUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyTemplateCreateOrConnectWithoutEntrepriseInput | CompanyTemplateCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyTemplateCreateManyEntrepriseInputEnvelope
    connect?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
  }

  export type CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanySettingCreateWithoutEntrepriseInput, CompanySettingUncheckedCreateWithoutEntrepriseInput> | CompanySettingCreateWithoutEntrepriseInput[] | CompanySettingUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanySettingCreateOrConnectWithoutEntrepriseInput | CompanySettingCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanySettingCreateManyEntrepriseInputEnvelope
    connect?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
  }

  export type CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput> | CompanyModeleDocumentCreateWithoutEntrepriseInput[] | CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput | CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyModeleDocumentCreateManyEntrepriseInputEnvelope
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
  }

  export type CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyPeriodePaieCreateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput> | CompanyPeriodePaieCreateWithoutEntrepriseInput[] | CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput | CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyPeriodePaieCreateManyEntrepriseInputEnvelope
    connect?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
  }

  export type CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<CompanyConfigurationPaieCreateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput> | CompanyConfigurationPaieCreateWithoutEntrepriseInput[] | CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput | CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput[]
    createMany?: CompanyConfigurationPaieCreateManyEntrepriseInputEnvelope
    connect?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
  }

  export type ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput = {
    create?: XOR<ReglePointageCreateWithoutEntrepriseInput, ReglePointageUncheckedCreateWithoutEntrepriseInput>
    connectOrCreate?: ReglePointageCreateOrConnectWithoutEntrepriseInput
    connect?: ReglePointageWhereUniqueInput
  }

  export type EmployeeUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<EmployeeCreateWithoutEntrepriseInput, EmployeeUncheckedCreateWithoutEntrepriseInput> | EmployeeCreateWithoutEntrepriseInput[] | EmployeeUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEntrepriseInput | EmployeeCreateOrConnectWithoutEntrepriseInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEntrepriseInput | EmployeeUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: EmployeeCreateManyEntrepriseInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEntrepriseInput | EmployeeUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEntrepriseInput | EmployeeUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type CompanyPayRunUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutEntrepriseInput, CompanyPayRunUncheckedCreateWithoutEntrepriseInput> | CompanyPayRunCreateWithoutEntrepriseInput[] | CompanyPayRunUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutEntrepriseInput | CompanyPayRunCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyPayRunUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyPayRunCreateManyEntrepriseInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyPayRunUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutEntrepriseInput | CompanyPayRunUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type CompanyTemplateUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyTemplateCreateWithoutEntrepriseInput, CompanyTemplateUncheckedCreateWithoutEntrepriseInput> | CompanyTemplateCreateWithoutEntrepriseInput[] | CompanyTemplateUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyTemplateCreateOrConnectWithoutEntrepriseInput | CompanyTemplateCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyTemplateUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyTemplateUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyTemplateCreateManyEntrepriseInputEnvelope
    set?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    disconnect?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    delete?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    connect?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    update?: CompanyTemplateUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyTemplateUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyTemplateUpdateManyWithWhereWithoutEntrepriseInput | CompanyTemplateUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyTemplateScalarWhereInput | CompanyTemplateScalarWhereInput[]
  }

  export type CompanySettingUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanySettingCreateWithoutEntrepriseInput, CompanySettingUncheckedCreateWithoutEntrepriseInput> | CompanySettingCreateWithoutEntrepriseInput[] | CompanySettingUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanySettingCreateOrConnectWithoutEntrepriseInput | CompanySettingCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanySettingUpsertWithWhereUniqueWithoutEntrepriseInput | CompanySettingUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanySettingCreateManyEntrepriseInputEnvelope
    set?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    disconnect?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    delete?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    connect?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    update?: CompanySettingUpdateWithWhereUniqueWithoutEntrepriseInput | CompanySettingUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanySettingUpdateManyWithWhereWithoutEntrepriseInput | CompanySettingUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanySettingScalarWhereInput | CompanySettingScalarWhereInput[]
  }

  export type CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput> | CompanyModeleDocumentCreateWithoutEntrepriseInput[] | CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput | CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyModeleDocumentUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyModeleDocumentUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyModeleDocumentCreateManyEntrepriseInputEnvelope
    set?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    disconnect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    delete?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    update?: CompanyModeleDocumentUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyModeleDocumentUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyModeleDocumentUpdateManyWithWhereWithoutEntrepriseInput | CompanyModeleDocumentUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyModeleDocumentScalarWhereInput | CompanyModeleDocumentScalarWhereInput[]
  }

  export type CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyPeriodePaieCreateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput> | CompanyPeriodePaieCreateWithoutEntrepriseInput[] | CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput | CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyPeriodePaieUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyPeriodePaieUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyPeriodePaieCreateManyEntrepriseInputEnvelope
    set?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    disconnect?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    delete?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    connect?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    update?: CompanyPeriodePaieUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyPeriodePaieUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyPeriodePaieUpdateManyWithWhereWithoutEntrepriseInput | CompanyPeriodePaieUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyPeriodePaieScalarWhereInput | CompanyPeriodePaieScalarWhereInput[]
  }

  export type CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyConfigurationPaieCreateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput> | CompanyConfigurationPaieCreateWithoutEntrepriseInput[] | CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput | CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyConfigurationPaieUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyConfigurationPaieUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyConfigurationPaieCreateManyEntrepriseInputEnvelope
    set?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    disconnect?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    delete?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    connect?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    update?: CompanyConfigurationPaieUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyConfigurationPaieUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyConfigurationPaieUpdateManyWithWhereWithoutEntrepriseInput | CompanyConfigurationPaieUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyConfigurationPaieScalarWhereInput | CompanyConfigurationPaieScalarWhereInput[]
  }

  export type ReglePointageUpdateOneWithoutEntrepriseNestedInput = {
    create?: XOR<ReglePointageCreateWithoutEntrepriseInput, ReglePointageUncheckedCreateWithoutEntrepriseInput>
    connectOrCreate?: ReglePointageCreateOrConnectWithoutEntrepriseInput
    upsert?: ReglePointageUpsertWithoutEntrepriseInput
    disconnect?: ReglePointageWhereInput | boolean
    delete?: ReglePointageWhereInput | boolean
    connect?: ReglePointageWhereUniqueInput
    update?: XOR<XOR<ReglePointageUpdateToOneWithWhereWithoutEntrepriseInput, ReglePointageUpdateWithoutEntrepriseInput>, ReglePointageUncheckedUpdateWithoutEntrepriseInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<EmployeeCreateWithoutEntrepriseInput, EmployeeUncheckedCreateWithoutEntrepriseInput> | EmployeeCreateWithoutEntrepriseInput[] | EmployeeUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEntrepriseInput | EmployeeCreateOrConnectWithoutEntrepriseInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEntrepriseInput | EmployeeUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: EmployeeCreateManyEntrepriseInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEntrepriseInput | EmployeeUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEntrepriseInput | EmployeeUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutEntrepriseInput, CompanyPayRunUncheckedCreateWithoutEntrepriseInput> | CompanyPayRunCreateWithoutEntrepriseInput[] | CompanyPayRunUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutEntrepriseInput | CompanyPayRunCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyPayRunUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyPayRunCreateManyEntrepriseInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyPayRunUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutEntrepriseInput | CompanyPayRunUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyTemplateCreateWithoutEntrepriseInput, CompanyTemplateUncheckedCreateWithoutEntrepriseInput> | CompanyTemplateCreateWithoutEntrepriseInput[] | CompanyTemplateUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyTemplateCreateOrConnectWithoutEntrepriseInput | CompanyTemplateCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyTemplateUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyTemplateUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyTemplateCreateManyEntrepriseInputEnvelope
    set?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    disconnect?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    delete?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    connect?: CompanyTemplateWhereUniqueInput | CompanyTemplateWhereUniqueInput[]
    update?: CompanyTemplateUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyTemplateUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyTemplateUpdateManyWithWhereWithoutEntrepriseInput | CompanyTemplateUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyTemplateScalarWhereInput | CompanyTemplateScalarWhereInput[]
  }

  export type CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanySettingCreateWithoutEntrepriseInput, CompanySettingUncheckedCreateWithoutEntrepriseInput> | CompanySettingCreateWithoutEntrepriseInput[] | CompanySettingUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanySettingCreateOrConnectWithoutEntrepriseInput | CompanySettingCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanySettingUpsertWithWhereUniqueWithoutEntrepriseInput | CompanySettingUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanySettingCreateManyEntrepriseInputEnvelope
    set?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    disconnect?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    delete?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    connect?: CompanySettingWhereUniqueInput | CompanySettingWhereUniqueInput[]
    update?: CompanySettingUpdateWithWhereUniqueWithoutEntrepriseInput | CompanySettingUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanySettingUpdateManyWithWhereWithoutEntrepriseInput | CompanySettingUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanySettingScalarWhereInput | CompanySettingScalarWhereInput[]
  }

  export type CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyModeleDocumentCreateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput> | CompanyModeleDocumentCreateWithoutEntrepriseInput[] | CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput | CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyModeleDocumentUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyModeleDocumentUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyModeleDocumentCreateManyEntrepriseInputEnvelope
    set?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    disconnect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    delete?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    connect?: CompanyModeleDocumentWhereUniqueInput | CompanyModeleDocumentWhereUniqueInput[]
    update?: CompanyModeleDocumentUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyModeleDocumentUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyModeleDocumentUpdateManyWithWhereWithoutEntrepriseInput | CompanyModeleDocumentUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyModeleDocumentScalarWhereInput | CompanyModeleDocumentScalarWhereInput[]
  }

  export type CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyPeriodePaieCreateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput> | CompanyPeriodePaieCreateWithoutEntrepriseInput[] | CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput | CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyPeriodePaieUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyPeriodePaieUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyPeriodePaieCreateManyEntrepriseInputEnvelope
    set?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    disconnect?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    delete?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    connect?: CompanyPeriodePaieWhereUniqueInput | CompanyPeriodePaieWhereUniqueInput[]
    update?: CompanyPeriodePaieUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyPeriodePaieUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyPeriodePaieUpdateManyWithWhereWithoutEntrepriseInput | CompanyPeriodePaieUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyPeriodePaieScalarWhereInput | CompanyPeriodePaieScalarWhereInput[]
  }

  export type CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<CompanyConfigurationPaieCreateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput> | CompanyConfigurationPaieCreateWithoutEntrepriseInput[] | CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput | CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput[]
    upsert?: CompanyConfigurationPaieUpsertWithWhereUniqueWithoutEntrepriseInput | CompanyConfigurationPaieUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: CompanyConfigurationPaieCreateManyEntrepriseInputEnvelope
    set?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    disconnect?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    delete?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    connect?: CompanyConfigurationPaieWhereUniqueInput | CompanyConfigurationPaieWhereUniqueInput[]
    update?: CompanyConfigurationPaieUpdateWithWhereUniqueWithoutEntrepriseInput | CompanyConfigurationPaieUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: CompanyConfigurationPaieUpdateManyWithWhereWithoutEntrepriseInput | CompanyConfigurationPaieUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: CompanyConfigurationPaieScalarWhereInput | CompanyConfigurationPaieScalarWhereInput[]
  }

  export type ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput = {
    create?: XOR<ReglePointageCreateWithoutEntrepriseInput, ReglePointageUncheckedCreateWithoutEntrepriseInput>
    connectOrCreate?: ReglePointageCreateOrConnectWithoutEntrepriseInput
    upsert?: ReglePointageUpsertWithoutEntrepriseInput
    disconnect?: ReglePointageWhereInput | boolean
    delete?: ReglePointageWhereInput | boolean
    connect?: ReglePointageWhereUniqueInput
    update?: XOR<XOR<ReglePointageUpdateToOneWithWhereWithoutEntrepriseInput, ReglePointageUpdateWithoutEntrepriseInput>, ReglePointageUncheckedUpdateWithoutEntrepriseInput>
  }

  export type UserCreateNestedOneWithoutJournalAuditInput = {
    create?: XOR<UserCreateWithoutJournalAuditInput, UserUncheckedCreateWithoutJournalAuditInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalAuditInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutJournalAuditNestedInput = {
    create?: XOR<UserCreateWithoutJournalAuditInput, UserUncheckedCreateWithoutJournalAuditInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalAuditInput
    upsert?: UserUpsertWithoutJournalAuditInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJournalAuditInput, UserUpdateWithoutJournalAuditInput>, UserUncheckedUpdateWithoutJournalAuditInput>
  }

  export type EmployeeCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<EmployeeCreateWithoutPaymentsInput, EmployeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPaymentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProcessedPaymentsInput = {
    create?: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EmployeeUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPaymentsInput, EmployeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPaymentsInput
    upsert?: EmployeeUpsertWithoutPaymentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPaymentsInput, EmployeeUpdateWithoutPaymentsInput>, EmployeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneWithoutProcessedPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedPaymentsInput
    upsert?: UserUpsertWithoutProcessedPaymentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessedPaymentsInput, UserUpdateWithoutProcessedPaymentsInput>, UserUncheckedUpdateWithoutProcessedPaymentsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type EmployeeCreateNestedOneWithoutFacturesInput = {
    create?: XOR<EmployeeCreateWithoutFacturesInput, EmployeeUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFacturesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedFacturesInput = {
    create?: XOR<UserCreateWithoutCreatedFacturesInput, UserUncheckedCreateWithoutCreatedFacturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFacturesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyLigneFactureCreateNestedManyWithoutFactureInput = {
    create?: XOR<CompanyLigneFactureCreateWithoutFactureInput, CompanyLigneFactureUncheckedCreateWithoutFactureInput> | CompanyLigneFactureCreateWithoutFactureInput[] | CompanyLigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: CompanyLigneFactureCreateOrConnectWithoutFactureInput | CompanyLigneFactureCreateOrConnectWithoutFactureInput[]
    createMany?: CompanyLigneFactureCreateManyFactureInputEnvelope
    connect?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
  }

  export type CompanyLigneFactureUncheckedCreateNestedManyWithoutFactureInput = {
    create?: XOR<CompanyLigneFactureCreateWithoutFactureInput, CompanyLigneFactureUncheckedCreateWithoutFactureInput> | CompanyLigneFactureCreateWithoutFactureInput[] | CompanyLigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: CompanyLigneFactureCreateOrConnectWithoutFactureInput | CompanyLigneFactureCreateOrConnectWithoutFactureInput[]
    createMany?: CompanyLigneFactureCreateManyFactureInputEnvelope
    connect?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
  }

  export type EnumCompanyStatutFactureFieldUpdateOperationsInput = {
    set?: $Enums.CompanyStatutFacture
  }

  export type EmployeeUpdateOneRequiredWithoutFacturesNestedInput = {
    create?: XOR<EmployeeCreateWithoutFacturesInput, EmployeeUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutFacturesInput
    upsert?: EmployeeUpsertWithoutFacturesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutFacturesInput, EmployeeUpdateWithoutFacturesInput>, EmployeeUncheckedUpdateWithoutFacturesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedFacturesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedFacturesInput, UserUncheckedCreateWithoutCreatedFacturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedFacturesInput
    upsert?: UserUpsertWithoutCreatedFacturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedFacturesInput, UserUpdateWithoutCreatedFacturesInput>, UserUncheckedUpdateWithoutCreatedFacturesInput>
  }

  export type CompanyLigneFactureUpdateManyWithoutFactureNestedInput = {
    create?: XOR<CompanyLigneFactureCreateWithoutFactureInput, CompanyLigneFactureUncheckedCreateWithoutFactureInput> | CompanyLigneFactureCreateWithoutFactureInput[] | CompanyLigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: CompanyLigneFactureCreateOrConnectWithoutFactureInput | CompanyLigneFactureCreateOrConnectWithoutFactureInput[]
    upsert?: CompanyLigneFactureUpsertWithWhereUniqueWithoutFactureInput | CompanyLigneFactureUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: CompanyLigneFactureCreateManyFactureInputEnvelope
    set?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    disconnect?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    delete?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    connect?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    update?: CompanyLigneFactureUpdateWithWhereUniqueWithoutFactureInput | CompanyLigneFactureUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: CompanyLigneFactureUpdateManyWithWhereWithoutFactureInput | CompanyLigneFactureUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: CompanyLigneFactureScalarWhereInput | CompanyLigneFactureScalarWhereInput[]
  }

  export type CompanyLigneFactureUncheckedUpdateManyWithoutFactureNestedInput = {
    create?: XOR<CompanyLigneFactureCreateWithoutFactureInput, CompanyLigneFactureUncheckedCreateWithoutFactureInput> | CompanyLigneFactureCreateWithoutFactureInput[] | CompanyLigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: CompanyLigneFactureCreateOrConnectWithoutFactureInput | CompanyLigneFactureCreateOrConnectWithoutFactureInput[]
    upsert?: CompanyLigneFactureUpsertWithWhereUniqueWithoutFactureInput | CompanyLigneFactureUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: CompanyLigneFactureCreateManyFactureInputEnvelope
    set?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    disconnect?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    delete?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    connect?: CompanyLigneFactureWhereUniqueInput | CompanyLigneFactureWhereUniqueInput[]
    update?: CompanyLigneFactureUpdateWithWhereUniqueWithoutFactureInput | CompanyLigneFactureUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: CompanyLigneFactureUpdateManyWithWhereWithoutFactureInput | CompanyLigneFactureUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: CompanyLigneFactureScalarWhereInput | CompanyLigneFactureScalarWhereInput[]
  }

  export type CompanyFactureCreateNestedOneWithoutLignesFactureInput = {
    create?: XOR<CompanyFactureCreateWithoutLignesFactureInput, CompanyFactureUncheckedCreateWithoutLignesFactureInput>
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutLignesFactureInput
    connect?: CompanyFactureWhereUniqueInput
  }

  export type CompanyFactureUpdateOneRequiredWithoutLignesFactureNestedInput = {
    create?: XOR<CompanyFactureCreateWithoutLignesFactureInput, CompanyFactureUncheckedCreateWithoutLignesFactureInput>
    connectOrCreate?: CompanyFactureCreateOrConnectWithoutLignesFactureInput
    upsert?: CompanyFactureUpsertWithoutLignesFactureInput
    connect?: CompanyFactureWhereUniqueInput
    update?: XOR<XOR<CompanyFactureUpdateToOneWithWhereWithoutLignesFactureInput, CompanyFactureUpdateWithoutLignesFactureInput>, CompanyFactureUncheckedUpdateWithoutLignesFactureInput>
  }

  export type EntrepriseCreateNestedOneWithoutPayRunsInput = {
    create?: XOR<EntrepriseCreateWithoutPayRunsInput, EntrepriseUncheckedCreateWithoutPayRunsInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutPayRunsInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type CompanyPeriodePaieCreateNestedOneWithoutPayRunsInput = {
    create?: XOR<CompanyPeriodePaieCreateWithoutPayRunsInput, CompanyPeriodePaieUncheckedCreateWithoutPayRunsInput>
    connectOrCreate?: CompanyPeriodePaieCreateOrConnectWithoutPayRunsInput
    connect?: CompanyPeriodePaieWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPayRunsInput = {
    create?: XOR<UserCreateWithoutCreatedPayRunsInput, UserUncheckedCreateWithoutCreatedPayRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPayRunsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedPayRunsInput = {
    create?: XOR<UserCreateWithoutApprovedPayRunsInput, UserUncheckedCreateWithoutApprovedPayRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedPayRunsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyBulletinCreateNestedManyWithoutPayRunInput = {
    create?: XOR<CompanyBulletinCreateWithoutPayRunInput, CompanyBulletinUncheckedCreateWithoutPayRunInput> | CompanyBulletinCreateWithoutPayRunInput[] | CompanyBulletinUncheckedCreateWithoutPayRunInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutPayRunInput | CompanyBulletinCreateOrConnectWithoutPayRunInput[]
    createMany?: CompanyBulletinCreateManyPayRunInputEnvelope
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
  }

  export type CompanyBulletinUncheckedCreateNestedManyWithoutPayRunInput = {
    create?: XOR<CompanyBulletinCreateWithoutPayRunInput, CompanyBulletinUncheckedCreateWithoutPayRunInput> | CompanyBulletinCreateWithoutPayRunInput[] | CompanyBulletinUncheckedCreateWithoutPayRunInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutPayRunInput | CompanyBulletinCreateOrConnectWithoutPayRunInput[]
    createMany?: CompanyBulletinCreateManyPayRunInputEnvelope
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
  }

  export type EnumCompanyStatutPayRunFieldUpdateOperationsInput = {
    set?: $Enums.CompanyStatutPayRun
  }

  export type EntrepriseUpdateOneRequiredWithoutPayRunsNestedInput = {
    create?: XOR<EntrepriseCreateWithoutPayRunsInput, EntrepriseUncheckedCreateWithoutPayRunsInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutPayRunsInput
    upsert?: EntrepriseUpsertWithoutPayRunsInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutPayRunsInput, EntrepriseUpdateWithoutPayRunsInput>, EntrepriseUncheckedUpdateWithoutPayRunsInput>
  }

  export type CompanyPeriodePaieUpdateOneRequiredWithoutPayRunsNestedInput = {
    create?: XOR<CompanyPeriodePaieCreateWithoutPayRunsInput, CompanyPeriodePaieUncheckedCreateWithoutPayRunsInput>
    connectOrCreate?: CompanyPeriodePaieCreateOrConnectWithoutPayRunsInput
    upsert?: CompanyPeriodePaieUpsertWithoutPayRunsInput
    connect?: CompanyPeriodePaieWhereUniqueInput
    update?: XOR<XOR<CompanyPeriodePaieUpdateToOneWithWhereWithoutPayRunsInput, CompanyPeriodePaieUpdateWithoutPayRunsInput>, CompanyPeriodePaieUncheckedUpdateWithoutPayRunsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedPayRunsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPayRunsInput, UserUncheckedCreateWithoutCreatedPayRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPayRunsInput
    upsert?: UserUpsertWithoutCreatedPayRunsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPayRunsInput, UserUpdateWithoutCreatedPayRunsInput>, UserUncheckedUpdateWithoutCreatedPayRunsInput>
  }

  export type UserUpdateOneWithoutApprovedPayRunsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedPayRunsInput, UserUncheckedCreateWithoutApprovedPayRunsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedPayRunsInput
    upsert?: UserUpsertWithoutApprovedPayRunsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedPayRunsInput, UserUpdateWithoutApprovedPayRunsInput>, UserUncheckedUpdateWithoutApprovedPayRunsInput>
  }

  export type CompanyBulletinUpdateManyWithoutPayRunNestedInput = {
    create?: XOR<CompanyBulletinCreateWithoutPayRunInput, CompanyBulletinUncheckedCreateWithoutPayRunInput> | CompanyBulletinCreateWithoutPayRunInput[] | CompanyBulletinUncheckedCreateWithoutPayRunInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutPayRunInput | CompanyBulletinCreateOrConnectWithoutPayRunInput[]
    upsert?: CompanyBulletinUpsertWithWhereUniqueWithoutPayRunInput | CompanyBulletinUpsertWithWhereUniqueWithoutPayRunInput[]
    createMany?: CompanyBulletinCreateManyPayRunInputEnvelope
    set?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    disconnect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    delete?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    update?: CompanyBulletinUpdateWithWhereUniqueWithoutPayRunInput | CompanyBulletinUpdateWithWhereUniqueWithoutPayRunInput[]
    updateMany?: CompanyBulletinUpdateManyWithWhereWithoutPayRunInput | CompanyBulletinUpdateManyWithWhereWithoutPayRunInput[]
    deleteMany?: CompanyBulletinScalarWhereInput | CompanyBulletinScalarWhereInput[]
  }

  export type CompanyBulletinUncheckedUpdateManyWithoutPayRunNestedInput = {
    create?: XOR<CompanyBulletinCreateWithoutPayRunInput, CompanyBulletinUncheckedCreateWithoutPayRunInput> | CompanyBulletinCreateWithoutPayRunInput[] | CompanyBulletinUncheckedCreateWithoutPayRunInput[]
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutPayRunInput | CompanyBulletinCreateOrConnectWithoutPayRunInput[]
    upsert?: CompanyBulletinUpsertWithWhereUniqueWithoutPayRunInput | CompanyBulletinUpsertWithWhereUniqueWithoutPayRunInput[]
    createMany?: CompanyBulletinCreateManyPayRunInputEnvelope
    set?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    disconnect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    delete?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    connect?: CompanyBulletinWhereUniqueInput | CompanyBulletinWhereUniqueInput[]
    update?: CompanyBulletinUpdateWithWhereUniqueWithoutPayRunInput | CompanyBulletinUpdateWithWhereUniqueWithoutPayRunInput[]
    updateMany?: CompanyBulletinUpdateManyWithWhereWithoutPayRunInput | CompanyBulletinUpdateManyWithWhereWithoutPayRunInput[]
    deleteMany?: CompanyBulletinScalarWhereInput | CompanyBulletinScalarWhereInput[]
  }

  export type CompanyPayRunCreateNestedOneWithoutBulletinsInput = {
    create?: XOR<CompanyPayRunCreateWithoutBulletinsInput, CompanyPayRunUncheckedCreateWithoutBulletinsInput>
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutBulletinsInput
    connect?: CompanyPayRunWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutBulletinsInput = {
    create?: XOR<EmployeeCreateWithoutBulletinsInput, EmployeeUncheckedCreateWithoutBulletinsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBulletinsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type CompanyPaiementCreateNestedManyWithoutBulletinInput = {
    create?: XOR<CompanyPaiementCreateWithoutBulletinInput, CompanyPaiementUncheckedCreateWithoutBulletinInput> | CompanyPaiementCreateWithoutBulletinInput[] | CompanyPaiementUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutBulletinInput | CompanyPaiementCreateOrConnectWithoutBulletinInput[]
    createMany?: CompanyPaiementCreateManyBulletinInputEnvelope
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
  }

  export type CompanyPaiementUncheckedCreateNestedManyWithoutBulletinInput = {
    create?: XOR<CompanyPaiementCreateWithoutBulletinInput, CompanyPaiementUncheckedCreateWithoutBulletinInput> | CompanyPaiementCreateWithoutBulletinInput[] | CompanyPaiementUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutBulletinInput | CompanyPaiementCreateOrConnectWithoutBulletinInput[]
    createMany?: CompanyPaiementCreateManyBulletinInputEnvelope
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
  }

  export type CompanyPayRunUpdateOneRequiredWithoutBulletinsNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutBulletinsInput, CompanyPayRunUncheckedCreateWithoutBulletinsInput>
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutBulletinsInput
    upsert?: CompanyPayRunUpsertWithoutBulletinsInput
    connect?: CompanyPayRunWhereUniqueInput
    update?: XOR<XOR<CompanyPayRunUpdateToOneWithWhereWithoutBulletinsInput, CompanyPayRunUpdateWithoutBulletinsInput>, CompanyPayRunUncheckedUpdateWithoutBulletinsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutBulletinsNestedInput = {
    create?: XOR<EmployeeCreateWithoutBulletinsInput, EmployeeUncheckedCreateWithoutBulletinsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBulletinsInput
    upsert?: EmployeeUpsertWithoutBulletinsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutBulletinsInput, EmployeeUpdateWithoutBulletinsInput>, EmployeeUncheckedUpdateWithoutBulletinsInput>
  }

  export type CompanyPaiementUpdateManyWithoutBulletinNestedInput = {
    create?: XOR<CompanyPaiementCreateWithoutBulletinInput, CompanyPaiementUncheckedCreateWithoutBulletinInput> | CompanyPaiementCreateWithoutBulletinInput[] | CompanyPaiementUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutBulletinInput | CompanyPaiementCreateOrConnectWithoutBulletinInput[]
    upsert?: CompanyPaiementUpsertWithWhereUniqueWithoutBulletinInput | CompanyPaiementUpsertWithWhereUniqueWithoutBulletinInput[]
    createMany?: CompanyPaiementCreateManyBulletinInputEnvelope
    set?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    disconnect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    delete?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    update?: CompanyPaiementUpdateWithWhereUniqueWithoutBulletinInput | CompanyPaiementUpdateWithWhereUniqueWithoutBulletinInput[]
    updateMany?: CompanyPaiementUpdateManyWithWhereWithoutBulletinInput | CompanyPaiementUpdateManyWithWhereWithoutBulletinInput[]
    deleteMany?: CompanyPaiementScalarWhereInput | CompanyPaiementScalarWhereInput[]
  }

  export type CompanyPaiementUncheckedUpdateManyWithoutBulletinNestedInput = {
    create?: XOR<CompanyPaiementCreateWithoutBulletinInput, CompanyPaiementUncheckedCreateWithoutBulletinInput> | CompanyPaiementCreateWithoutBulletinInput[] | CompanyPaiementUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: CompanyPaiementCreateOrConnectWithoutBulletinInput | CompanyPaiementCreateOrConnectWithoutBulletinInput[]
    upsert?: CompanyPaiementUpsertWithWhereUniqueWithoutBulletinInput | CompanyPaiementUpsertWithWhereUniqueWithoutBulletinInput[]
    createMany?: CompanyPaiementCreateManyBulletinInputEnvelope
    set?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    disconnect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    delete?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    connect?: CompanyPaiementWhereUniqueInput | CompanyPaiementWhereUniqueInput[]
    update?: CompanyPaiementUpdateWithWhereUniqueWithoutBulletinInput | CompanyPaiementUpdateWithWhereUniqueWithoutBulletinInput[]
    updateMany?: CompanyPaiementUpdateManyWithWhereWithoutBulletinInput | CompanyPaiementUpdateManyWithWhereWithoutBulletinInput[]
    deleteMany?: CompanyPaiementScalarWhereInput | CompanyPaiementScalarWhereInput[]
  }

  export type CompanyBulletinCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<CompanyBulletinCreateWithoutPaiementsInput, CompanyBulletinUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutPaiementsInput
    connect?: CompanyBulletinWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProcessedPaymentsCompanyInput = {
    create?: XOR<UserCreateWithoutProcessedPaymentsCompanyInput, UserUncheckedCreateWithoutProcessedPaymentsCompanyInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedPaymentsCompanyInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyBulletinUpdateOneRequiredWithoutPaiementsNestedInput = {
    create?: XOR<CompanyBulletinCreateWithoutPaiementsInput, CompanyBulletinUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: CompanyBulletinCreateOrConnectWithoutPaiementsInput
    upsert?: CompanyBulletinUpsertWithoutPaiementsInput
    connect?: CompanyBulletinWhereUniqueInput
    update?: XOR<XOR<CompanyBulletinUpdateToOneWithWhereWithoutPaiementsInput, CompanyBulletinUpdateWithoutPaiementsInput>, CompanyBulletinUncheckedUpdateWithoutPaiementsInput>
  }

  export type UserUpdateOneRequiredWithoutProcessedPaymentsCompanyNestedInput = {
    create?: XOR<UserCreateWithoutProcessedPaymentsCompanyInput, UserUncheckedCreateWithoutProcessedPaymentsCompanyInput>
    connectOrCreate?: UserCreateOrConnectWithoutProcessedPaymentsCompanyInput
    upsert?: UserUpsertWithoutProcessedPaymentsCompanyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProcessedPaymentsCompanyInput, UserUpdateWithoutProcessedPaymentsCompanyInput>, UserUncheckedUpdateWithoutProcessedPaymentsCompanyInput>
  }

  export type EntrepriseCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<EntrepriseCreateWithoutTemplatesInput, EntrepriseUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutTemplatesInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type EntrepriseUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<EntrepriseCreateWithoutTemplatesInput, EntrepriseUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutTemplatesInput
    upsert?: EntrepriseUpsertWithoutTemplatesInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutTemplatesInput, EntrepriseUpdateWithoutTemplatesInput>, EntrepriseUncheckedUpdateWithoutTemplatesInput>
  }

  export type EntrepriseCreateNestedOneWithoutSettingsInput = {
    create?: XOR<EntrepriseCreateWithoutSettingsInput, EntrepriseUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutSettingsInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type EntrepriseUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<EntrepriseCreateWithoutSettingsInput, EntrepriseUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutSettingsInput
    upsert?: EntrepriseUpsertWithoutSettingsInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutSettingsInput, EntrepriseUpdateWithoutSettingsInput>, EntrepriseUncheckedUpdateWithoutSettingsInput>
  }

  export type EmployeeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    upsert?: EmployeeUpsertWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDocumentsInput, EmployeeUpdateWithoutDocumentsInput>, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: UserUpsertWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocumentsInput, UserUpdateWithoutUploadedDocumentsInput>, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type EntrepriseCreateNestedOneWithoutModelesInput = {
    create?: XOR<EntrepriseCreateWithoutModelesInput, EntrepriseUncheckedCreateWithoutModelesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutModelesInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedModelesInput = {
    create?: XOR<UserCreateWithoutCreatedModelesInput, UserUncheckedCreateWithoutCreatedModelesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedModelesInput
    connect?: UserWhereUniqueInput
  }

  export type EntrepriseUpdateOneRequiredWithoutModelesNestedInput = {
    create?: XOR<EntrepriseCreateWithoutModelesInput, EntrepriseUncheckedCreateWithoutModelesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutModelesInput
    upsert?: EntrepriseUpsertWithoutModelesInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutModelesInput, EntrepriseUpdateWithoutModelesInput>, EntrepriseUncheckedUpdateWithoutModelesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedModelesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedModelesInput, UserUncheckedCreateWithoutCreatedModelesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedModelesInput
    upsert?: UserUpsertWithoutCreatedModelesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedModelesInput, UserUpdateWithoutCreatedModelesInput>, UserUncheckedUpdateWithoutCreatedModelesInput>
  }

  export type EntrepriseCreateNestedOneWithoutPeriodesPaieInput = {
    create?: XOR<EntrepriseCreateWithoutPeriodesPaieInput, EntrepriseUncheckedCreateWithoutPeriodesPaieInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutPeriodesPaieInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type CompanyPayRunCreateNestedManyWithoutPeriodePaieInput = {
    create?: XOR<CompanyPayRunCreateWithoutPeriodePaieInput, CompanyPayRunUncheckedCreateWithoutPeriodePaieInput> | CompanyPayRunCreateWithoutPeriodePaieInput[] | CompanyPayRunUncheckedCreateWithoutPeriodePaieInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutPeriodePaieInput | CompanyPayRunCreateOrConnectWithoutPeriodePaieInput[]
    createMany?: CompanyPayRunCreateManyPeriodePaieInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type CompanyPayRunUncheckedCreateNestedManyWithoutPeriodePaieInput = {
    create?: XOR<CompanyPayRunCreateWithoutPeriodePaieInput, CompanyPayRunUncheckedCreateWithoutPeriodePaieInput> | CompanyPayRunCreateWithoutPeriodePaieInput[] | CompanyPayRunUncheckedCreateWithoutPeriodePaieInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutPeriodePaieInput | CompanyPayRunCreateOrConnectWithoutPeriodePaieInput[]
    createMany?: CompanyPayRunCreateManyPeriodePaieInputEnvelope
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
  }

  export type EntrepriseUpdateOneRequiredWithoutPeriodesPaieNestedInput = {
    create?: XOR<EntrepriseCreateWithoutPeriodesPaieInput, EntrepriseUncheckedCreateWithoutPeriodesPaieInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutPeriodesPaieInput
    upsert?: EntrepriseUpsertWithoutPeriodesPaieInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutPeriodesPaieInput, EntrepriseUpdateWithoutPeriodesPaieInput>, EntrepriseUncheckedUpdateWithoutPeriodesPaieInput>
  }

  export type CompanyPayRunUpdateManyWithoutPeriodePaieNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutPeriodePaieInput, CompanyPayRunUncheckedCreateWithoutPeriodePaieInput> | CompanyPayRunCreateWithoutPeriodePaieInput[] | CompanyPayRunUncheckedCreateWithoutPeriodePaieInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutPeriodePaieInput | CompanyPayRunCreateOrConnectWithoutPeriodePaieInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutPeriodePaieInput | CompanyPayRunUpsertWithWhereUniqueWithoutPeriodePaieInput[]
    createMany?: CompanyPayRunCreateManyPeriodePaieInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutPeriodePaieInput | CompanyPayRunUpdateWithWhereUniqueWithoutPeriodePaieInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutPeriodePaieInput | CompanyPayRunUpdateManyWithWhereWithoutPeriodePaieInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutPeriodePaieNestedInput = {
    create?: XOR<CompanyPayRunCreateWithoutPeriodePaieInput, CompanyPayRunUncheckedCreateWithoutPeriodePaieInput> | CompanyPayRunCreateWithoutPeriodePaieInput[] | CompanyPayRunUncheckedCreateWithoutPeriodePaieInput[]
    connectOrCreate?: CompanyPayRunCreateOrConnectWithoutPeriodePaieInput | CompanyPayRunCreateOrConnectWithoutPeriodePaieInput[]
    upsert?: CompanyPayRunUpsertWithWhereUniqueWithoutPeriodePaieInput | CompanyPayRunUpsertWithWhereUniqueWithoutPeriodePaieInput[]
    createMany?: CompanyPayRunCreateManyPeriodePaieInputEnvelope
    set?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    disconnect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    delete?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    connect?: CompanyPayRunWhereUniqueInput | CompanyPayRunWhereUniqueInput[]
    update?: CompanyPayRunUpdateWithWhereUniqueWithoutPeriodePaieInput | CompanyPayRunUpdateWithWhereUniqueWithoutPeriodePaieInput[]
    updateMany?: CompanyPayRunUpdateManyWithWhereWithoutPeriodePaieInput | CompanyPayRunUpdateManyWithWhereWithoutPeriodePaieInput[]
    deleteMany?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
  }

  export type EntrepriseCreateNestedOneWithoutConfigurationsPaieInput = {
    create?: XOR<EntrepriseCreateWithoutConfigurationsPaieInput, EntrepriseUncheckedCreateWithoutConfigurationsPaieInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutConfigurationsPaieInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type CompanyRegleDeductionCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<CompanyRegleDeductionCreateWithoutConfigurationInput, CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput> | CompanyRegleDeductionCreateWithoutConfigurationInput[] | CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput | CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput[]
    createMany?: CompanyRegleDeductionCreateManyConfigurationInputEnvelope
    connect?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
  }

  export type CompanyRegleDeductionUncheckedCreateNestedManyWithoutConfigurationInput = {
    create?: XOR<CompanyRegleDeductionCreateWithoutConfigurationInput, CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput> | CompanyRegleDeductionCreateWithoutConfigurationInput[] | CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput | CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput[]
    createMany?: CompanyRegleDeductionCreateManyConfigurationInputEnvelope
    connect?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
  }

  export type EntrepriseUpdateOneRequiredWithoutConfigurationsPaieNestedInput = {
    create?: XOR<EntrepriseCreateWithoutConfigurationsPaieInput, EntrepriseUncheckedCreateWithoutConfigurationsPaieInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutConfigurationsPaieInput
    upsert?: EntrepriseUpsertWithoutConfigurationsPaieInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutConfigurationsPaieInput, EntrepriseUpdateWithoutConfigurationsPaieInput>, EntrepriseUncheckedUpdateWithoutConfigurationsPaieInput>
  }

  export type CompanyRegleDeductionUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<CompanyRegleDeductionCreateWithoutConfigurationInput, CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput> | CompanyRegleDeductionCreateWithoutConfigurationInput[] | CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput | CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput[]
    upsert?: CompanyRegleDeductionUpsertWithWhereUniqueWithoutConfigurationInput | CompanyRegleDeductionUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: CompanyRegleDeductionCreateManyConfigurationInputEnvelope
    set?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    disconnect?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    delete?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    connect?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    update?: CompanyRegleDeductionUpdateWithWhereUniqueWithoutConfigurationInput | CompanyRegleDeductionUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: CompanyRegleDeductionUpdateManyWithWhereWithoutConfigurationInput | CompanyRegleDeductionUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: CompanyRegleDeductionScalarWhereInput | CompanyRegleDeductionScalarWhereInput[]
  }

  export type CompanyRegleDeductionUncheckedUpdateManyWithoutConfigurationNestedInput = {
    create?: XOR<CompanyRegleDeductionCreateWithoutConfigurationInput, CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput> | CompanyRegleDeductionCreateWithoutConfigurationInput[] | CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput[]
    connectOrCreate?: CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput | CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput[]
    upsert?: CompanyRegleDeductionUpsertWithWhereUniqueWithoutConfigurationInput | CompanyRegleDeductionUpsertWithWhereUniqueWithoutConfigurationInput[]
    createMany?: CompanyRegleDeductionCreateManyConfigurationInputEnvelope
    set?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    disconnect?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    delete?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    connect?: CompanyRegleDeductionWhereUniqueInput | CompanyRegleDeductionWhereUniqueInput[]
    update?: CompanyRegleDeductionUpdateWithWhereUniqueWithoutConfigurationInput | CompanyRegleDeductionUpdateWithWhereUniqueWithoutConfigurationInput[]
    updateMany?: CompanyRegleDeductionUpdateManyWithWhereWithoutConfigurationInput | CompanyRegleDeductionUpdateManyWithWhereWithoutConfigurationInput[]
    deleteMany?: CompanyRegleDeductionScalarWhereInput | CompanyRegleDeductionScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutSalaryHistoryInput = {
    create?: XOR<EmployeeCreateWithoutSalaryHistoryInput, EmployeeUncheckedCreateWithoutSalaryHistoryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalaryHistoryInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutModifiedSalariesInput = {
    create?: XOR<UserCreateWithoutModifiedSalariesInput, UserUncheckedCreateWithoutModifiedSalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutModifiedSalariesInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutSalaryHistoryNestedInput = {
    create?: XOR<EmployeeCreateWithoutSalaryHistoryInput, EmployeeUncheckedCreateWithoutSalaryHistoryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalaryHistoryInput
    upsert?: EmployeeUpsertWithoutSalaryHistoryInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSalaryHistoryInput, EmployeeUpdateWithoutSalaryHistoryInput>, EmployeeUncheckedUpdateWithoutSalaryHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutModifiedSalariesNestedInput = {
    create?: XOR<UserCreateWithoutModifiedSalariesInput, UserUncheckedCreateWithoutModifiedSalariesInput>
    connectOrCreate?: UserCreateOrConnectWithoutModifiedSalariesInput
    upsert?: UserUpsertWithoutModifiedSalariesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModifiedSalariesInput, UserUpdateWithoutModifiedSalariesInput>, UserUncheckedUpdateWithoutModifiedSalariesInput>
  }

  export type CompanyConfigurationPaieCreateNestedOneWithoutReglesDeductionInput = {
    create?: XOR<CompanyConfigurationPaieCreateWithoutReglesDeductionInput, CompanyConfigurationPaieUncheckedCreateWithoutReglesDeductionInput>
    connectOrCreate?: CompanyConfigurationPaieCreateOrConnectWithoutReglesDeductionInput
    connect?: CompanyConfigurationPaieWhereUniqueInput
  }

  export type CompanyConfigurationPaieUpdateOneRequiredWithoutReglesDeductionNestedInput = {
    create?: XOR<CompanyConfigurationPaieCreateWithoutReglesDeductionInput, CompanyConfigurationPaieUncheckedCreateWithoutReglesDeductionInput>
    connectOrCreate?: CompanyConfigurationPaieCreateOrConnectWithoutReglesDeductionInput
    upsert?: CompanyConfigurationPaieUpsertWithoutReglesDeductionInput
    connect?: CompanyConfigurationPaieWhereUniqueInput
    update?: XOR<XOR<CompanyConfigurationPaieUpdateToOneWithWhereWithoutReglesDeductionInput, CompanyConfigurationPaieUpdateWithoutReglesDeductionInput>, CompanyConfigurationPaieUncheckedUpdateWithoutReglesDeductionInput>
  }

  export type EmployeeCreateNestedOneWithoutPointagesInput = {
    create?: XOR<EmployeeCreateWithoutPointagesInput, EmployeeUncheckedCreateWithoutPointagesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPointagesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutValidatedPointagesInput = {
    create?: XOR<UserCreateWithoutValidatedPointagesInput, UserUncheckedCreateWithoutValidatedPointagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedPointagesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStatutPointageFieldUpdateOperationsInput = {
    set?: $Enums.StatutPointage
  }

  export type EnumTypePointageFieldUpdateOperationsInput = {
    set?: $Enums.TypePointage
  }

  export type EmployeeUpdateOneRequiredWithoutPointagesNestedInput = {
    create?: XOR<EmployeeCreateWithoutPointagesInput, EmployeeUncheckedCreateWithoutPointagesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPointagesInput
    upsert?: EmployeeUpsertWithoutPointagesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPointagesInput, EmployeeUpdateWithoutPointagesInput>, EmployeeUncheckedUpdateWithoutPointagesInput>
  }

  export type UserUpdateOneWithoutValidatedPointagesNestedInput = {
    create?: XOR<UserCreateWithoutValidatedPointagesInput, UserUncheckedCreateWithoutValidatedPointagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutValidatedPointagesInput
    upsert?: UserUpsertWithoutValidatedPointagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutValidatedPointagesInput, UserUpdateWithoutValidatedPointagesInput>, UserUncheckedUpdateWithoutValidatedPointagesInput>
  }

  export type EntrepriseCreateNestedOneWithoutReglePointageInput = {
    create?: XOR<EntrepriseCreateWithoutReglePointageInput, EntrepriseUncheckedCreateWithoutReglePointageInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutReglePointageInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type EntrepriseUpdateOneRequiredWithoutReglePointageNestedInput = {
    create?: XOR<EntrepriseCreateWithoutReglePointageInput, EntrepriseUncheckedCreateWithoutReglePointageInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutReglePointageInput
    upsert?: EntrepriseUpsertWithoutReglePointageInput
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutReglePointageInput, EntrepriseUpdateWithoutReglePointageInput>, EntrepriseUncheckedUpdateWithoutReglePointageInput>
  }

  export type EmployeeCreateNestedOneWithoutAbsencesInput = {
    create?: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAbsencesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedAbsencesInput = {
    create?: XOR<UserCreateWithoutApprovedAbsencesInput, UserUncheckedCreateWithoutApprovedAbsencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedAbsencesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTypeAbsenceFieldUpdateOperationsInput = {
    set?: $Enums.TypeAbsence
  }

  export type EnumStatutAbsenceFieldUpdateOperationsInput = {
    set?: $Enums.StatutAbsence
  }

  export type EmployeeUpdateOneRequiredWithoutAbsencesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAbsencesInput
    upsert?: EmployeeUpsertWithoutAbsencesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAbsencesInput, EmployeeUpdateWithoutAbsencesInput>, EmployeeUncheckedUpdateWithoutAbsencesInput>
  }

  export type UserUpdateOneWithoutApprovedAbsencesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedAbsencesInput, UserUncheckedCreateWithoutApprovedAbsencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedAbsencesInput
    upsert?: UserUpsertWithoutApprovedAbsencesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedAbsencesInput, UserUpdateWithoutApprovedAbsencesInput>, UserUncheckedUpdateWithoutApprovedAbsencesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumEmployeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[]
    notIn?: $Enums.EmployeeStatus[]
    not?: NestedEnumEmployeeStatusFilter<$PrismaModel> | $Enums.EmployeeStatus
  }

  export type NestedEnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[]
    notIn?: $Enums.ContractType[]
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[]
    notIn?: $Enums.EmployeeStatus[]
    not?: NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumCompanyStatutFactureFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutFacture | EnumCompanyStatutFactureFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutFacture[]
    notIn?: $Enums.CompanyStatutFacture[]
    not?: NestedEnumCompanyStatutFactureFilter<$PrismaModel> | $Enums.CompanyStatutFacture
  }

  export type NestedEnumCompanyStatutFactureWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutFacture | EnumCompanyStatutFactureFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutFacture[]
    notIn?: $Enums.CompanyStatutFacture[]
    not?: NestedEnumCompanyStatutFactureWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatutFacture
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatutFactureFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatutFactureFilter<$PrismaModel>
  }

  export type NestedEnumCompanyStatutPayRunFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutPayRun | EnumCompanyStatutPayRunFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutPayRun[]
    notIn?: $Enums.CompanyStatutPayRun[]
    not?: NestedEnumCompanyStatutPayRunFilter<$PrismaModel> | $Enums.CompanyStatutPayRun
  }

  export type NestedEnumCompanyStatutPayRunWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatutPayRun | EnumCompanyStatutPayRunFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatutPayRun[]
    notIn?: $Enums.CompanyStatutPayRun[]
    not?: NestedEnumCompanyStatutPayRunWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatutPayRun
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatutPayRunFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatutPayRunFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStatutPointageFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPointage | EnumStatutPointageFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPointage[]
    notIn?: $Enums.StatutPointage[]
    not?: NestedEnumStatutPointageFilter<$PrismaModel> | $Enums.StatutPointage
  }

  export type NestedEnumTypePointageFilter<$PrismaModel = never> = {
    equals?: $Enums.TypePointage | EnumTypePointageFieldRefInput<$PrismaModel>
    in?: $Enums.TypePointage[]
    notIn?: $Enums.TypePointage[]
    not?: NestedEnumTypePointageFilter<$PrismaModel> | $Enums.TypePointage
  }

  export type NestedEnumStatutPointageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutPointage | EnumStatutPointageFieldRefInput<$PrismaModel>
    in?: $Enums.StatutPointage[]
    notIn?: $Enums.StatutPointage[]
    not?: NestedEnumStatutPointageWithAggregatesFilter<$PrismaModel> | $Enums.StatutPointage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutPointageFilter<$PrismaModel>
    _max?: NestedEnumStatutPointageFilter<$PrismaModel>
  }

  export type NestedEnumTypePointageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypePointage | EnumTypePointageFieldRefInput<$PrismaModel>
    in?: $Enums.TypePointage[]
    notIn?: $Enums.TypePointage[]
    not?: NestedEnumTypePointageWithAggregatesFilter<$PrismaModel> | $Enums.TypePointage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypePointageFilter<$PrismaModel>
    _max?: NestedEnumTypePointageFilter<$PrismaModel>
  }

  export type NestedEnumTypeAbsenceFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeAbsence | EnumTypeAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeAbsence[]
    notIn?: $Enums.TypeAbsence[]
    not?: NestedEnumTypeAbsenceFilter<$PrismaModel> | $Enums.TypeAbsence
  }

  export type NestedEnumStatutAbsenceFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAbsence | EnumStatutAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAbsence[]
    notIn?: $Enums.StatutAbsence[]
    not?: NestedEnumStatutAbsenceFilter<$PrismaModel> | $Enums.StatutAbsence
  }

  export type NestedEnumTypeAbsenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeAbsence | EnumTypeAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeAbsence[]
    notIn?: $Enums.TypeAbsence[]
    not?: NestedEnumTypeAbsenceWithAggregatesFilter<$PrismaModel> | $Enums.TypeAbsence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeAbsenceFilter<$PrismaModel>
    _max?: NestedEnumTypeAbsenceFilter<$PrismaModel>
  }

  export type NestedEnumStatutAbsenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAbsence | EnumStatutAbsenceFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAbsence[]
    notIn?: $Enums.StatutAbsence[]
    not?: NestedEnumStatutAbsenceWithAggregatesFilter<$PrismaModel> | $Enums.StatutAbsence
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAbsenceFilter<$PrismaModel>
    _max?: NestedEnumStatutAbsenceFilter<$PrismaModel>
  }

  export type EmployeeCreateWithoutUserInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type JournalAuditCreateWithoutUtilisateurInput = {
    action: string
    nomTable: string
    idEnregistrement?: number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
  }

  export type JournalAuditUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    action: string
    nomTable: string
    idEnregistrement?: number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
  }

  export type JournalAuditCreateOrConnectWithoutUtilisateurInput = {
    where: JournalAuditWhereUniqueInput
    create: XOR<JournalAuditCreateWithoutUtilisateurInput, JournalAuditUncheckedCreateWithoutUtilisateurInput>
  }

  export type JournalAuditCreateManyUtilisateurInputEnvelope = {
    data: JournalAuditCreateManyUtilisateurInput | JournalAuditCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCashierInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCashierInput = {
    id?: number
    employeeId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCashierInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCashierInput, PaymentUncheckedCreateWithoutCashierInput>
  }

  export type PaymentCreateManyCashierInputEnvelope = {
    data: PaymentCreateManyCashierInput | PaymentCreateManyCashierInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    message: string
    type?: $Enums.NotificationType
    category: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    message: string
    type?: $Enums.NotificationType
    category: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFactureCreateWithoutCreatorInput = {
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutFacturesInput
    lignesFacture?: CompanyLigneFactureCreateNestedManyWithoutFactureInput
  }

  export type CompanyFactureUncheckedCreateWithoutCreatorInput = {
    id?: number
    employeeId: number
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    lignesFacture?: CompanyLigneFactureUncheckedCreateNestedManyWithoutFactureInput
  }

  export type CompanyFactureCreateOrConnectWithoutCreatorInput = {
    where: CompanyFactureWhereUniqueInput
    create: XOR<CompanyFactureCreateWithoutCreatorInput, CompanyFactureUncheckedCreateWithoutCreatorInput>
  }

  export type CompanyFactureCreateManyCreatorInputEnvelope = {
    data: CompanyFactureCreateManyCreatorInput | CompanyFactureCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPayRunCreateWithoutCreatorInput = {
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    approuveLe?: Date | string | null
    entreprise: EntrepriseCreateNestedOneWithoutPayRunsInput
    periodePaie: CompanyPeriodePaieCreateNestedOneWithoutPayRunsInput
    approver?: UserCreateNestedOneWithoutApprovedPayRunsInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunUncheckedCreateWithoutCreatorInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    periodePaieId: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunCreateOrConnectWithoutCreatorInput = {
    where: CompanyPayRunWhereUniqueInput
    create: XOR<CompanyPayRunCreateWithoutCreatorInput, CompanyPayRunUncheckedCreateWithoutCreatorInput>
  }

  export type CompanyPayRunCreateManyCreatorInputEnvelope = {
    data: CompanyPayRunCreateManyCreatorInput | CompanyPayRunCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPayRunCreateWithoutApproverInput = {
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    approuveLe?: Date | string | null
    entreprise: EntrepriseCreateNestedOneWithoutPayRunsInput
    periodePaie: CompanyPeriodePaieCreateNestedOneWithoutPayRunsInput
    creator: UserCreateNestedOneWithoutCreatedPayRunsInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunUncheckedCreateWithoutApproverInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    periodePaieId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunCreateOrConnectWithoutApproverInput = {
    where: CompanyPayRunWhereUniqueInput
    create: XOR<CompanyPayRunCreateWithoutApproverInput, CompanyPayRunUncheckedCreateWithoutApproverInput>
  }

  export type CompanyPayRunCreateManyApproverInputEnvelope = {
    data: CompanyPayRunCreateManyApproverInput | CompanyPayRunCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPaiementCreateWithoutProcessorInput = {
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    bulletin: CompanyBulletinCreateNestedOneWithoutPaiementsInput
  }

  export type CompanyPaiementUncheckedCreateWithoutProcessorInput = {
    id?: number
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId: number
    creeLe?: Date | string
  }

  export type CompanyPaiementCreateOrConnectWithoutProcessorInput = {
    where: CompanyPaiementWhereUniqueInput
    create: XOR<CompanyPaiementCreateWithoutProcessorInput, CompanyPaiementUncheckedCreateWithoutProcessorInput>
  }

  export type CompanyPaiementCreateManyProcessorInputEnvelope = {
    data: CompanyPaiementCreateManyProcessorInput | CompanyPaiementCreateManyProcessorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyDocumentCreateWithoutUploaderInput = {
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    creeLe?: Date | string
    modifieLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutDocumentsInput
  }

  export type CompanyDocumentUncheckedCreateWithoutUploaderInput = {
    id?: number
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    employeId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyDocumentCreateOrConnectWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    create: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type CompanyDocumentCreateManyUploaderInputEnvelope = {
    data: CompanyDocumentCreateManyUploaderInput | CompanyDocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyModeleDocumentCreateWithoutCreatorInput = {
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    version?: number
    creeLe?: Date | string
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutModelesInput
  }

  export type CompanyModeleDocumentUncheckedCreateWithoutCreatorInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    entrepriseId: number
    version?: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyModeleDocumentCreateOrConnectWithoutCreatorInput = {
    where: CompanyModeleDocumentWhereUniqueInput
    create: XOR<CompanyModeleDocumentCreateWithoutCreatorInput, CompanyModeleDocumentUncheckedCreateWithoutCreatorInput>
  }

  export type CompanyModeleDocumentCreateManyCreatorInputEnvelope = {
    data: CompanyModeleDocumentCreateManyCreatorInput | CompanyModeleDocumentCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyHistoriqueSalaireCreateWithoutModifierInput = {
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutSalaryHistoryInput
  }

  export type CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput = {
    id?: number
    employeId: number
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
  }

  export type CompanyHistoriqueSalaireCreateOrConnectWithoutModifierInput = {
    where: CompanyHistoriqueSalaireWhereUniqueInput
    create: XOR<CompanyHistoriqueSalaireCreateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput>
  }

  export type CompanyHistoriqueSalaireCreateManyModifierInputEnvelope = {
    data: CompanyHistoriqueSalaireCreateManyModifierInput | CompanyHistoriqueSalaireCreateManyModifierInput[]
    skipDuplicates?: boolean
  }

  export type PointageCreateWithoutValidateurInput = {
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    employe: EmployeeCreateNestedOneWithoutPointagesInput
  }

  export type PointageUncheckedCreateWithoutValidateurInput = {
    id?: number
    employeId: number
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type PointageCreateOrConnectWithoutValidateurInput = {
    where: PointageWhereUniqueInput
    create: XOR<PointageCreateWithoutValidateurInput, PointageUncheckedCreateWithoutValidateurInput>
  }

  export type PointageCreateManyValidateurInputEnvelope = {
    data: PointageCreateManyValidateurInput | PointageCreateManyValidateurInput[]
    skipDuplicates?: boolean
  }

  export type AbsenceCreateWithoutApprobateurInput = {
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    employe: EmployeeCreateNestedOneWithoutAbsencesInput
  }

  export type AbsenceUncheckedCreateWithoutApprobateurInput = {
    id?: number
    employeId: number
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type AbsenceCreateOrConnectWithoutApprobateurInput = {
    where: AbsenceWhereUniqueInput
    create: XOR<AbsenceCreateWithoutApprobateurInput, AbsenceUncheckedCreateWithoutApprobateurInput>
  }

  export type AbsenceCreateManyApprobateurInputEnvelope = {
    data: AbsenceCreateManyApprobateurInput | AbsenceCreateManyApprobateurInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type JournalAuditUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: JournalAuditWhereUniqueInput
    update: XOR<JournalAuditUpdateWithoutUtilisateurInput, JournalAuditUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<JournalAuditCreateWithoutUtilisateurInput, JournalAuditUncheckedCreateWithoutUtilisateurInput>
  }

  export type JournalAuditUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: JournalAuditWhereUniqueInput
    data: XOR<JournalAuditUpdateWithoutUtilisateurInput, JournalAuditUncheckedUpdateWithoutUtilisateurInput>
  }

  export type JournalAuditUpdateManyWithWhereWithoutUtilisateurInput = {
    where: JournalAuditScalarWhereInput
    data: XOR<JournalAuditUpdateManyMutationInput, JournalAuditUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type JournalAuditScalarWhereInput = {
    AND?: JournalAuditScalarWhereInput | JournalAuditScalarWhereInput[]
    OR?: JournalAuditScalarWhereInput[]
    NOT?: JournalAuditScalarWhereInput | JournalAuditScalarWhereInput[]
    id?: IntFilter<"JournalAudit"> | number
    utilisateurId?: IntNullableFilter<"JournalAudit"> | number | null
    action?: StringFilter<"JournalAudit"> | string
    nomTable?: StringFilter<"JournalAudit"> | string
    idEnregistrement?: IntNullableFilter<"JournalAudit"> | number | null
    anciennes_valeurs?: JsonNullableFilter<"JournalAudit">
    nouvelles_valeurs?: JsonNullableFilter<"JournalAudit">
    creeLe?: DateTimeFilter<"JournalAudit"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCashierInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCashierInput, PaymentUncheckedUpdateWithoutCashierInput>
    create: XOR<PaymentCreateWithoutCashierInput, PaymentUncheckedCreateWithoutCashierInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCashierInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCashierInput, PaymentUncheckedUpdateWithoutCashierInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCashierInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCashierInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    employeeId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    notes?: StringNullableFilter<"Payment"> | string | null
    processedBy?: IntNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type CompanyFactureUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CompanyFactureWhereUniqueInput
    update: XOR<CompanyFactureUpdateWithoutCreatorInput, CompanyFactureUncheckedUpdateWithoutCreatorInput>
    create: XOR<CompanyFactureCreateWithoutCreatorInput, CompanyFactureUncheckedCreateWithoutCreatorInput>
  }

  export type CompanyFactureUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CompanyFactureWhereUniqueInput
    data: XOR<CompanyFactureUpdateWithoutCreatorInput, CompanyFactureUncheckedUpdateWithoutCreatorInput>
  }

  export type CompanyFactureUpdateManyWithWhereWithoutCreatorInput = {
    where: CompanyFactureScalarWhereInput
    data: XOR<CompanyFactureUpdateManyMutationInput, CompanyFactureUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CompanyFactureScalarWhereInput = {
    AND?: CompanyFactureScalarWhereInput | CompanyFactureScalarWhereInput[]
    OR?: CompanyFactureScalarWhereInput[]
    NOT?: CompanyFactureScalarWhereInput | CompanyFactureScalarWhereInput[]
    id?: IntFilter<"CompanyFacture"> | number
    employeeId?: IntFilter<"CompanyFacture"> | number
    numeroFacture?: StringFilter<"CompanyFacture"> | string
    montant?: DecimalFilter<"CompanyFacture"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"CompanyFacture"> | string | null
    statut?: EnumCompanyStatutFactureFilter<"CompanyFacture"> | $Enums.CompanyStatutFacture
    dateEcheance?: DateTimeNullableFilter<"CompanyFacture"> | Date | string | null
    datePaiement?: DateTimeNullableFilter<"CompanyFacture"> | Date | string | null
    creePar?: IntFilter<"CompanyFacture"> | number
    creeLe?: DateTimeFilter<"CompanyFacture"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyFacture"> | Date | string
  }

  export type CompanyPayRunUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CompanyPayRunWhereUniqueInput
    update: XOR<CompanyPayRunUpdateWithoutCreatorInput, CompanyPayRunUncheckedUpdateWithoutCreatorInput>
    create: XOR<CompanyPayRunCreateWithoutCreatorInput, CompanyPayRunUncheckedCreateWithoutCreatorInput>
  }

  export type CompanyPayRunUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CompanyPayRunWhereUniqueInput
    data: XOR<CompanyPayRunUpdateWithoutCreatorInput, CompanyPayRunUncheckedUpdateWithoutCreatorInput>
  }

  export type CompanyPayRunUpdateManyWithWhereWithoutCreatorInput = {
    where: CompanyPayRunScalarWhereInput
    data: XOR<CompanyPayRunUpdateManyMutationInput, CompanyPayRunUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CompanyPayRunScalarWhereInput = {
    AND?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
    OR?: CompanyPayRunScalarWhereInput[]
    NOT?: CompanyPayRunScalarWhereInput | CompanyPayRunScalarWhereInput[]
    id?: IntFilter<"CompanyPayRun"> | number
    reference?: StringFilter<"CompanyPayRun"> | string
    dateDebut?: DateTimeFilter<"CompanyPayRun"> | Date | string
    dateFin?: DateTimeFilter<"CompanyPayRun"> | Date | string
    datePaiement?: DateTimeFilter<"CompanyPayRun"> | Date | string
    statut?: EnumCompanyStatutPayRunFilter<"CompanyPayRun"> | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"CompanyPayRun"> | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFilter<"CompanyPayRun"> | number
    metadata?: JsonNullableFilter<"CompanyPayRun">
    entrepriseId?: IntFilter<"CompanyPayRun"> | number
    periodePaieId?: IntFilter<"CompanyPayRun"> | number
    creePar?: IntFilter<"CompanyPayRun"> | number
    creeLe?: DateTimeFilter<"CompanyPayRun"> | Date | string
    approuveLe?: DateTimeNullableFilter<"CompanyPayRun"> | Date | string | null
    approuvePar?: IntNullableFilter<"CompanyPayRun"> | number | null
  }

  export type CompanyPayRunUpsertWithWhereUniqueWithoutApproverInput = {
    where: CompanyPayRunWhereUniqueInput
    update: XOR<CompanyPayRunUpdateWithoutApproverInput, CompanyPayRunUncheckedUpdateWithoutApproverInput>
    create: XOR<CompanyPayRunCreateWithoutApproverInput, CompanyPayRunUncheckedCreateWithoutApproverInput>
  }

  export type CompanyPayRunUpdateWithWhereUniqueWithoutApproverInput = {
    where: CompanyPayRunWhereUniqueInput
    data: XOR<CompanyPayRunUpdateWithoutApproverInput, CompanyPayRunUncheckedUpdateWithoutApproverInput>
  }

  export type CompanyPayRunUpdateManyWithWhereWithoutApproverInput = {
    where: CompanyPayRunScalarWhereInput
    data: XOR<CompanyPayRunUpdateManyMutationInput, CompanyPayRunUncheckedUpdateManyWithoutApproverInput>
  }

  export type CompanyPaiementUpsertWithWhereUniqueWithoutProcessorInput = {
    where: CompanyPaiementWhereUniqueInput
    update: XOR<CompanyPaiementUpdateWithoutProcessorInput, CompanyPaiementUncheckedUpdateWithoutProcessorInput>
    create: XOR<CompanyPaiementCreateWithoutProcessorInput, CompanyPaiementUncheckedCreateWithoutProcessorInput>
  }

  export type CompanyPaiementUpdateWithWhereUniqueWithoutProcessorInput = {
    where: CompanyPaiementWhereUniqueInput
    data: XOR<CompanyPaiementUpdateWithoutProcessorInput, CompanyPaiementUncheckedUpdateWithoutProcessorInput>
  }

  export type CompanyPaiementUpdateManyWithWhereWithoutProcessorInput = {
    where: CompanyPaiementScalarWhereInput
    data: XOR<CompanyPaiementUpdateManyMutationInput, CompanyPaiementUncheckedUpdateManyWithoutProcessorInput>
  }

  export type CompanyPaiementScalarWhereInput = {
    AND?: CompanyPaiementScalarWhereInput | CompanyPaiementScalarWhereInput[]
    OR?: CompanyPaiementScalarWhereInput[]
    NOT?: CompanyPaiementScalarWhereInput | CompanyPaiementScalarWhereInput[]
    id?: IntFilter<"CompanyPaiement"> | number
    referenceTransaction?: StringFilter<"CompanyPaiement"> | string
    montant?: DecimalFilter<"CompanyPaiement"> | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFilter<"CompanyPaiement"> | string
    referencePaiement?: StringNullableFilter<"CompanyPaiement"> | string | null
    datePaiement?: DateTimeFilter<"CompanyPaiement"> | Date | string
    notes?: StringNullableFilter<"CompanyPaiement"> | string | null
    cheminRecu?: StringNullableFilter<"CompanyPaiement"> | string | null
    statut?: StringFilter<"CompanyPaiement"> | string
    metadata?: JsonNullableFilter<"CompanyPaiement">
    bulletinId?: IntFilter<"CompanyPaiement"> | number
    traitePar?: IntFilter<"CompanyPaiement"> | number
    creeLe?: DateTimeFilter<"CompanyPaiement"> | Date | string
  }

  export type CompanyDocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    update: XOR<CompanyDocumentUpdateWithoutUploaderInput, CompanyDocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<CompanyDocumentCreateWithoutUploaderInput, CompanyDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type CompanyDocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: CompanyDocumentWhereUniqueInput
    data: XOR<CompanyDocumentUpdateWithoutUploaderInput, CompanyDocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type CompanyDocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: CompanyDocumentScalarWhereInput
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type CompanyDocumentScalarWhereInput = {
    AND?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
    OR?: CompanyDocumentScalarWhereInput[]
    NOT?: CompanyDocumentScalarWhereInput | CompanyDocumentScalarWhereInput[]
    id?: IntFilter<"CompanyDocument"> | number
    type?: StringFilter<"CompanyDocument"> | string
    titre?: StringFilter<"CompanyDocument"> | string
    description?: StringNullableFilter<"CompanyDocument"> | string | null
    cheminFichier?: StringFilter<"CompanyDocument"> | string
    tailleFichier?: IntFilter<"CompanyDocument"> | number
    mimeType?: StringFilter<"CompanyDocument"> | string
    metadata?: JsonNullableFilter<"CompanyDocument">
    tags?: StringFilter<"CompanyDocument"> | string
    employeId?: IntFilter<"CompanyDocument"> | number
    uploadePar?: IntFilter<"CompanyDocument"> | number
    creeLe?: DateTimeFilter<"CompanyDocument"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyDocument"> | Date | string
  }

  export type CompanyModeleDocumentUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CompanyModeleDocumentWhereUniqueInput
    update: XOR<CompanyModeleDocumentUpdateWithoutCreatorInput, CompanyModeleDocumentUncheckedUpdateWithoutCreatorInput>
    create: XOR<CompanyModeleDocumentCreateWithoutCreatorInput, CompanyModeleDocumentUncheckedCreateWithoutCreatorInput>
  }

  export type CompanyModeleDocumentUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CompanyModeleDocumentWhereUniqueInput
    data: XOR<CompanyModeleDocumentUpdateWithoutCreatorInput, CompanyModeleDocumentUncheckedUpdateWithoutCreatorInput>
  }

  export type CompanyModeleDocumentUpdateManyWithWhereWithoutCreatorInput = {
    where: CompanyModeleDocumentScalarWhereInput
    data: XOR<CompanyModeleDocumentUpdateManyMutationInput, CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CompanyModeleDocumentScalarWhereInput = {
    AND?: CompanyModeleDocumentScalarWhereInput | CompanyModeleDocumentScalarWhereInput[]
    OR?: CompanyModeleDocumentScalarWhereInput[]
    NOT?: CompanyModeleDocumentScalarWhereInput | CompanyModeleDocumentScalarWhereInput[]
    id?: IntFilter<"CompanyModeleDocument"> | number
    nom?: StringFilter<"CompanyModeleDocument"> | string
    description?: StringNullableFilter<"CompanyModeleDocument"> | string | null
    type?: StringFilter<"CompanyModeleDocument"> | string
    contenu?: StringFilter<"CompanyModeleDocument"> | string
    variables?: JsonFilter<"CompanyModeleDocument">
    estActif?: BoolFilter<"CompanyModeleDocument"> | boolean
    entrepriseId?: IntFilter<"CompanyModeleDocument"> | number
    version?: IntFilter<"CompanyModeleDocument"> | number
    creePar?: IntFilter<"CompanyModeleDocument"> | number
    creeLe?: DateTimeFilter<"CompanyModeleDocument"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyModeleDocument"> | Date | string
  }

  export type CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutModifierInput = {
    where: CompanyHistoriqueSalaireWhereUniqueInput
    update: XOR<CompanyHistoriqueSalaireUpdateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedUpdateWithoutModifierInput>
    create: XOR<CompanyHistoriqueSalaireCreateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedCreateWithoutModifierInput>
  }

  export type CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutModifierInput = {
    where: CompanyHistoriqueSalaireWhereUniqueInput
    data: XOR<CompanyHistoriqueSalaireUpdateWithoutModifierInput, CompanyHistoriqueSalaireUncheckedUpdateWithoutModifierInput>
  }

  export type CompanyHistoriqueSalaireUpdateManyWithWhereWithoutModifierInput = {
    where: CompanyHistoriqueSalaireScalarWhereInput
    data: XOR<CompanyHistoriqueSalaireUpdateManyMutationInput, CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierInput>
  }

  export type CompanyHistoriqueSalaireScalarWhereInput = {
    AND?: CompanyHistoriqueSalaireScalarWhereInput | CompanyHistoriqueSalaireScalarWhereInput[]
    OR?: CompanyHistoriqueSalaireScalarWhereInput[]
    NOT?: CompanyHistoriqueSalaireScalarWhereInput | CompanyHistoriqueSalaireScalarWhereInput[]
    id?: IntFilter<"CompanyHistoriqueSalaire"> | number
    employeId?: IntFilter<"CompanyHistoriqueSalaire"> | number
    ancienSalaire?: DecimalFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFilter<"CompanyHistoriqueSalaire"> | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFilter<"CompanyHistoriqueSalaire"> | Date | string
    motif?: StringFilter<"CompanyHistoriqueSalaire"> | string
    notes?: StringNullableFilter<"CompanyHistoriqueSalaire"> | string | null
    documents?: JsonNullableFilter<"CompanyHistoriqueSalaire">
    modifiePar?: IntFilter<"CompanyHistoriqueSalaire"> | number
    creeLe?: DateTimeFilter<"CompanyHistoriqueSalaire"> | Date | string
  }

  export type PointageUpsertWithWhereUniqueWithoutValidateurInput = {
    where: PointageWhereUniqueInput
    update: XOR<PointageUpdateWithoutValidateurInput, PointageUncheckedUpdateWithoutValidateurInput>
    create: XOR<PointageCreateWithoutValidateurInput, PointageUncheckedCreateWithoutValidateurInput>
  }

  export type PointageUpdateWithWhereUniqueWithoutValidateurInput = {
    where: PointageWhereUniqueInput
    data: XOR<PointageUpdateWithoutValidateurInput, PointageUncheckedUpdateWithoutValidateurInput>
  }

  export type PointageUpdateManyWithWhereWithoutValidateurInput = {
    where: PointageScalarWhereInput
    data: XOR<PointageUpdateManyMutationInput, PointageUncheckedUpdateManyWithoutValidateurInput>
  }

  export type PointageScalarWhereInput = {
    AND?: PointageScalarWhereInput | PointageScalarWhereInput[]
    OR?: PointageScalarWhereInput[]
    NOT?: PointageScalarWhereInput | PointageScalarWhereInput[]
    id?: IntFilter<"Pointage"> | number
    employeId?: IntFilter<"Pointage"> | number
    date?: DateTimeFilter<"Pointage"> | Date | string
    heureArrivee?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    heureDepart?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    statut?: EnumStatutPointageFilter<"Pointage"> | $Enums.StatutPointage
    typePointage?: EnumTypePointageFilter<"Pointage"> | $Enums.TypePointage
    commentaire?: StringNullableFilter<"Pointage"> | string | null
    latitude?: DecimalNullableFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Pointage"> | Decimal | DecimalJsLike | number | string | null
    ipAddress?: StringNullableFilter<"Pointage"> | string | null
    deviceInfo?: StringNullableFilter<"Pointage"> | string | null
    validePar?: IntNullableFilter<"Pointage"> | number | null
    dateValidation?: DateTimeNullableFilter<"Pointage"> | Date | string | null
    creeLe?: DateTimeFilter<"Pointage"> | Date | string
    modifieLe?: DateTimeFilter<"Pointage"> | Date | string
  }

  export type AbsenceUpsertWithWhereUniqueWithoutApprobateurInput = {
    where: AbsenceWhereUniqueInput
    update: XOR<AbsenceUpdateWithoutApprobateurInput, AbsenceUncheckedUpdateWithoutApprobateurInput>
    create: XOR<AbsenceCreateWithoutApprobateurInput, AbsenceUncheckedCreateWithoutApprobateurInput>
  }

  export type AbsenceUpdateWithWhereUniqueWithoutApprobateurInput = {
    where: AbsenceWhereUniqueInput
    data: XOR<AbsenceUpdateWithoutApprobateurInput, AbsenceUncheckedUpdateWithoutApprobateurInput>
  }

  export type AbsenceUpdateManyWithWhereWithoutApprobateurInput = {
    where: AbsenceScalarWhereInput
    data: XOR<AbsenceUpdateManyMutationInput, AbsenceUncheckedUpdateManyWithoutApprobateurInput>
  }

  export type AbsenceScalarWhereInput = {
    AND?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
    OR?: AbsenceScalarWhereInput[]
    NOT?: AbsenceScalarWhereInput | AbsenceScalarWhereInput[]
    id?: IntFilter<"Absence"> | number
    employeId?: IntFilter<"Absence"> | number
    typeAbsence?: EnumTypeAbsenceFilter<"Absence"> | $Enums.TypeAbsence
    dateDebut?: DateTimeFilter<"Absence"> | Date | string
    dateFin?: DateTimeFilter<"Absence"> | Date | string
    motif?: StringNullableFilter<"Absence"> | string | null
    statut?: EnumStatutAbsenceFilter<"Absence"> | $Enums.StatutAbsence
    joursOuvres?: IntFilter<"Absence"> | number
    heuresAbsence?: DecimalFilter<"Absence"> | Decimal | DecimalJsLike | number | string
    commentaire?: StringNullableFilter<"Absence"> | string | null
    pieceJointe?: StringNullableFilter<"Absence"> | string | null
    approuvePar?: IntNullableFilter<"Absence"> | number | null
    dateApprobation?: DateTimeNullableFilter<"Absence"> | Date | string | null
    creeLe?: DateTimeFilter<"Absence"> | Date | string
    modifieLe?: DateTimeFilter<"Absence"> | Date | string
  }

  export type UserCreateWithoutEmployeeInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type EntrepriseCreateWithoutEmployeesInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutEmployeesInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutEmployeesInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutEmployeesInput, EntrepriseUncheckedCreateWithoutEmployeesInput>
  }

  export type PaymentCreateWithoutEmployeeInput = {
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cashier?: UserCreateNestedOneWithoutProcessedPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutEmployeeInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutEmployeeInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutEmployeeInput, PaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type PaymentCreateManyEmployeeInputEnvelope = {
    data: PaymentCreateManyEmployeeInput | PaymentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyFactureCreateWithoutEmployeeInput = {
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    creator: UserCreateNestedOneWithoutCreatedFacturesInput
    lignesFacture?: CompanyLigneFactureCreateNestedManyWithoutFactureInput
  }

  export type CompanyFactureUncheckedCreateWithoutEmployeeInput = {
    id?: number
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
    lignesFacture?: CompanyLigneFactureUncheckedCreateNestedManyWithoutFactureInput
  }

  export type CompanyFactureCreateOrConnectWithoutEmployeeInput = {
    where: CompanyFactureWhereUniqueInput
    create: XOR<CompanyFactureCreateWithoutEmployeeInput, CompanyFactureUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyFactureCreateManyEmployeeInputEnvelope = {
    data: CompanyFactureCreateManyEmployeeInput | CompanyFactureCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyBulletinCreateWithoutEmployeeInput = {
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
    payRun: CompanyPayRunCreateNestedOneWithoutBulletinsInput
    paiements?: CompanyPaiementCreateNestedManyWithoutBulletinInput
  }

  export type CompanyBulletinUncheckedCreateWithoutEmployeeInput = {
    id?: number
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    payRunId: number
    creeLe?: Date | string
    modifieLe?: Date | string
    paiements?: CompanyPaiementUncheckedCreateNestedManyWithoutBulletinInput
  }

  export type CompanyBulletinCreateOrConnectWithoutEmployeeInput = {
    where: CompanyBulletinWhereUniqueInput
    create: XOR<CompanyBulletinCreateWithoutEmployeeInput, CompanyBulletinUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyBulletinCreateManyEmployeeInputEnvelope = {
    data: CompanyBulletinCreateManyEmployeeInput | CompanyBulletinCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyDocumentCreateWithoutEmployeeInput = {
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    creeLe?: Date | string
    modifieLe?: Date | string
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type CompanyDocumentUncheckedCreateWithoutEmployeeInput = {
    id?: number
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    uploadePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyDocumentCreateOrConnectWithoutEmployeeInput = {
    where: CompanyDocumentWhereUniqueInput
    create: XOR<CompanyDocumentCreateWithoutEmployeeInput, CompanyDocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyDocumentCreateManyEmployeeInputEnvelope = {
    data: CompanyDocumentCreateManyEmployeeInput | CompanyDocumentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyHistoriqueSalaireCreateWithoutEmployeeInput = {
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifier: UserCreateNestedOneWithoutModifiedSalariesInput
  }

  export type CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput = {
    id?: number
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar: number
    creeLe?: Date | string
  }

  export type CompanyHistoriqueSalaireCreateOrConnectWithoutEmployeeInput = {
    where: CompanyHistoriqueSalaireWhereUniqueInput
    create: XOR<CompanyHistoriqueSalaireCreateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyHistoriqueSalaireCreateManyEmployeeInputEnvelope = {
    data: CompanyHistoriqueSalaireCreateManyEmployeeInput | CompanyHistoriqueSalaireCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PointageCreateWithoutEmployeInput = {
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    validateur?: UserCreateNestedOneWithoutValidatedPointagesInput
  }

  export type PointageUncheckedCreateWithoutEmployeInput = {
    id?: number
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    validePar?: number | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type PointageCreateOrConnectWithoutEmployeInput = {
    where: PointageWhereUniqueInput
    create: XOR<PointageCreateWithoutEmployeInput, PointageUncheckedCreateWithoutEmployeInput>
  }

  export type PointageCreateManyEmployeInputEnvelope = {
    data: PointageCreateManyEmployeInput | PointageCreateManyEmployeInput[]
    skipDuplicates?: boolean
  }

  export type AbsenceCreateWithoutEmployeInput = {
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    approbateur?: UserCreateNestedOneWithoutApprovedAbsencesInput
  }

  export type AbsenceUncheckedCreateWithoutEmployeInput = {
    id?: number
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    approuvePar?: number | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type AbsenceCreateOrConnectWithoutEmployeInput = {
    where: AbsenceWhereUniqueInput
    create: XOR<AbsenceCreateWithoutEmployeInput, AbsenceUncheckedCreateWithoutEmployeInput>
  }

  export type AbsenceCreateManyEmployeInputEnvelope = {
    data: AbsenceCreateManyEmployeInput | AbsenceCreateManyEmployeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type EntrepriseUpsertWithoutEmployeesInput = {
    update: XOR<EntrepriseUpdateWithoutEmployeesInput, EntrepriseUncheckedUpdateWithoutEmployeesInput>
    create: XOR<EntrepriseCreateWithoutEmployeesInput, EntrepriseUncheckedCreateWithoutEmployeesInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutEmployeesInput, EntrepriseUncheckedUpdateWithoutEmployeesInput>
  }

  export type EntrepriseUpdateWithoutEmployeesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutEmployeeInput, PaymentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PaymentCreateWithoutEmployeeInput, PaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutEmployeeInput, PaymentUncheckedUpdateWithoutEmployeeInput>
  }

  export type PaymentUpdateManyWithWhereWithoutEmployeeInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type CompanyFactureUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyFactureWhereUniqueInput
    update: XOR<CompanyFactureUpdateWithoutEmployeeInput, CompanyFactureUncheckedUpdateWithoutEmployeeInput>
    create: XOR<CompanyFactureCreateWithoutEmployeeInput, CompanyFactureUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyFactureUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyFactureWhereUniqueInput
    data: XOR<CompanyFactureUpdateWithoutEmployeeInput, CompanyFactureUncheckedUpdateWithoutEmployeeInput>
  }

  export type CompanyFactureUpdateManyWithWhereWithoutEmployeeInput = {
    where: CompanyFactureScalarWhereInput
    data: XOR<CompanyFactureUpdateManyMutationInput, CompanyFactureUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type CompanyBulletinUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyBulletinWhereUniqueInput
    update: XOR<CompanyBulletinUpdateWithoutEmployeeInput, CompanyBulletinUncheckedUpdateWithoutEmployeeInput>
    create: XOR<CompanyBulletinCreateWithoutEmployeeInput, CompanyBulletinUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyBulletinUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyBulletinWhereUniqueInput
    data: XOR<CompanyBulletinUpdateWithoutEmployeeInput, CompanyBulletinUncheckedUpdateWithoutEmployeeInput>
  }

  export type CompanyBulletinUpdateManyWithWhereWithoutEmployeeInput = {
    where: CompanyBulletinScalarWhereInput
    data: XOR<CompanyBulletinUpdateManyMutationInput, CompanyBulletinUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type CompanyBulletinScalarWhereInput = {
    AND?: CompanyBulletinScalarWhereInput | CompanyBulletinScalarWhereInput[]
    OR?: CompanyBulletinScalarWhereInput[]
    NOT?: CompanyBulletinScalarWhereInput | CompanyBulletinScalarWhereInput[]
    id?: IntFilter<"CompanyBulletin"> | number
    numeroBulletin?: StringFilter<"CompanyBulletin"> | string
    datePaiement?: DateTimeFilter<"CompanyBulletin"> | Date | string
    joursTravailles?: IntFilter<"CompanyBulletin"> | number
    heuresTravailes?: IntFilter<"CompanyBulletin"> | number
    salaireBrut?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    deductions?: JsonFilter<"CompanyBulletin">
    totalDeductions?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFilter<"CompanyBulletin"> | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFilter<"CompanyBulletin"> | string
    cheminPDF?: StringNullableFilter<"CompanyBulletin"> | string | null
    calculs?: JsonNullableFilter<"CompanyBulletin">
    estVerrouille?: BoolFilter<"CompanyBulletin"> | boolean
    payRunId?: IntFilter<"CompanyBulletin"> | number
    employeId?: IntFilter<"CompanyBulletin"> | number
    creeLe?: DateTimeFilter<"CompanyBulletin"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyBulletin"> | Date | string
  }

  export type CompanyDocumentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyDocumentWhereUniqueInput
    update: XOR<CompanyDocumentUpdateWithoutEmployeeInput, CompanyDocumentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<CompanyDocumentCreateWithoutEmployeeInput, CompanyDocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyDocumentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyDocumentWhereUniqueInput
    data: XOR<CompanyDocumentUpdateWithoutEmployeeInput, CompanyDocumentUncheckedUpdateWithoutEmployeeInput>
  }

  export type CompanyDocumentUpdateManyWithWhereWithoutEmployeeInput = {
    where: CompanyDocumentScalarWhereInput
    data: XOR<CompanyDocumentUpdateManyMutationInput, CompanyDocumentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type CompanyHistoriqueSalaireUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyHistoriqueSalaireWhereUniqueInput
    update: XOR<CompanyHistoriqueSalaireUpdateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedUpdateWithoutEmployeeInput>
    create: XOR<CompanyHistoriqueSalaireCreateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedCreateWithoutEmployeeInput>
  }

  export type CompanyHistoriqueSalaireUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: CompanyHistoriqueSalaireWhereUniqueInput
    data: XOR<CompanyHistoriqueSalaireUpdateWithoutEmployeeInput, CompanyHistoriqueSalaireUncheckedUpdateWithoutEmployeeInput>
  }

  export type CompanyHistoriqueSalaireUpdateManyWithWhereWithoutEmployeeInput = {
    where: CompanyHistoriqueSalaireScalarWhereInput
    data: XOR<CompanyHistoriqueSalaireUpdateManyMutationInput, CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PointageUpsertWithWhereUniqueWithoutEmployeInput = {
    where: PointageWhereUniqueInput
    update: XOR<PointageUpdateWithoutEmployeInput, PointageUncheckedUpdateWithoutEmployeInput>
    create: XOR<PointageCreateWithoutEmployeInput, PointageUncheckedCreateWithoutEmployeInput>
  }

  export type PointageUpdateWithWhereUniqueWithoutEmployeInput = {
    where: PointageWhereUniqueInput
    data: XOR<PointageUpdateWithoutEmployeInput, PointageUncheckedUpdateWithoutEmployeInput>
  }

  export type PointageUpdateManyWithWhereWithoutEmployeInput = {
    where: PointageScalarWhereInput
    data: XOR<PointageUpdateManyMutationInput, PointageUncheckedUpdateManyWithoutEmployeInput>
  }

  export type AbsenceUpsertWithWhereUniqueWithoutEmployeInput = {
    where: AbsenceWhereUniqueInput
    update: XOR<AbsenceUpdateWithoutEmployeInput, AbsenceUncheckedUpdateWithoutEmployeInput>
    create: XOR<AbsenceCreateWithoutEmployeInput, AbsenceUncheckedCreateWithoutEmployeInput>
  }

  export type AbsenceUpdateWithWhereUniqueWithoutEmployeInput = {
    where: AbsenceWhereUniqueInput
    data: XOR<AbsenceUpdateWithoutEmployeInput, AbsenceUncheckedUpdateWithoutEmployeInput>
  }

  export type AbsenceUpdateManyWithWhereWithoutEmployeInput = {
    where: AbsenceScalarWhereInput
    data: XOR<AbsenceUpdateManyMutationInput, AbsenceUncheckedUpdateManyWithoutEmployeInput>
  }

  export type EmployeeCreateWithoutEntrepriseInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    userId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutEntrepriseInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEntrepriseInput, EmployeeUncheckedCreateWithoutEntrepriseInput>
  }

  export type EmployeeCreateManyEntrepriseInputEnvelope = {
    data: EmployeeCreateManyEntrepriseInput | EmployeeCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPayRunCreateWithoutEntrepriseInput = {
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    approuveLe?: Date | string | null
    periodePaie: CompanyPeriodePaieCreateNestedOneWithoutPayRunsInput
    creator: UserCreateNestedOneWithoutCreatedPayRunsInput
    approver?: UserCreateNestedOneWithoutApprovedPayRunsInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodePaieId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunCreateOrConnectWithoutEntrepriseInput = {
    where: CompanyPayRunWhereUniqueInput
    create: XOR<CompanyPayRunCreateWithoutEntrepriseInput, CompanyPayRunUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyPayRunCreateManyEntrepriseInputEnvelope = {
    data: CompanyPayRunCreateManyEntrepriseInput | CompanyPayRunCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type CompanyTemplateCreateWithoutEntrepriseInput = {
    typeTemplate: string
    nom: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estDefaut?: boolean
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyTemplateUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    typeTemplate: string
    nom: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estDefaut?: boolean
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyTemplateCreateOrConnectWithoutEntrepriseInput = {
    where: CompanyTemplateWhereUniqueInput
    create: XOR<CompanyTemplateCreateWithoutEntrepriseInput, CompanyTemplateUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyTemplateCreateManyEntrepriseInputEnvelope = {
    data: CompanyTemplateCreateManyEntrepriseInput | CompanyTemplateCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type CompanySettingCreateWithoutEntrepriseInput = {
    cle: string
    valeur: string
    description?: string | null
    typeData: string
    estEncrypte?: boolean
    modifieLe?: Date | string
  }

  export type CompanySettingUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    cle: string
    valeur: string
    description?: string | null
    typeData: string
    estEncrypte?: boolean
    modifieLe?: Date | string
  }

  export type CompanySettingCreateOrConnectWithoutEntrepriseInput = {
    where: CompanySettingWhereUniqueInput
    create: XOR<CompanySettingCreateWithoutEntrepriseInput, CompanySettingUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanySettingCreateManyEntrepriseInputEnvelope = {
    data: CompanySettingCreateManyEntrepriseInput | CompanySettingCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type CompanyModeleDocumentCreateWithoutEntrepriseInput = {
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    version?: number
    creeLe?: Date | string
    modifieLe?: Date | string
    creator: UserCreateNestedOneWithoutCreatedModelesInput
  }

  export type CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    version?: number
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyModeleDocumentCreateOrConnectWithoutEntrepriseInput = {
    where: CompanyModeleDocumentWhereUniqueInput
    create: XOR<CompanyModeleDocumentCreateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyModeleDocumentCreateManyEntrepriseInputEnvelope = {
    data: CompanyModeleDocumentCreateManyEntrepriseInput | CompanyModeleDocumentCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPeriodePaieCreateWithoutEntrepriseInput = {
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    payRuns?: CompanyPayRunCreateNestedManyWithoutPeriodePaieInput
  }

  export type CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutPeriodePaieInput
  }

  export type CompanyPeriodePaieCreateOrConnectWithoutEntrepriseInput = {
    where: CompanyPeriodePaieWhereUniqueInput
    create: XOR<CompanyPeriodePaieCreateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyPeriodePaieCreateManyEntrepriseInputEnvelope = {
    data: CompanyPeriodePaieCreateManyEntrepriseInput | CompanyPeriodePaieCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type CompanyConfigurationPaieCreateWithoutEntrepriseInput = {
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
    reglesDeduction?: CompanyRegleDeductionCreateNestedManyWithoutConfigurationInput
  }

  export type CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
    reglesDeduction?: CompanyRegleDeductionUncheckedCreateNestedManyWithoutConfigurationInput
  }

  export type CompanyConfigurationPaieCreateOrConnectWithoutEntrepriseInput = {
    where: CompanyConfigurationPaieWhereUniqueInput
    create: XOR<CompanyConfigurationPaieCreateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyConfigurationPaieCreateManyEntrepriseInputEnvelope = {
    data: CompanyConfigurationPaieCreateManyEntrepriseInput | CompanyConfigurationPaieCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type ReglePointageCreateWithoutEntrepriseInput = {
    heureDebut?: string
    heureFin?: string
    toleranceRetard?: number
    toleranceDepart?: number
    joursTravail: JsonNullValueInput | InputJsonValue
    heuresParJour?: number
    heuresSupAutorise?: boolean
    seuilHeuresSup?: number
    pauseDejeuner?: number
    estFlexible?: boolean
    plageHoraireMin?: string | null
    plageHoraireMax?: string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
  }

  export type ReglePointageUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    heureDebut?: string
    heureFin?: string
    toleranceRetard?: number
    toleranceDepart?: number
    joursTravail: JsonNullValueInput | InputJsonValue
    heuresParJour?: number
    heuresSupAutorise?: boolean
    seuilHeuresSup?: number
    pauseDejeuner?: number
    estFlexible?: boolean
    plageHoraireMin?: string | null
    plageHoraireMax?: string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
  }

  export type ReglePointageCreateOrConnectWithoutEntrepriseInput = {
    where: ReglePointageWhereUniqueInput
    create: XOR<ReglePointageCreateWithoutEntrepriseInput, ReglePointageUncheckedCreateWithoutEntrepriseInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutEntrepriseInput, EmployeeUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<EmployeeCreateWithoutEntrepriseInput, EmployeeUncheckedCreateWithoutEntrepriseInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutEntrepriseInput, EmployeeUncheckedUpdateWithoutEntrepriseInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutEntrepriseInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: IntFilter<"Employee"> | number
    userId?: IntFilter<"Employee"> | number
    entrepriseId?: IntFilter<"Employee"> | number
    employeeId?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    contractType?: EnumContractTypeFilter<"Employee"> | $Enums.ContractType
    salary?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    dailyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: DecimalNullableFilter<"Employee"> | Decimal | DecimalJsLike | number | string | null
    hireDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    qrCode?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type CompanyPayRunUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyPayRunWhereUniqueInput
    update: XOR<CompanyPayRunUpdateWithoutEntrepriseInput, CompanyPayRunUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<CompanyPayRunCreateWithoutEntrepriseInput, CompanyPayRunUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyPayRunUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyPayRunWhereUniqueInput
    data: XOR<CompanyPayRunUpdateWithoutEntrepriseInput, CompanyPayRunUncheckedUpdateWithoutEntrepriseInput>
  }

  export type CompanyPayRunUpdateManyWithWhereWithoutEntrepriseInput = {
    where: CompanyPayRunScalarWhereInput
    data: XOR<CompanyPayRunUpdateManyMutationInput, CompanyPayRunUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type CompanyTemplateUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyTemplateWhereUniqueInput
    update: XOR<CompanyTemplateUpdateWithoutEntrepriseInput, CompanyTemplateUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<CompanyTemplateCreateWithoutEntrepriseInput, CompanyTemplateUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyTemplateUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyTemplateWhereUniqueInput
    data: XOR<CompanyTemplateUpdateWithoutEntrepriseInput, CompanyTemplateUncheckedUpdateWithoutEntrepriseInput>
  }

  export type CompanyTemplateUpdateManyWithWhereWithoutEntrepriseInput = {
    where: CompanyTemplateScalarWhereInput
    data: XOR<CompanyTemplateUpdateManyMutationInput, CompanyTemplateUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type CompanyTemplateScalarWhereInput = {
    AND?: CompanyTemplateScalarWhereInput | CompanyTemplateScalarWhereInput[]
    OR?: CompanyTemplateScalarWhereInput[]
    NOT?: CompanyTemplateScalarWhereInput | CompanyTemplateScalarWhereInput[]
    id?: IntFilter<"CompanyTemplate"> | number
    typeTemplate?: StringFilter<"CompanyTemplate"> | string
    nom?: StringFilter<"CompanyTemplate"> | string
    contenu?: StringFilter<"CompanyTemplate"> | string
    variables?: JsonFilter<"CompanyTemplate">
    estDefaut?: BoolFilter<"CompanyTemplate"> | boolean
    estActif?: BoolFilter<"CompanyTemplate"> | boolean
    entrepriseId?: IntFilter<"CompanyTemplate"> | number
    creeLe?: DateTimeFilter<"CompanyTemplate"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyTemplate"> | Date | string
  }

  export type CompanySettingUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanySettingWhereUniqueInput
    update: XOR<CompanySettingUpdateWithoutEntrepriseInput, CompanySettingUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<CompanySettingCreateWithoutEntrepriseInput, CompanySettingUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanySettingUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanySettingWhereUniqueInput
    data: XOR<CompanySettingUpdateWithoutEntrepriseInput, CompanySettingUncheckedUpdateWithoutEntrepriseInput>
  }

  export type CompanySettingUpdateManyWithWhereWithoutEntrepriseInput = {
    where: CompanySettingScalarWhereInput
    data: XOR<CompanySettingUpdateManyMutationInput, CompanySettingUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type CompanySettingScalarWhereInput = {
    AND?: CompanySettingScalarWhereInput | CompanySettingScalarWhereInput[]
    OR?: CompanySettingScalarWhereInput[]
    NOT?: CompanySettingScalarWhereInput | CompanySettingScalarWhereInput[]
    id?: IntFilter<"CompanySetting"> | number
    cle?: StringFilter<"CompanySetting"> | string
    valeur?: StringFilter<"CompanySetting"> | string
    description?: StringNullableFilter<"CompanySetting"> | string | null
    typeData?: StringFilter<"CompanySetting"> | string
    estEncrypte?: BoolFilter<"CompanySetting"> | boolean
    entrepriseId?: IntFilter<"CompanySetting"> | number
    modifieLe?: DateTimeFilter<"CompanySetting"> | Date | string
  }

  export type CompanyModeleDocumentUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyModeleDocumentWhereUniqueInput
    update: XOR<CompanyModeleDocumentUpdateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<CompanyModeleDocumentCreateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyModeleDocumentUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyModeleDocumentWhereUniqueInput
    data: XOR<CompanyModeleDocumentUpdateWithoutEntrepriseInput, CompanyModeleDocumentUncheckedUpdateWithoutEntrepriseInput>
  }

  export type CompanyModeleDocumentUpdateManyWithWhereWithoutEntrepriseInput = {
    where: CompanyModeleDocumentScalarWhereInput
    data: XOR<CompanyModeleDocumentUpdateManyMutationInput, CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type CompanyPeriodePaieUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyPeriodePaieWhereUniqueInput
    update: XOR<CompanyPeriodePaieUpdateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<CompanyPeriodePaieCreateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyPeriodePaieUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyPeriodePaieWhereUniqueInput
    data: XOR<CompanyPeriodePaieUpdateWithoutEntrepriseInput, CompanyPeriodePaieUncheckedUpdateWithoutEntrepriseInput>
  }

  export type CompanyPeriodePaieUpdateManyWithWhereWithoutEntrepriseInput = {
    where: CompanyPeriodePaieScalarWhereInput
    data: XOR<CompanyPeriodePaieUpdateManyMutationInput, CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type CompanyPeriodePaieScalarWhereInput = {
    AND?: CompanyPeriodePaieScalarWhereInput | CompanyPeriodePaieScalarWhereInput[]
    OR?: CompanyPeriodePaieScalarWhereInput[]
    NOT?: CompanyPeriodePaieScalarWhereInput | CompanyPeriodePaieScalarWhereInput[]
    id?: IntFilter<"CompanyPeriodePaie"> | number
    nom?: StringFilter<"CompanyPeriodePaie"> | string
    dateDebut?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    dateFin?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    estCloturee?: BoolFilter<"CompanyPeriodePaie"> | boolean
    dateReglement?: DateTimeNullableFilter<"CompanyPeriodePaie"> | Date | string | null
    notes?: StringNullableFilter<"CompanyPeriodePaie"> | string | null
    metadata?: JsonNullableFilter<"CompanyPeriodePaie">
    entrepriseId?: IntFilter<"CompanyPeriodePaie"> | number
    creeLe?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyPeriodePaie"> | Date | string
  }

  export type CompanyConfigurationPaieUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyConfigurationPaieWhereUniqueInput
    update: XOR<CompanyConfigurationPaieUpdateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<CompanyConfigurationPaieCreateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedCreateWithoutEntrepriseInput>
  }

  export type CompanyConfigurationPaieUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: CompanyConfigurationPaieWhereUniqueInput
    data: XOR<CompanyConfigurationPaieUpdateWithoutEntrepriseInput, CompanyConfigurationPaieUncheckedUpdateWithoutEntrepriseInput>
  }

  export type CompanyConfigurationPaieUpdateManyWithWhereWithoutEntrepriseInput = {
    where: CompanyConfigurationPaieScalarWhereInput
    data: XOR<CompanyConfigurationPaieUpdateManyMutationInput, CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type CompanyConfigurationPaieScalarWhereInput = {
    AND?: CompanyConfigurationPaieScalarWhereInput | CompanyConfigurationPaieScalarWhereInput[]
    OR?: CompanyConfigurationPaieScalarWhereInput[]
    NOT?: CompanyConfigurationPaieScalarWhereInput | CompanyConfigurationPaieScalarWhereInput[]
    id?: IntFilter<"CompanyConfigurationPaie"> | number
    entrepriseId?: IntFilter<"CompanyConfigurationPaie"> | number
    jourPaie?: IntFilter<"CompanyConfigurationPaie"> | number
    periodeCalcul?: StringFilter<"CompanyConfigurationPaie"> | string
    regleArrondi?: StringFilter<"CompanyConfigurationPaie"> | string
    deviseSecondaire?: StringNullableFilter<"CompanyConfigurationPaie"> | string | null
    tauxChange?: DecimalNullableFilter<"CompanyConfigurationPaie"> | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonFilter<"CompanyConfigurationPaie">
    regleValidation?: JsonFilter<"CompanyConfigurationPaie">
    parametresCalcul?: JsonFilter<"CompanyConfigurationPaie">
    modifieLe?: DateTimeFilter<"CompanyConfigurationPaie"> | Date | string
  }

  export type ReglePointageUpsertWithoutEntrepriseInput = {
    update: XOR<ReglePointageUpdateWithoutEntrepriseInput, ReglePointageUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<ReglePointageCreateWithoutEntrepriseInput, ReglePointageUncheckedCreateWithoutEntrepriseInput>
    where?: ReglePointageWhereInput
  }

  export type ReglePointageUpdateToOneWithWhereWithoutEntrepriseInput = {
    where?: ReglePointageWhereInput
    data: XOR<ReglePointageUpdateWithoutEntrepriseInput, ReglePointageUncheckedUpdateWithoutEntrepriseInput>
  }

  export type ReglePointageUpdateWithoutEntrepriseInput = {
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    toleranceRetard?: IntFieldUpdateOperationsInput | number
    toleranceDepart?: IntFieldUpdateOperationsInput | number
    joursTravail?: JsonNullValueInput | InputJsonValue
    heuresParJour?: IntFieldUpdateOperationsInput | number
    heuresSupAutorise?: BoolFieldUpdateOperationsInput | boolean
    seuilHeuresSup?: IntFieldUpdateOperationsInput | number
    pauseDejeuner?: IntFieldUpdateOperationsInput | number
    estFlexible?: BoolFieldUpdateOperationsInput | boolean
    plageHoraireMin?: NullableStringFieldUpdateOperationsInput | string | null
    plageHoraireMax?: NullableStringFieldUpdateOperationsInput | string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReglePointageUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    toleranceRetard?: IntFieldUpdateOperationsInput | number
    toleranceDepart?: IntFieldUpdateOperationsInput | number
    joursTravail?: JsonNullValueInput | InputJsonValue
    heuresParJour?: IntFieldUpdateOperationsInput | number
    heuresSupAutorise?: BoolFieldUpdateOperationsInput | boolean
    seuilHeuresSup?: IntFieldUpdateOperationsInput | number
    pauseDejeuner?: IntFieldUpdateOperationsInput | number
    estFlexible?: BoolFieldUpdateOperationsInput | boolean
    plageHoraireMin?: NullableStringFieldUpdateOperationsInput | string | null
    plageHoraireMax?: NullableStringFieldUpdateOperationsInput | string | null
    joursFeries?: NullableJsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutJournalAuditInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutJournalAuditInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutJournalAuditInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJournalAuditInput, UserUncheckedCreateWithoutJournalAuditInput>
  }

  export type UserUpsertWithoutJournalAuditInput = {
    update: XOR<UserUpdateWithoutJournalAuditInput, UserUncheckedUpdateWithoutJournalAuditInput>
    create: XOR<UserCreateWithoutJournalAuditInput, UserUncheckedCreateWithoutJournalAuditInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJournalAuditInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJournalAuditInput, UserUncheckedUpdateWithoutJournalAuditInput>
  }

  export type UserUpdateWithoutJournalAuditInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutJournalAuditInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type EmployeeCreateWithoutPaymentsInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutPaymentsInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutPaymentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPaymentsInput, EmployeeUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutProcessedPaymentsInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutProcessedPaymentsInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutProcessedPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
  }

  export type EmployeeUpsertWithoutPaymentsInput = {
    update: XOR<EmployeeUpdateWithoutPaymentsInput, EmployeeUncheckedUpdateWithoutPaymentsInput>
    create: XOR<EmployeeCreateWithoutPaymentsInput, EmployeeUncheckedCreateWithoutPaymentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPaymentsInput, EmployeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type EmployeeUpdateWithoutPaymentsInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type UserUpsertWithoutProcessedPaymentsInput = {
    update: XOR<UserUpdateWithoutProcessedPaymentsInput, UserUncheckedUpdateWithoutProcessedPaymentsInput>
    create: XOR<UserCreateWithoutProcessedPaymentsInput, UserUncheckedCreateWithoutProcessedPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessedPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessedPaymentsInput, UserUncheckedUpdateWithoutProcessedPaymentsInput>
  }

  export type UserUpdateWithoutProcessedPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessedPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type EmployeeCreateWithoutFacturesInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutFacturesInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutFacturesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutFacturesInput, EmployeeUncheckedCreateWithoutFacturesInput>
  }

  export type UserCreateWithoutCreatedFacturesInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutCreatedFacturesInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutCreatedFacturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedFacturesInput, UserUncheckedCreateWithoutCreatedFacturesInput>
  }

  export type CompanyLigneFactureCreateWithoutFactureInput = {
    description: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    prixTotal: Decimal | DecimalJsLike | number | string
    creeLe?: Date | string
  }

  export type CompanyLigneFactureUncheckedCreateWithoutFactureInput = {
    id?: number
    description: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    prixTotal: Decimal | DecimalJsLike | number | string
    creeLe?: Date | string
  }

  export type CompanyLigneFactureCreateOrConnectWithoutFactureInput = {
    where: CompanyLigneFactureWhereUniqueInput
    create: XOR<CompanyLigneFactureCreateWithoutFactureInput, CompanyLigneFactureUncheckedCreateWithoutFactureInput>
  }

  export type CompanyLigneFactureCreateManyFactureInputEnvelope = {
    data: CompanyLigneFactureCreateManyFactureInput | CompanyLigneFactureCreateManyFactureInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithoutFacturesInput = {
    update: XOR<EmployeeUpdateWithoutFacturesInput, EmployeeUncheckedUpdateWithoutFacturesInput>
    create: XOR<EmployeeCreateWithoutFacturesInput, EmployeeUncheckedCreateWithoutFacturesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutFacturesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutFacturesInput, EmployeeUncheckedUpdateWithoutFacturesInput>
  }

  export type EmployeeUpdateWithoutFacturesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutFacturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type UserUpsertWithoutCreatedFacturesInput = {
    update: XOR<UserUpdateWithoutCreatedFacturesInput, UserUncheckedUpdateWithoutCreatedFacturesInput>
    create: XOR<UserCreateWithoutCreatedFacturesInput, UserUncheckedCreateWithoutCreatedFacturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedFacturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedFacturesInput, UserUncheckedUpdateWithoutCreatedFacturesInput>
  }

  export type UserUpdateWithoutCreatedFacturesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedFacturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type CompanyLigneFactureUpsertWithWhereUniqueWithoutFactureInput = {
    where: CompanyLigneFactureWhereUniqueInput
    update: XOR<CompanyLigneFactureUpdateWithoutFactureInput, CompanyLigneFactureUncheckedUpdateWithoutFactureInput>
    create: XOR<CompanyLigneFactureCreateWithoutFactureInput, CompanyLigneFactureUncheckedCreateWithoutFactureInput>
  }

  export type CompanyLigneFactureUpdateWithWhereUniqueWithoutFactureInput = {
    where: CompanyLigneFactureWhereUniqueInput
    data: XOR<CompanyLigneFactureUpdateWithoutFactureInput, CompanyLigneFactureUncheckedUpdateWithoutFactureInput>
  }

  export type CompanyLigneFactureUpdateManyWithWhereWithoutFactureInput = {
    where: CompanyLigneFactureScalarWhereInput
    data: XOR<CompanyLigneFactureUpdateManyMutationInput, CompanyLigneFactureUncheckedUpdateManyWithoutFactureInput>
  }

  export type CompanyLigneFactureScalarWhereInput = {
    AND?: CompanyLigneFactureScalarWhereInput | CompanyLigneFactureScalarWhereInput[]
    OR?: CompanyLigneFactureScalarWhereInput[]
    NOT?: CompanyLigneFactureScalarWhereInput | CompanyLigneFactureScalarWhereInput[]
    id?: IntFilter<"CompanyLigneFacture"> | number
    factureId?: IntFilter<"CompanyLigneFacture"> | number
    description?: StringFilter<"CompanyLigneFacture"> | string
    quantite?: IntFilter<"CompanyLigneFacture"> | number
    prixUnitaire?: DecimalFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFilter<"CompanyLigneFacture"> | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFilter<"CompanyLigneFacture"> | Date | string
  }

  export type CompanyFactureCreateWithoutLignesFactureInput = {
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutFacturesInput
    creator: UserCreateNestedOneWithoutCreatedFacturesInput
  }

  export type CompanyFactureUncheckedCreateWithoutLignesFactureInput = {
    id?: number
    employeeId: number
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyFactureCreateOrConnectWithoutLignesFactureInput = {
    where: CompanyFactureWhereUniqueInput
    create: XOR<CompanyFactureCreateWithoutLignesFactureInput, CompanyFactureUncheckedCreateWithoutLignesFactureInput>
  }

  export type CompanyFactureUpsertWithoutLignesFactureInput = {
    update: XOR<CompanyFactureUpdateWithoutLignesFactureInput, CompanyFactureUncheckedUpdateWithoutLignesFactureInput>
    create: XOR<CompanyFactureCreateWithoutLignesFactureInput, CompanyFactureUncheckedCreateWithoutLignesFactureInput>
    where?: CompanyFactureWhereInput
  }

  export type CompanyFactureUpdateToOneWithWhereWithoutLignesFactureInput = {
    where?: CompanyFactureWhereInput
    data: XOR<CompanyFactureUpdateWithoutLignesFactureInput, CompanyFactureUncheckedUpdateWithoutLignesFactureInput>
  }

  export type CompanyFactureUpdateWithoutLignesFactureInput = {
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutFacturesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedFacturesNestedInput
  }

  export type CompanyFactureUncheckedUpdateWithoutLignesFactureInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntrepriseCreateWithoutPayRunsInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutPayRunsInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutPayRunsInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutPayRunsInput, EntrepriseUncheckedCreateWithoutPayRunsInput>
  }

  export type CompanyPeriodePaieCreateWithoutPayRunsInput = {
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutPeriodesPaieInput
  }

  export type CompanyPeriodePaieUncheckedCreateWithoutPayRunsInput = {
    id?: number
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyPeriodePaieCreateOrConnectWithoutPayRunsInput = {
    where: CompanyPeriodePaieWhereUniqueInput
    create: XOR<CompanyPeriodePaieCreateWithoutPayRunsInput, CompanyPeriodePaieUncheckedCreateWithoutPayRunsInput>
  }

  export type UserCreateWithoutCreatedPayRunsInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutCreatedPayRunsInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutCreatedPayRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPayRunsInput, UserUncheckedCreateWithoutCreatedPayRunsInput>
  }

  export type UserCreateWithoutApprovedPayRunsInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutApprovedPayRunsInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutApprovedPayRunsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedPayRunsInput, UserUncheckedCreateWithoutApprovedPayRunsInput>
  }

  export type CompanyBulletinCreateWithoutPayRunInput = {
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
    employee: EmployeeCreateNestedOneWithoutBulletinsInput
    paiements?: CompanyPaiementCreateNestedManyWithoutBulletinInput
  }

  export type CompanyBulletinUncheckedCreateWithoutPayRunInput = {
    id?: number
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    employeId: number
    creeLe?: Date | string
    modifieLe?: Date | string
    paiements?: CompanyPaiementUncheckedCreateNestedManyWithoutBulletinInput
  }

  export type CompanyBulletinCreateOrConnectWithoutPayRunInput = {
    where: CompanyBulletinWhereUniqueInput
    create: XOR<CompanyBulletinCreateWithoutPayRunInput, CompanyBulletinUncheckedCreateWithoutPayRunInput>
  }

  export type CompanyBulletinCreateManyPayRunInputEnvelope = {
    data: CompanyBulletinCreateManyPayRunInput | CompanyBulletinCreateManyPayRunInput[]
    skipDuplicates?: boolean
  }

  export type EntrepriseUpsertWithoutPayRunsInput = {
    update: XOR<EntrepriseUpdateWithoutPayRunsInput, EntrepriseUncheckedUpdateWithoutPayRunsInput>
    create: XOR<EntrepriseCreateWithoutPayRunsInput, EntrepriseUncheckedCreateWithoutPayRunsInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutPayRunsInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutPayRunsInput, EntrepriseUncheckedUpdateWithoutPayRunsInput>
  }

  export type EntrepriseUpdateWithoutPayRunsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutPayRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type CompanyPeriodePaieUpsertWithoutPayRunsInput = {
    update: XOR<CompanyPeriodePaieUpdateWithoutPayRunsInput, CompanyPeriodePaieUncheckedUpdateWithoutPayRunsInput>
    create: XOR<CompanyPeriodePaieCreateWithoutPayRunsInput, CompanyPeriodePaieUncheckedCreateWithoutPayRunsInput>
    where?: CompanyPeriodePaieWhereInput
  }

  export type CompanyPeriodePaieUpdateToOneWithWhereWithoutPayRunsInput = {
    where?: CompanyPeriodePaieWhereInput
    data: XOR<CompanyPeriodePaieUpdateWithoutPayRunsInput, CompanyPeriodePaieUncheckedUpdateWithoutPayRunsInput>
  }

  export type CompanyPeriodePaieUpdateWithoutPayRunsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutPeriodesPaieNestedInput
  }

  export type CompanyPeriodePaieUncheckedUpdateWithoutPayRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedPayRunsInput = {
    update: XOR<UserUpdateWithoutCreatedPayRunsInput, UserUncheckedUpdateWithoutCreatedPayRunsInput>
    create: XOR<UserCreateWithoutCreatedPayRunsInput, UserUncheckedCreateWithoutCreatedPayRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPayRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPayRunsInput, UserUncheckedUpdateWithoutCreatedPayRunsInput>
  }

  export type UserUpdateWithoutCreatedPayRunsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPayRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUpsertWithoutApprovedPayRunsInput = {
    update: XOR<UserUpdateWithoutApprovedPayRunsInput, UserUncheckedUpdateWithoutApprovedPayRunsInput>
    create: XOR<UserCreateWithoutApprovedPayRunsInput, UserUncheckedCreateWithoutApprovedPayRunsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedPayRunsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedPayRunsInput, UserUncheckedUpdateWithoutApprovedPayRunsInput>
  }

  export type UserUpdateWithoutApprovedPayRunsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedPayRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type CompanyBulletinUpsertWithWhereUniqueWithoutPayRunInput = {
    where: CompanyBulletinWhereUniqueInput
    update: XOR<CompanyBulletinUpdateWithoutPayRunInput, CompanyBulletinUncheckedUpdateWithoutPayRunInput>
    create: XOR<CompanyBulletinCreateWithoutPayRunInput, CompanyBulletinUncheckedCreateWithoutPayRunInput>
  }

  export type CompanyBulletinUpdateWithWhereUniqueWithoutPayRunInput = {
    where: CompanyBulletinWhereUniqueInput
    data: XOR<CompanyBulletinUpdateWithoutPayRunInput, CompanyBulletinUncheckedUpdateWithoutPayRunInput>
  }

  export type CompanyBulletinUpdateManyWithWhereWithoutPayRunInput = {
    where: CompanyBulletinScalarWhereInput
    data: XOR<CompanyBulletinUpdateManyMutationInput, CompanyBulletinUncheckedUpdateManyWithoutPayRunInput>
  }

  export type CompanyPayRunCreateWithoutBulletinsInput = {
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    approuveLe?: Date | string | null
    entreprise: EntrepriseCreateNestedOneWithoutPayRunsInput
    periodePaie: CompanyPeriodePaieCreateNestedOneWithoutPayRunsInput
    creator: UserCreateNestedOneWithoutCreatedPayRunsInput
    approver?: UserCreateNestedOneWithoutApprovedPayRunsInput
  }

  export type CompanyPayRunUncheckedCreateWithoutBulletinsInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    periodePaieId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
  }

  export type CompanyPayRunCreateOrConnectWithoutBulletinsInput = {
    where: CompanyPayRunWhereUniqueInput
    create: XOR<CompanyPayRunCreateWithoutBulletinsInput, CompanyPayRunUncheckedCreateWithoutBulletinsInput>
  }

  export type EmployeeCreateWithoutBulletinsInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutBulletinsInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutBulletinsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutBulletinsInput, EmployeeUncheckedCreateWithoutBulletinsInput>
  }

  export type CompanyPaiementCreateWithoutBulletinInput = {
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    processor: UserCreateNestedOneWithoutProcessedPaymentsCompanyInput
  }

  export type CompanyPaiementUncheckedCreateWithoutBulletinInput = {
    id?: number
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    traitePar: number
    creeLe?: Date | string
  }

  export type CompanyPaiementCreateOrConnectWithoutBulletinInput = {
    where: CompanyPaiementWhereUniqueInput
    create: XOR<CompanyPaiementCreateWithoutBulletinInput, CompanyPaiementUncheckedCreateWithoutBulletinInput>
  }

  export type CompanyPaiementCreateManyBulletinInputEnvelope = {
    data: CompanyPaiementCreateManyBulletinInput | CompanyPaiementCreateManyBulletinInput[]
    skipDuplicates?: boolean
  }

  export type CompanyPayRunUpsertWithoutBulletinsInput = {
    update: XOR<CompanyPayRunUpdateWithoutBulletinsInput, CompanyPayRunUncheckedUpdateWithoutBulletinsInput>
    create: XOR<CompanyPayRunCreateWithoutBulletinsInput, CompanyPayRunUncheckedCreateWithoutBulletinsInput>
    where?: CompanyPayRunWhereInput
  }

  export type CompanyPayRunUpdateToOneWithWhereWithoutBulletinsInput = {
    where?: CompanyPayRunWhereInput
    data: XOR<CompanyPayRunUpdateWithoutBulletinsInput, CompanyPayRunUncheckedUpdateWithoutBulletinsInput>
  }

  export type CompanyPayRunUpdateWithoutBulletinsInput = {
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entreprise?: EntrepriseUpdateOneRequiredWithoutPayRunsNestedInput
    periodePaie?: CompanyPeriodePaieUpdateOneRequiredWithoutPayRunsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPayRunsNestedInput
    approver?: UserUpdateOneWithoutApprovedPayRunsNestedInput
  }

  export type CompanyPayRunUncheckedUpdateWithoutBulletinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmployeeUpsertWithoutBulletinsInput = {
    update: XOR<EmployeeUpdateWithoutBulletinsInput, EmployeeUncheckedUpdateWithoutBulletinsInput>
    create: XOR<EmployeeCreateWithoutBulletinsInput, EmployeeUncheckedCreateWithoutBulletinsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutBulletinsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutBulletinsInput, EmployeeUncheckedUpdateWithoutBulletinsInput>
  }

  export type EmployeeUpdateWithoutBulletinsInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutBulletinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type CompanyPaiementUpsertWithWhereUniqueWithoutBulletinInput = {
    where: CompanyPaiementWhereUniqueInput
    update: XOR<CompanyPaiementUpdateWithoutBulletinInput, CompanyPaiementUncheckedUpdateWithoutBulletinInput>
    create: XOR<CompanyPaiementCreateWithoutBulletinInput, CompanyPaiementUncheckedCreateWithoutBulletinInput>
  }

  export type CompanyPaiementUpdateWithWhereUniqueWithoutBulletinInput = {
    where: CompanyPaiementWhereUniqueInput
    data: XOR<CompanyPaiementUpdateWithoutBulletinInput, CompanyPaiementUncheckedUpdateWithoutBulletinInput>
  }

  export type CompanyPaiementUpdateManyWithWhereWithoutBulletinInput = {
    where: CompanyPaiementScalarWhereInput
    data: XOR<CompanyPaiementUpdateManyMutationInput, CompanyPaiementUncheckedUpdateManyWithoutBulletinInput>
  }

  export type CompanyBulletinCreateWithoutPaiementsInput = {
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
    payRun: CompanyPayRunCreateNestedOneWithoutBulletinsInput
    employee: EmployeeCreateNestedOneWithoutBulletinsInput
  }

  export type CompanyBulletinUncheckedCreateWithoutPaiementsInput = {
    id?: number
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    payRunId: number
    employeId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyBulletinCreateOrConnectWithoutPaiementsInput = {
    where: CompanyBulletinWhereUniqueInput
    create: XOR<CompanyBulletinCreateWithoutPaiementsInput, CompanyBulletinUncheckedCreateWithoutPaiementsInput>
  }

  export type UserCreateWithoutProcessedPaymentsCompanyInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutProcessedPaymentsCompanyInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutProcessedPaymentsCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProcessedPaymentsCompanyInput, UserUncheckedCreateWithoutProcessedPaymentsCompanyInput>
  }

  export type CompanyBulletinUpsertWithoutPaiementsInput = {
    update: XOR<CompanyBulletinUpdateWithoutPaiementsInput, CompanyBulletinUncheckedUpdateWithoutPaiementsInput>
    create: XOR<CompanyBulletinCreateWithoutPaiementsInput, CompanyBulletinUncheckedCreateWithoutPaiementsInput>
    where?: CompanyBulletinWhereInput
  }

  export type CompanyBulletinUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: CompanyBulletinWhereInput
    data: XOR<CompanyBulletinUpdateWithoutPaiementsInput, CompanyBulletinUncheckedUpdateWithoutPaiementsInput>
  }

  export type CompanyBulletinUpdateWithoutPaiementsInput = {
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRun?: CompanyPayRunUpdateOneRequiredWithoutBulletinsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutBulletinsNestedInput
  }

  export type CompanyBulletinUncheckedUpdateWithoutPaiementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    payRunId?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutProcessedPaymentsCompanyInput = {
    update: XOR<UserUpdateWithoutProcessedPaymentsCompanyInput, UserUncheckedUpdateWithoutProcessedPaymentsCompanyInput>
    create: XOR<UserCreateWithoutProcessedPaymentsCompanyInput, UserUncheckedCreateWithoutProcessedPaymentsCompanyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProcessedPaymentsCompanyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProcessedPaymentsCompanyInput, UserUncheckedUpdateWithoutProcessedPaymentsCompanyInput>
  }

  export type UserUpdateWithoutProcessedPaymentsCompanyInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutProcessedPaymentsCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type EntrepriseCreateWithoutTemplatesInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutTemplatesInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutTemplatesInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutTemplatesInput, EntrepriseUncheckedCreateWithoutTemplatesInput>
  }

  export type EntrepriseUpsertWithoutTemplatesInput = {
    update: XOR<EntrepriseUpdateWithoutTemplatesInput, EntrepriseUncheckedUpdateWithoutTemplatesInput>
    create: XOR<EntrepriseCreateWithoutTemplatesInput, EntrepriseUncheckedCreateWithoutTemplatesInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutTemplatesInput, EntrepriseUncheckedUpdateWithoutTemplatesInput>
  }

  export type EntrepriseUpdateWithoutTemplatesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutTemplatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseCreateWithoutSettingsInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutSettingsInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutSettingsInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutSettingsInput, EntrepriseUncheckedCreateWithoutSettingsInput>
  }

  export type EntrepriseUpsertWithoutSettingsInput = {
    update: XOR<EntrepriseUpdateWithoutSettingsInput, EntrepriseUncheckedUpdateWithoutSettingsInput>
    create: XOR<EntrepriseCreateWithoutSettingsInput, EntrepriseUncheckedCreateWithoutSettingsInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutSettingsInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutSettingsInput, EntrepriseUncheckedUpdateWithoutSettingsInput>
  }

  export type EntrepriseUpdateWithoutSettingsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type EmployeeCreateWithoutDocumentsInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutDocumentsInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutDocumentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedDocumentsInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutUploadedDocumentsInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutUploadedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type EmployeeUpsertWithoutDocumentsInput = {
    update: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeUpdateWithoutDocumentsInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type UserUpsertWithoutUploadedDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDocumentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type EntrepriseCreateWithoutModelesInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutModelesInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutModelesInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutModelesInput, EntrepriseUncheckedCreateWithoutModelesInput>
  }

  export type UserCreateWithoutCreatedModelesInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutCreatedModelesInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutCreatedModelesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedModelesInput, UserUncheckedCreateWithoutCreatedModelesInput>
  }

  export type EntrepriseUpsertWithoutModelesInput = {
    update: XOR<EntrepriseUpdateWithoutModelesInput, EntrepriseUncheckedUpdateWithoutModelesInput>
    create: XOR<EntrepriseCreateWithoutModelesInput, EntrepriseUncheckedCreateWithoutModelesInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutModelesInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutModelesInput, EntrepriseUncheckedUpdateWithoutModelesInput>
  }

  export type EntrepriseUpdateWithoutModelesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutModelesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type UserUpsertWithoutCreatedModelesInput = {
    update: XOR<UserUpdateWithoutCreatedModelesInput, UserUncheckedUpdateWithoutCreatedModelesInput>
    create: XOR<UserCreateWithoutCreatedModelesInput, UserUncheckedCreateWithoutCreatedModelesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedModelesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedModelesInput, UserUncheckedUpdateWithoutCreatedModelesInput>
  }

  export type UserUpdateWithoutCreatedModelesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedModelesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type EntrepriseCreateWithoutPeriodesPaieInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutPeriodesPaieInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutPeriodesPaieInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutPeriodesPaieInput, EntrepriseUncheckedCreateWithoutPeriodesPaieInput>
  }

  export type CompanyPayRunCreateWithoutPeriodePaieInput = {
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    approuveLe?: Date | string | null
    entreprise: EntrepriseCreateNestedOneWithoutPayRunsInput
    creator: UserCreateNestedOneWithoutCreatedPayRunsInput
    approver?: UserCreateNestedOneWithoutApprovedPayRunsInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunUncheckedCreateWithoutPeriodePaieInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutPayRunInput
  }

  export type CompanyPayRunCreateOrConnectWithoutPeriodePaieInput = {
    where: CompanyPayRunWhereUniqueInput
    create: XOR<CompanyPayRunCreateWithoutPeriodePaieInput, CompanyPayRunUncheckedCreateWithoutPeriodePaieInput>
  }

  export type CompanyPayRunCreateManyPeriodePaieInputEnvelope = {
    data: CompanyPayRunCreateManyPeriodePaieInput | CompanyPayRunCreateManyPeriodePaieInput[]
    skipDuplicates?: boolean
  }

  export type EntrepriseUpsertWithoutPeriodesPaieInput = {
    update: XOR<EntrepriseUpdateWithoutPeriodesPaieInput, EntrepriseUncheckedUpdateWithoutPeriodesPaieInput>
    create: XOR<EntrepriseCreateWithoutPeriodesPaieInput, EntrepriseUncheckedCreateWithoutPeriodesPaieInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutPeriodesPaieInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutPeriodesPaieInput, EntrepriseUncheckedUpdateWithoutPeriodesPaieInput>
  }

  export type EntrepriseUpdateWithoutPeriodesPaieInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutPeriodesPaieInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type CompanyPayRunUpsertWithWhereUniqueWithoutPeriodePaieInput = {
    where: CompanyPayRunWhereUniqueInput
    update: XOR<CompanyPayRunUpdateWithoutPeriodePaieInput, CompanyPayRunUncheckedUpdateWithoutPeriodePaieInput>
    create: XOR<CompanyPayRunCreateWithoutPeriodePaieInput, CompanyPayRunUncheckedCreateWithoutPeriodePaieInput>
  }

  export type CompanyPayRunUpdateWithWhereUniqueWithoutPeriodePaieInput = {
    where: CompanyPayRunWhereUniqueInput
    data: XOR<CompanyPayRunUpdateWithoutPeriodePaieInput, CompanyPayRunUncheckedUpdateWithoutPeriodePaieInput>
  }

  export type CompanyPayRunUpdateManyWithWhereWithoutPeriodePaieInput = {
    where: CompanyPayRunScalarWhereInput
    data: XOR<CompanyPayRunUpdateManyMutationInput, CompanyPayRunUncheckedUpdateManyWithoutPeriodePaieInput>
  }

  export type EntrepriseCreateWithoutConfigurationsPaieInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutConfigurationsPaieInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    reglePointage?: ReglePointageUncheckedCreateNestedOneWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutConfigurationsPaieInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutConfigurationsPaieInput, EntrepriseUncheckedCreateWithoutConfigurationsPaieInput>
  }

  export type CompanyRegleDeductionCreateWithoutConfigurationInput = {
    nom: string
    description?: string | null
    type: string
    formule: string
    conditionsApplication: JsonNullValueInput | InputJsonValue
    estObligatoire?: boolean
    ordre: number
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    formule: string
    conditionsApplication: JsonNullValueInput | InputJsonValue
    estObligatoire?: boolean
    ordre: number
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyRegleDeductionCreateOrConnectWithoutConfigurationInput = {
    where: CompanyRegleDeductionWhereUniqueInput
    create: XOR<CompanyRegleDeductionCreateWithoutConfigurationInput, CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput>
  }

  export type CompanyRegleDeductionCreateManyConfigurationInputEnvelope = {
    data: CompanyRegleDeductionCreateManyConfigurationInput | CompanyRegleDeductionCreateManyConfigurationInput[]
    skipDuplicates?: boolean
  }

  export type EntrepriseUpsertWithoutConfigurationsPaieInput = {
    update: XOR<EntrepriseUpdateWithoutConfigurationsPaieInput, EntrepriseUncheckedUpdateWithoutConfigurationsPaieInput>
    create: XOR<EntrepriseCreateWithoutConfigurationsPaieInput, EntrepriseUncheckedCreateWithoutConfigurationsPaieInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutConfigurationsPaieInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutConfigurationsPaieInput, EntrepriseUncheckedUpdateWithoutConfigurationsPaieInput>
  }

  export type EntrepriseUpdateWithoutConfigurationsPaieInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUpdateOneWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutConfigurationsPaieInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    reglePointage?: ReglePointageUncheckedUpdateOneWithoutEntrepriseNestedInput
  }

  export type CompanyRegleDeductionUpsertWithWhereUniqueWithoutConfigurationInput = {
    where: CompanyRegleDeductionWhereUniqueInput
    update: XOR<CompanyRegleDeductionUpdateWithoutConfigurationInput, CompanyRegleDeductionUncheckedUpdateWithoutConfigurationInput>
    create: XOR<CompanyRegleDeductionCreateWithoutConfigurationInput, CompanyRegleDeductionUncheckedCreateWithoutConfigurationInput>
  }

  export type CompanyRegleDeductionUpdateWithWhereUniqueWithoutConfigurationInput = {
    where: CompanyRegleDeductionWhereUniqueInput
    data: XOR<CompanyRegleDeductionUpdateWithoutConfigurationInput, CompanyRegleDeductionUncheckedUpdateWithoutConfigurationInput>
  }

  export type CompanyRegleDeductionUpdateManyWithWhereWithoutConfigurationInput = {
    where: CompanyRegleDeductionScalarWhereInput
    data: XOR<CompanyRegleDeductionUpdateManyMutationInput, CompanyRegleDeductionUncheckedUpdateManyWithoutConfigurationInput>
  }

  export type CompanyRegleDeductionScalarWhereInput = {
    AND?: CompanyRegleDeductionScalarWhereInput | CompanyRegleDeductionScalarWhereInput[]
    OR?: CompanyRegleDeductionScalarWhereInput[]
    NOT?: CompanyRegleDeductionScalarWhereInput | CompanyRegleDeductionScalarWhereInput[]
    id?: IntFilter<"CompanyRegleDeduction"> | number
    nom?: StringFilter<"CompanyRegleDeduction"> | string
    description?: StringNullableFilter<"CompanyRegleDeduction"> | string | null
    type?: StringFilter<"CompanyRegleDeduction"> | string
    formule?: StringFilter<"CompanyRegleDeduction"> | string
    conditionsApplication?: JsonFilter<"CompanyRegleDeduction">
    estObligatoire?: BoolFilter<"CompanyRegleDeduction"> | boolean
    ordre?: IntFilter<"CompanyRegleDeduction"> | number
    configurationId?: IntFilter<"CompanyRegleDeduction"> | number
    estActif?: BoolFilter<"CompanyRegleDeduction"> | boolean
    creeLe?: DateTimeFilter<"CompanyRegleDeduction"> | Date | string
    modifieLe?: DateTimeFilter<"CompanyRegleDeduction"> | Date | string
  }

  export type EmployeeCreateWithoutSalaryHistoryInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutSalaryHistoryInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutSalaryHistoryInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSalaryHistoryInput, EmployeeUncheckedCreateWithoutSalaryHistoryInput>
  }

  export type UserCreateWithoutModifiedSalariesInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutModifiedSalariesInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutModifiedSalariesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModifiedSalariesInput, UserUncheckedCreateWithoutModifiedSalariesInput>
  }

  export type EmployeeUpsertWithoutSalaryHistoryInput = {
    update: XOR<EmployeeUpdateWithoutSalaryHistoryInput, EmployeeUncheckedUpdateWithoutSalaryHistoryInput>
    create: XOR<EmployeeCreateWithoutSalaryHistoryInput, EmployeeUncheckedCreateWithoutSalaryHistoryInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSalaryHistoryInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSalaryHistoryInput, EmployeeUncheckedUpdateWithoutSalaryHistoryInput>
  }

  export type EmployeeUpdateWithoutSalaryHistoryInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSalaryHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type UserUpsertWithoutModifiedSalariesInput = {
    update: XOR<UserUpdateWithoutModifiedSalariesInput, UserUncheckedUpdateWithoutModifiedSalariesInput>
    create: XOR<UserCreateWithoutModifiedSalariesInput, UserUncheckedCreateWithoutModifiedSalariesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModifiedSalariesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModifiedSalariesInput, UserUncheckedUpdateWithoutModifiedSalariesInput>
  }

  export type UserUpdateWithoutModifiedSalariesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutModifiedSalariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type CompanyConfigurationPaieCreateWithoutReglesDeductionInput = {
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
    entreprise: EntrepriseCreateNestedOneWithoutConfigurationsPaieInput
  }

  export type CompanyConfigurationPaieUncheckedCreateWithoutReglesDeductionInput = {
    id?: number
    entrepriseId: number
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
  }

  export type CompanyConfigurationPaieCreateOrConnectWithoutReglesDeductionInput = {
    where: CompanyConfigurationPaieWhereUniqueInput
    create: XOR<CompanyConfigurationPaieCreateWithoutReglesDeductionInput, CompanyConfigurationPaieUncheckedCreateWithoutReglesDeductionInput>
  }

  export type CompanyConfigurationPaieUpsertWithoutReglesDeductionInput = {
    update: XOR<CompanyConfigurationPaieUpdateWithoutReglesDeductionInput, CompanyConfigurationPaieUncheckedUpdateWithoutReglesDeductionInput>
    create: XOR<CompanyConfigurationPaieCreateWithoutReglesDeductionInput, CompanyConfigurationPaieUncheckedCreateWithoutReglesDeductionInput>
    where?: CompanyConfigurationPaieWhereInput
  }

  export type CompanyConfigurationPaieUpdateToOneWithWhereWithoutReglesDeductionInput = {
    where?: CompanyConfigurationPaieWhereInput
    data: XOR<CompanyConfigurationPaieUpdateWithoutReglesDeductionInput, CompanyConfigurationPaieUncheckedUpdateWithoutReglesDeductionInput>
  }

  export type CompanyConfigurationPaieUpdateWithoutReglesDeductionInput = {
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutConfigurationsPaieNestedInput
  }

  export type CompanyConfigurationPaieUncheckedUpdateWithoutReglesDeductionInput = {
    id?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateWithoutPointagesInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutPointagesInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    absences?: AbsenceUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutPointagesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPointagesInput, EmployeeUncheckedCreateWithoutPointagesInput>
  }

  export type UserCreateWithoutValidatedPointagesInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    approvedAbsences?: AbsenceCreateNestedManyWithoutApprobateurInput
  }

  export type UserUncheckedCreateWithoutValidatedPointagesInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    approvedAbsences?: AbsenceUncheckedCreateNestedManyWithoutApprobateurInput
  }

  export type UserCreateOrConnectWithoutValidatedPointagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutValidatedPointagesInput, UserUncheckedCreateWithoutValidatedPointagesInput>
  }

  export type EmployeeUpsertWithoutPointagesInput = {
    update: XOR<EmployeeUpdateWithoutPointagesInput, EmployeeUncheckedUpdateWithoutPointagesInput>
    create: XOR<EmployeeCreateWithoutPointagesInput, EmployeeUncheckedCreateWithoutPointagesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPointagesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPointagesInput, EmployeeUncheckedUpdateWithoutPointagesInput>
  }

  export type EmployeeUpdateWithoutPointagesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPointagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type UserUpsertWithoutValidatedPointagesInput = {
    update: XOR<UserUpdateWithoutValidatedPointagesInput, UserUncheckedUpdateWithoutValidatedPointagesInput>
    create: XOR<UserCreateWithoutValidatedPointagesInput, UserUncheckedCreateWithoutValidatedPointagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutValidatedPointagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutValidatedPointagesInput, UserUncheckedUpdateWithoutValidatedPointagesInput>
  }

  export type UserUpdateWithoutValidatedPointagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    approvedAbsences?: AbsenceUpdateManyWithoutApprobateurNestedInput
  }

  export type UserUncheckedUpdateWithoutValidatedPointagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    approvedAbsences?: AbsenceUncheckedUpdateManyWithoutApprobateurNestedInput
  }

  export type EntrepriseCreateWithoutReglePointageInput = {
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutReglePointageInput = {
    id?: number
    nom: string
    adresse?: string | null
    telephone?: string | null
    email?: string | null
    siteWeb?: string | null
    logo?: string | null
    couleurPrimaire?: string | null
    couleurSecondaire?: string | null
    couleurDashboard?: string | null
    description?: string | null
    devise?: string
    timezone?: string
    periodePayroll?: string
    estActive?: boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEntrepriseInput
    payRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutEntrepriseInput
    templates?: CompanyTemplateUncheckedCreateNestedManyWithoutEntrepriseInput
    settings?: CompanySettingUncheckedCreateNestedManyWithoutEntrepriseInput
    modeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutEntrepriseInput
    periodesPaie?: CompanyPeriodePaieUncheckedCreateNestedManyWithoutEntrepriseInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutReglePointageInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutReglePointageInput, EntrepriseUncheckedCreateWithoutReglePointageInput>
  }

  export type EntrepriseUpsertWithoutReglePointageInput = {
    update: XOR<EntrepriseUpdateWithoutReglePointageInput, EntrepriseUncheckedUpdateWithoutReglePointageInput>
    create: XOR<EntrepriseCreateWithoutReglePointageInput, EntrepriseUncheckedCreateWithoutReglePointageInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutReglePointageInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutReglePointageInput, EntrepriseUncheckedUpdateWithoutReglePointageInput>
  }

  export type EntrepriseUpdateWithoutReglePointageInput = {
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUpdateManyWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutReglePointageInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    siteWeb?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    couleurPrimaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    couleurDashboard?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    devise?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    periodePayroll?: StringFieldUpdateOperationsInput | string
    estActive?: BoolFieldUpdateOperationsInput | boolean
    parametres?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutEntrepriseNestedInput
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutEntrepriseNestedInput
    templates?: CompanyTemplateUncheckedUpdateManyWithoutEntrepriseNestedInput
    settings?: CompanySettingUncheckedUpdateManyWithoutEntrepriseNestedInput
    modeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseNestedInput
    periodesPaie?: CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseNestedInput
    configurationsPaie?: CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type EmployeeCreateWithoutAbsencesInput = {
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
    entreprise: EntrepriseCreateNestedOneWithoutEmployeesInput
    payments?: PaymentCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireCreateNestedManyWithoutEmployeeInput
    pointages?: PointageCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeUncheckedCreateWithoutAbsencesInput = {
    id?: number
    userId: number
    entrepriseId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutEmployeeInput
    factures?: CompanyFactureUncheckedCreateNestedManyWithoutEmployeeInput
    bulletins?: CompanyBulletinUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: CompanyDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutEmployeeInput
    pointages?: PointageUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeeCreateOrConnectWithoutAbsencesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
  }

  export type UserCreateWithoutApprovedAbsencesInput = {
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentCreateNestedManyWithoutCashierInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageCreateNestedManyWithoutValidateurInput
  }

  export type UserUncheckedCreateWithoutApprovedAbsencesInput = {
    id?: number
    email: string
    passwordHash: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    phone?: string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    lastLogin?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    journalAudit?: JournalAuditUncheckedCreateNestedManyWithoutUtilisateurInput
    processedPayments?: PaymentUncheckedCreateNestedManyWithoutCashierInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    createdFactures?: CompanyFactureUncheckedCreateNestedManyWithoutCreatorInput
    createdPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutCreatorInput
    approvedPayRuns?: CompanyPayRunUncheckedCreateNestedManyWithoutApproverInput
    processedPaymentsCompany?: CompanyPaiementUncheckedCreateNestedManyWithoutProcessorInput
    uploadedDocuments?: CompanyDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdModeles?: CompanyModeleDocumentUncheckedCreateNestedManyWithoutCreatorInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedCreateNestedManyWithoutModifierInput
    validatedPointages?: PointageUncheckedCreateNestedManyWithoutValidateurInput
  }

  export type UserCreateOrConnectWithoutApprovedAbsencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedAbsencesInput, UserUncheckedCreateWithoutApprovedAbsencesInput>
  }

  export type EmployeeUpsertWithoutAbsencesInput = {
    update: XOR<EmployeeUpdateWithoutAbsencesInput, EmployeeUncheckedUpdateWithoutAbsencesInput>
    create: XOR<EmployeeCreateWithoutAbsencesInput, EmployeeUncheckedCreateWithoutAbsencesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAbsencesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAbsencesInput, EmployeeUncheckedUpdateWithoutAbsencesInput>
  }

  export type EmployeeUpdateWithoutAbsencesInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    entreprise?: EntrepriseUpdateOneRequiredWithoutEmployeesNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAbsencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type UserUpsertWithoutApprovedAbsencesInput = {
    update: XOR<UserUpdateWithoutApprovedAbsencesInput, UserUncheckedUpdateWithoutApprovedAbsencesInput>
    create: XOR<UserCreateWithoutApprovedAbsencesInput, UserUncheckedCreateWithoutApprovedAbsencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedAbsencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedAbsencesInput, UserUncheckedUpdateWithoutApprovedAbsencesInput>
  }

  export type UserUpdateWithoutApprovedAbsencesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUpdateManyWithoutValidateurNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedAbsencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    journalAudit?: JournalAuditUncheckedUpdateManyWithoutUtilisateurNestedInput
    processedPayments?: PaymentUncheckedUpdateManyWithoutCashierNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    createdFactures?: CompanyFactureUncheckedUpdateManyWithoutCreatorNestedInput
    createdPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutCreatorNestedInput
    approvedPayRuns?: CompanyPayRunUncheckedUpdateManyWithoutApproverNestedInput
    processedPaymentsCompany?: CompanyPaiementUncheckedUpdateManyWithoutProcessorNestedInput
    uploadedDocuments?: CompanyDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdModeles?: CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorNestedInput
    modifiedSalaries?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierNestedInput
    validatedPointages?: PointageUncheckedUpdateManyWithoutValidateurNestedInput
  }

  export type JournalAuditCreateManyUtilisateurInput = {
    id?: number
    action: string
    nomTable: string
    idEnregistrement?: number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
  }

  export type PaymentCreateManyCashierInput = {
    id?: number
    employeeId: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    title: string
    message: string
    type?: $Enums.NotificationType
    category: string
    isRead?: boolean
    link?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFactureCreateManyCreatorInput = {
    id?: number
    employeeId: number
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyPayRunCreateManyCreatorInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    periodePaieId: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
  }

  export type CompanyPayRunCreateManyApproverInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    periodePaieId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
  }

  export type CompanyPaiementCreateManyProcessorInput = {
    id?: number
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId: number
    creeLe?: Date | string
  }

  export type CompanyDocumentCreateManyUploaderInput = {
    id?: number
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    employeId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyModeleDocumentCreateManyCreatorInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    entrepriseId: number
    version?: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyHistoriqueSalaireCreateManyModifierInput = {
    id?: number
    employeId: number
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
  }

  export type PointageCreateManyValidateurInput = {
    id?: number
    employeId: number
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type AbsenceCreateManyApprobateurInput = {
    id?: number
    employeId: number
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type JournalAuditUpdateWithoutUtilisateurInput = {
    action?: StringFieldUpdateOperationsInput | string
    nomTable?: StringFieldUpdateOperationsInput | string
    idEnregistrement?: NullableIntFieldUpdateOperationsInput | number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalAuditUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    nomTable?: StringFieldUpdateOperationsInput | string
    idEnregistrement?: NullableIntFieldUpdateOperationsInput | number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalAuditUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    nomTable?: StringFieldUpdateOperationsInput | string
    idEnregistrement?: NullableIntFieldUpdateOperationsInput | number | null
    anciennes_valeurs?: NullableJsonNullValueInput | InputJsonValue
    nouvelles_valeurs?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutCashierInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCashierInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCashierInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFactureUpdateWithoutCreatorInput = {
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutFacturesNestedInput
    lignesFacture?: CompanyLigneFactureUpdateManyWithoutFactureNestedInput
  }

  export type CompanyFactureUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesFacture?: CompanyLigneFactureUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type CompanyFactureUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPayRunUpdateWithoutCreatorInput = {
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entreprise?: EntrepriseUpdateOneRequiredWithoutPayRunsNestedInput
    periodePaie?: CompanyPeriodePaieUpdateOneRequiredWithoutPayRunsNestedInput
    approver?: UserUpdateOneWithoutApprovedPayRunsNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyPayRunUpdateWithoutApproverInput = {
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entreprise?: EntrepriseUpdateOneRequiredWithoutPayRunsNestedInput
    periodePaie?: CompanyPeriodePaieUpdateOneRequiredWithoutPayRunsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPayRunsNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyPaiementUpdateWithoutProcessorInput = {
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    bulletin?: CompanyBulletinUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type CompanyPaiementUncheckedUpdateWithoutProcessorInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPaiementUncheckedUpdateManyWithoutProcessorInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    bulletinId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUpdateWithoutUploaderInput = {
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    employeId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    employeId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyModeleDocumentUpdateWithoutCreatorInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneRequiredWithoutModelesNestedInput
  }

  export type CompanyModeleDocumentUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyModeleDocumentUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    entrepriseId?: IntFieldUpdateOperationsInput | number
    version?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHistoriqueSalaireUpdateWithoutModifierInput = {
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSalaryHistoryNestedInput
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateWithoutModifierInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateManyWithoutModifierInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointageUpdateWithoutValidateurInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employe?: EmployeeUpdateOneRequiredWithoutPointagesNestedInput
  }

  export type PointageUncheckedUpdateWithoutValidateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointageUncheckedUpdateManyWithoutValidateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUpdateWithoutApprobateurInput = {
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employe?: EmployeeUpdateOneRequiredWithoutAbsencesNestedInput
  }

  export type AbsenceUncheckedUpdateWithoutApprobateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUncheckedUpdateManyWithoutApprobateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeId?: IntFieldUpdateOperationsInput | number
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyEmployeeInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    status?: $Enums.PaymentStatus
    notes?: string | null
    processedBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyFactureCreateManyEmployeeInput = {
    id?: number
    numeroFacture: string
    montant: Decimal | DecimalJsLike | number | string
    description?: string | null
    statut?: $Enums.CompanyStatutFacture
    dateEcheance?: Date | string | null
    datePaiement?: Date | string | null
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyBulletinCreateManyEmployeeInput = {
    id?: number
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    payRunId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyDocumentCreateManyEmployeeInput = {
    id?: number
    type: string
    titre: string
    description?: string | null
    cheminFichier: string
    tailleFichier: number
    mimeType: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags: string
    uploadePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyHistoriqueSalaireCreateManyEmployeeInput = {
    id?: number
    ancienSalaire: Decimal | DecimalJsLike | number | string
    nouveauSalaire: Decimal | DecimalJsLike | number | string
    dateEffet: Date | string
    motif: string
    notes?: string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar: number
    creeLe?: Date | string
  }

  export type PointageCreateManyEmployeInput = {
    id?: number
    date: Date | string
    heureArrivee?: Date | string | null
    heureDepart?: Date | string | null
    statut?: $Enums.StatutPointage
    typePointage?: $Enums.TypePointage
    commentaire?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    ipAddress?: string | null
    deviceInfo?: string | null
    validePar?: number | null
    dateValidation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type AbsenceCreateManyEmployeInput = {
    id?: number
    typeAbsence: $Enums.TypeAbsence
    dateDebut: Date | string
    dateFin: Date | string
    motif?: string | null
    statut?: $Enums.StatutAbsence
    joursOuvres: number
    heuresAbsence: Decimal | DecimalJsLike | number | string
    commentaire?: string | null
    pieceJointe?: string | null
    approuvePar?: number | null
    dateApprobation?: Date | string | null
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type PaymentUpdateWithoutEmployeeInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashier?: UserUpdateOneWithoutProcessedPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyFactureUpdateWithoutEmployeeInput = {
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedFacturesNestedInput
    lignesFacture?: CompanyLigneFactureUpdateManyWithoutFactureNestedInput
  }

  export type CompanyFactureUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    lignesFacture?: CompanyLigneFactureUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type CompanyFactureUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroFacture?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumCompanyStatutFactureFieldUpdateOperationsInput | $Enums.CompanyStatutFacture
    dateEcheance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datePaiement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBulletinUpdateWithoutEmployeeInput = {
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRun?: CompanyPayRunUpdateOneRequiredWithoutBulletinsNestedInput
    paiements?: CompanyPaiementUpdateManyWithoutBulletinNestedInput
  }

  export type CompanyBulletinUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    payRunId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: CompanyPaiementUncheckedUpdateManyWithoutBulletinNestedInput
  }

  export type CompanyBulletinUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    payRunId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUpdateWithoutEmployeeInput = {
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type CompanyDocumentUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    uploadePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyDocumentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tags?: StringFieldUpdateOperationsInput | string
    uploadePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHistoriqueSalaireUpdateWithoutEmployeeInput = {
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifier?: UserUpdateOneRequiredWithoutModifiedSalariesNestedInput
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ancienSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nouveauSalaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateEffet?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: NullableJsonNullValueInput | InputJsonValue
    modifiePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointageUpdateWithoutEmployeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    validateur?: UserUpdateOneWithoutValidatedPointagesNestedInput
  }

  export type PointageUncheckedUpdateWithoutEmployeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    validePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointageUncheckedUpdateManyWithoutEmployeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureArrivee?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    heureDepart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: EnumStatutPointageFieldUpdateOperationsInput | $Enums.StatutPointage
    typePointage?: EnumTypePointageFieldUpdateOperationsInput | $Enums.TypePointage
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    validePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUpdateWithoutEmployeInput = {
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approbateur?: UserUpdateOneWithoutApprovedAbsencesNestedInput
  }

  export type AbsenceUncheckedUpdateWithoutEmployeInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AbsenceUncheckedUpdateManyWithoutEmployeInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeAbsence?: EnumTypeAbsenceFieldUpdateOperationsInput | $Enums.TypeAbsence
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutAbsenceFieldUpdateOperationsInput | $Enums.StatutAbsence
    joursOuvres?: IntFieldUpdateOperationsInput | number
    heuresAbsence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    pieceJointe?: NullableStringFieldUpdateOperationsInput | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    dateApprobation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyEntrepriseInput = {
    id?: number
    userId: number
    employeeId: string
    department?: string | null
    position?: string | null
    contractType?: $Enums.ContractType
    salary?: Decimal | DecimalJsLike | number | string | null
    dailyRate?: Decimal | DecimalJsLike | number | string | null
    hourlyRate?: Decimal | DecimalJsLike | number | string | null
    hireDate?: Date | string | null
    phone?: string | null
    address?: string | null
    status?: $Enums.EmployeeStatus
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyPayRunCreateManyEntrepriseInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodePaieId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
  }

  export type CompanyTemplateCreateManyEntrepriseInput = {
    id?: number
    typeTemplate: string
    nom: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estDefaut?: boolean
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanySettingCreateManyEntrepriseInput = {
    id?: number
    cle: string
    valeur: string
    description?: string | null
    typeData: string
    estEncrypte?: boolean
    modifieLe?: Date | string
  }

  export type CompanyModeleDocumentCreateManyEntrepriseInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    contenu: string
    variables: JsonNullValueInput | InputJsonValue
    estActif?: boolean
    version?: number
    creePar: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyPeriodePaieCreateManyEntrepriseInput = {
    id?: number
    nom: string
    dateDebut: Date | string
    dateFin: Date | string
    estCloturee?: boolean
    dateReglement?: Date | string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyConfigurationPaieCreateManyEntrepriseInput = {
    id?: number
    jourPaie: number
    periodeCalcul: string
    regleArrondi: string
    deviseSecondaire?: string | null
    tauxChange?: Decimal | DecimalJsLike | number | string | null
    formatNumeration: JsonNullValueInput | InputJsonValue
    regleValidation: JsonNullValueInput | InputJsonValue
    parametresCalcul: JsonNullValueInput | InputJsonValue
    modifieLe?: Date | string
  }

  export type EmployeeUpdateWithoutEntrepriseInput = {
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
    payments?: PaymentUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    factures?: CompanyFactureUncheckedUpdateManyWithoutEmployeeNestedInput
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: CompanyDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryHistory?: CompanyHistoriqueSalaireUncheckedUpdateManyWithoutEmployeeNestedInput
    pointages?: PointageUncheckedUpdateManyWithoutEmployeNestedInput
    absences?: AbsenceUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dailyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPayRunUpdateWithoutEntrepriseInput = {
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    periodePaie?: CompanyPeriodePaieUpdateOneRequiredWithoutPayRunsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPayRunsNestedInput
    approver?: UserUpdateOneWithoutApprovedPayRunsNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    periodePaieId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyTemplateUpdateWithoutEntrepriseInput = {
    typeTemplate?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estDefaut?: BoolFieldUpdateOperationsInput | boolean
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyTemplateUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeTemplate?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estDefaut?: BoolFieldUpdateOperationsInput | boolean
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyTemplateUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeTemplate?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estDefaut?: BoolFieldUpdateOperationsInput | boolean
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingUpdateWithoutEntrepriseInput = {
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeData?: StringFieldUpdateOperationsInput | string
    estEncrypte?: BoolFieldUpdateOperationsInput | boolean
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeData?: StringFieldUpdateOperationsInput | string
    estEncrypte?: BoolFieldUpdateOperationsInput | boolean
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    typeData?: StringFieldUpdateOperationsInput | string
    estEncrypte?: BoolFieldUpdateOperationsInput | boolean
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyModeleDocumentUpdateWithoutEntrepriseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedModelesNestedInput
  }

  export type CompanyModeleDocumentUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyModeleDocumentUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    estActif?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPeriodePaieUpdateWithoutEntrepriseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRuns?: CompanyPayRunUpdateManyWithoutPeriodePaieNestedInput
  }

  export type CompanyPeriodePaieUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    payRuns?: CompanyPayRunUncheckedUpdateManyWithoutPeriodePaieNestedInput
  }

  export type CompanyPeriodePaieUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estCloturee?: BoolFieldUpdateOperationsInput | boolean
    dateReglement?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyConfigurationPaieUpdateWithoutEntrepriseInput = {
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    reglesDeduction?: CompanyRegleDeductionUpdateManyWithoutConfigurationNestedInput
  }

  export type CompanyConfigurationPaieUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    reglesDeduction?: CompanyRegleDeductionUncheckedUpdateManyWithoutConfigurationNestedInput
  }

  export type CompanyConfigurationPaieUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    jourPaie?: IntFieldUpdateOperationsInput | number
    periodeCalcul?: StringFieldUpdateOperationsInput | string
    regleArrondi?: StringFieldUpdateOperationsInput | string
    deviseSecondaire?: NullableStringFieldUpdateOperationsInput | string | null
    tauxChange?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    formatNumeration?: JsonNullValueInput | InputJsonValue
    regleValidation?: JsonNullValueInput | InputJsonValue
    parametresCalcul?: JsonNullValueInput | InputJsonValue
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyLigneFactureCreateManyFactureInput = {
    id?: number
    description: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    prixTotal: Decimal | DecimalJsLike | number | string
    creeLe?: Date | string
  }

  export type CompanyLigneFactureUpdateWithoutFactureInput = {
    description?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyLigneFactureUncheckedUpdateWithoutFactureInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyLigneFactureUncheckedUpdateManyWithoutFactureInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyBulletinCreateManyPayRunInput = {
    id?: number
    numeroBulletin: string
    datePaiement: Date | string
    joursTravailles: number
    heuresTravailes: number
    salaireBrut: Decimal | DecimalJsLike | number | string
    salaireBase: Decimal | DecimalJsLike | number | string
    montantHeuresSupp: Decimal | DecimalJsLike | number | string
    montantBonus: Decimal | DecimalJsLike | number | string
    indemnites: Decimal | DecimalJsLike | number | string
    deductions: JsonNullValueInput | InputJsonValue
    totalDeductions: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    montantPaye: Decimal | DecimalJsLike | number | string
    resteAPayer: Decimal | DecimalJsLike | number | string
    statutPaiement: string
    cheminPDF?: string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: boolean
    employeId: number
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyBulletinUpdateWithoutPayRunInput = {
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutBulletinsNestedInput
    paiements?: CompanyPaiementUpdateManyWithoutBulletinNestedInput
  }

  export type CompanyBulletinUncheckedUpdateWithoutPayRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    employeId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: CompanyPaiementUncheckedUpdateManyWithoutBulletinNestedInput
  }

  export type CompanyBulletinUncheckedUpdateManyWithoutPayRunInput = {
    id?: IntFieldUpdateOperationsInput | number
    numeroBulletin?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    joursTravailles?: IntFieldUpdateOperationsInput | number
    heuresTravailes?: IntFieldUpdateOperationsInput | number
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantHeuresSupp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantBonus?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    indemnites?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: JsonNullValueInput | InputJsonValue
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantPaye?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    resteAPayer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statutPaiement?: StringFieldUpdateOperationsInput | string
    cheminPDF?: NullableStringFieldUpdateOperationsInput | string | null
    calculs?: NullableJsonNullValueInput | InputJsonValue
    estVerrouille?: BoolFieldUpdateOperationsInput | boolean
    employeId?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPaiementCreateManyBulletinInput = {
    id?: number
    referenceTransaction: string
    montant: Decimal | DecimalJsLike | number | string
    methodePaiement: string
    referencePaiement?: string | null
    datePaiement: Date | string
    notes?: string | null
    cheminRecu?: string | null
    statut: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    traitePar: number
    creeLe?: Date | string
  }

  export type CompanyPaiementUpdateWithoutBulletinInput = {
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    processor?: UserUpdateOneRequiredWithoutProcessedPaymentsCompanyNestedInput
  }

  export type CompanyPaiementUncheckedUpdateWithoutBulletinInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    traitePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPaiementUncheckedUpdateManyWithoutBulletinInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceTransaction?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    methodePaiement?: StringFieldUpdateOperationsInput | string
    referencePaiement?: NullableStringFieldUpdateOperationsInput | string | null
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    cheminRecu?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    traitePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyPayRunCreateManyPeriodePaieInput = {
    id?: number
    reference: string
    dateDebut: Date | string
    dateFin: Date | string
    datePaiement: Date | string
    statut?: $Enums.CompanyStatutPayRun
    totalBrut: Decimal | DecimalJsLike | number | string
    totalNet: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    nombreEmployes: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId: number
    creePar: number
    creeLe?: Date | string
    approuveLe?: Date | string | null
    approuvePar?: number | null
  }

  export type CompanyPayRunUpdateWithoutPeriodePaieInput = {
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entreprise?: EntrepriseUpdateOneRequiredWithoutPayRunsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedPayRunsNestedInput
    approver?: UserUpdateOneWithoutApprovedPayRunsNestedInput
    bulletins?: CompanyBulletinUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateWithoutPeriodePaieInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
    bulletins?: CompanyBulletinUncheckedUpdateManyWithoutPayRunNestedInput
  }

  export type CompanyPayRunUncheckedUpdateManyWithoutPeriodePaieInput = {
    id?: IntFieldUpdateOperationsInput | number
    reference?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    statut?: EnumCompanyStatutPayRunFieldUpdateOperationsInput | $Enums.CompanyStatutPayRun
    totalBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nombreEmployes?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    entrepriseId?: IntFieldUpdateOperationsInput | number
    creePar?: IntFieldUpdateOperationsInput | number
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    approuveLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approuvePar?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CompanyRegleDeductionCreateManyConfigurationInput = {
    id?: number
    nom: string
    description?: string | null
    type: string
    formule: string
    conditionsApplication: JsonNullValueInput | InputJsonValue
    estObligatoire?: boolean
    ordre: number
    estActif?: boolean
    creeLe?: Date | string
    modifieLe?: Date | string
  }

  export type CompanyRegleDeductionUpdateWithoutConfigurationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    formule?: StringFieldUpdateOperationsInput | string
    conditionsApplication?: JsonNullValueInput | InputJsonValue
    estObligatoire?: BoolFieldUpdateOperationsInput | boolean
    ordre?: IntFieldUpdateOperationsInput | number
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRegleDeductionUncheckedUpdateWithoutConfigurationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    formule?: StringFieldUpdateOperationsInput | string
    conditionsApplication?: JsonNullValueInput | InputJsonValue
    estObligatoire?: BoolFieldUpdateOperationsInput | boolean
    ordre?: IntFieldUpdateOperationsInput | number
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyRegleDeductionUncheckedUpdateManyWithoutConfigurationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    formule?: StringFieldUpdateOperationsInput | string
    conditionsApplication?: JsonNullValueInput | InputJsonValue
    estObligatoire?: BoolFieldUpdateOperationsInput | boolean
    ordre?: IntFieldUpdateOperationsInput | number
    estActif?: BoolFieldUpdateOperationsInput | boolean
    creeLe?: DateTimeFieldUpdateOperationsInput | Date | string
    modifieLe?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}